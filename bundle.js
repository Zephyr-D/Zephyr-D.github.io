(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dl = require("deeplearn");
const nn_art_util = require("./nn_art_util");
const MAX_LAYERS = 10;
const math = dl.ENV.math;
const activationFunctionMap = {
    'tanh': x => x.tanh(),
    'sin': x => x.sin(),
    'relu': x => x.relu(),
    'step': x => x.step()
};
const NUM_IMAGE_SPACE_VARIABLES = 3;
const NUM_LATENT_VARIABLES = 2;
class CPPN {
    constructor(inferenceCanvas) {
        this.inferenceCanvas = inferenceCanvas;
        this.intermediateWeights = [];
        this.z1Counter = 0;
        this.z2Counter = 0;
        this.isInferring = false;
        this.inferenceCanvas.width = Math.round(window.innerWidth / 4);
        this.inferenceCanvas.height = Math.round(window.innerHeight / 6);
        this.inputAtlas = nn_art_util.createInputAtlas(this.inferenceCanvas.width, this.inferenceCanvas.height, NUM_IMAGE_SPACE_VARIABLES, NUM_LATENT_VARIABLES);
        this.ones = dl.Array2D.ones([this.inputAtlas.shape[0], 1]);
    }
    generateWeights(neuronsPerLayer, weightsStdev) {
        for (let i = 0; i < this.intermediateWeights.length; i++) {
            this.intermediateWeights[i].dispose();
        }
        this.intermediateWeights = [];
        if (this.firstLayerWeights != null) {
            this.firstLayerWeights.dispose();
        }
        if (this.lastLayerWeights != null) {
            this.lastLayerWeights.dispose();
        }
        this.firstLayerWeights = dl.truncatedNormal([NUM_IMAGE_SPACE_VARIABLES + NUM_LATENT_VARIABLES, neuronsPerLayer], 0, weightsStdev);
        for (let i = 0; i < MAX_LAYERS; i++) {
            this.intermediateWeights.push(dl.truncatedNormal([neuronsPerLayer, neuronsPerLayer], 0, weightsStdev));
        }
        this.lastLayerWeights = dl.Array2D.randTruncatedNormal([neuronsPerLayer, 1], 0, weightsStdev);
    }
    setActivationFunction(activationFunction) {
        this.selectedActivationFunctionName = activationFunction;
    }
    setNumLayers(numLayers) {
        this.numLayers = numLayers;
    }
    setZ1Scale(z1Scale) {
        this.z1Scale = z1Scale;
    }
    setZ2Scale(z2Scale) {
        this.z2Scale = z2Scale;
    }
    start() {
        this.isInferring = true;
        this.runInferenceLoop();
    }
    async runInferenceLoop() {
        if (!this.isInferring) {
            return;
        }
        this.z1Counter += 1 / this.z1Scale;
        this.z2Counter += 1 / this.z2Scale;
        const lastOutput = math.scope(() => {
            const z1 = dl.Scalar.new(Math.sin(this.z1Counter));
            const z2 = dl.Scalar.new(Math.cos(this.z2Counter));
            const z1Mat = z1.mul(this.ones);
            const z2Mat = z2.mul(this.ones);
            const concatAxis = 1;
            const latentVars = z1Mat.concat(z2Mat, concatAxis);
            const activation = (x) => activationFunctionMap[this.selectedActivationFunctionName](x);
            let lastOutput = this.inputAtlas.concat(latentVars, concatAxis);
            lastOutput = activation(lastOutput.matMul(this.firstLayerWeights));
            for (let i = 0; i < this.numLayers; i++) {
                lastOutput = activation(lastOutput.matMul(this.intermediateWeights[i]));
            }
            return lastOutput.matMul(this.lastLayerWeights).sigmoid().reshape([
                this.inferenceCanvas.height, this.inferenceCanvas.width, 1
            ]);
        });
        await renderToCanvas(lastOutput, this.inferenceCanvas);
        await dl.util.nextFrame();
        this.runInferenceLoop();
    }
    stopInferenceLoop() {
        this.isInferring = false;
    }
}
exports.CPPN = CPPN;
async function renderToCanvas(a, canvas) {
    const [height, width,] = a.shape;
    const ctx = canvas.getContext('2d');
    const imageData = new ImageData(width, height);
    const data = await a.data();
    for (let i = 0; i < height * width; ++i) {
        const j = i * 4;
        const k = i;
        const gray = Math.round(255 * data[k]);
        imageData.data[j + 0] = gray;
        imageData.data[j + 1] = gray;
        imageData.data[j + 2] = gray;
        imageData.data[j + 3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
}

},{"./nn_art_util":3,"deeplearn":45}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const polymer_spec_1 = require("../polymer-spec");
const cppn_1 = require("./cppn");
const WEIGHTS_STDEV = .75;
const NNArtPolymer = polymer_spec_1.PolymerElement({
    is: 'nn-art',
    properties: {
        activationFunctionNames: Array,
        selectedActivationFunctionName: String
    }
});
class NNArt extends NNArtPolymer {
    ready() {
        this.inferenceCanvas =
            this.querySelector('#inference');
        this.inferenceCanvas.style.width = `${window.innerWidth}px`;
        this.inferenceCanvas.style.height = `${Math.round(window.innerHeight / 2)}px`;
        this.cppn = new cppn_1.CPPN(this.inferenceCanvas);
        this.activationFunctionNames = ['tanh', 'sin', 'relu', 'step'];
        this.selectedActivationFunctionName = 'tanh';
        this.cppn.setActivationFunction(this.selectedActivationFunctionName);
        this.querySelector('#activation-function-dropdown').addEventListener('iron-activate', (event) => {
            this.selectedActivationFunctionName = event.detail.selected;
            this.cppn.setActivationFunction(this.selectedActivationFunctionName);
        });
        const layersSlider = this.querySelector('#layers-slider');
        const layersCountElement = this.querySelector('#layers-count');
        layersSlider.addEventListener('immediate-value-changed', (event) => {
            this.numLayers = parseInt(event.target.immediateValue, 10);
            layersCountElement.innerText = this.numLayers.toString();
            this.cppn.setNumLayers(this.numLayers);
        });
        this.numLayers = parseInt(layersSlider.value, 10);
        layersCountElement.innerText = this.numLayers.toString();
        this.cppn.setNumLayers(this.numLayers);
        const neuronsSlider = this.querySelector('#neurons-slider');
        const neuronsCountElement = this.querySelector('#neurons-count');
        neuronsSlider.addEventListener('immediate-value-changed', (event) => {
            this.MAT_WIDTH = parseInt(event.target.immediateValue, 10);
            neuronsCountElement.innerText = this.MAT_WIDTH.toString();
            this.cppn.generateWeights(this.MAT_WIDTH, WEIGHTS_STDEV);
        });
        this.MAT_WIDTH = parseInt(neuronsSlider.value, 10);
        neuronsCountElement.innerText = this.MAT_WIDTH.toString();
        this.z1Scale = 10;
        this.cppn.setZ1Scale(convertZScale(this.z1Scale));
        this.z2Scale = 10;
        this.cppn.setZ2Scale(convertZScale(this.z2Scale));
        this.cppn.generateWeights(this.MAT_WIDTH, WEIGHTS_STDEV);
        this.cppn.start();
    }
}
function convertZScale(z) {
    return (103 - z);
}
document.registerElement(NNArt.prototype.is, NNArt);

},{"../polymer-spec":124,"./cppn":1}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dl = require("deeplearn");
function createInputAtlas(imageWidth, imageHeight, inputNumDimensions, numLatentVariables) {
    const coords = new Float32Array(imageWidth * imageHeight
        * inputNumDimensions);
    let dst = 0;
    for (let i = 0; i < imageWidth * imageHeight; i++) {
        for (let d = 0; d < inputNumDimensions; d++) {
            const x = i % imageWidth;
            const y = Math.floor(i / imageWidth);
            const coord = imagePixelToNormalizedCoord(x, y, imageWidth, imageHeight, numLatentVariables);
            coords[dst++] = coord[d];
        }
    }
    return dl.Array2D.new([imageWidth * imageHeight,
        inputNumDimensions], coords);
}
exports.createInputAtlas = createInputAtlas;
function imagePixelToNormalizedCoord(x, y, imageWidth, imageHeight, zSize) {
    const halfWidth = imageWidth * 0.5;
    const halfHeight = imageHeight * 0.5;
    const normX = (x - halfWidth) / imageWidth;
    const normY = (y - halfHeight) / imageHeight;
    const r = Math.sqrt(normX * normX + normY * normY);
    const result = [normX, normY, r];
    return result;
}
exports.imagePixelToNormalizedCoord = imagePixelToNormalizedCoord;

},{"deeplearn":45}],4:[function(require,module,exports){

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                if (xhr.status === 404) {
                    throw new Error("Not found variable " + varName);
                }
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error("Could not fetch variable " + varName + ": " + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"../math/ndarray":105}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].dataSync();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.dataSync();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }, 'float32'));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.dataSync();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"../math/ndarray":105,"../util":122}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"../math/ndarray":105,"../util":122}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var dataset_1 = require("./dataset");
var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
function getXhrDatasetConfig(jsonConfigPath) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', jsonConfigPath);
        xhr.onload = function () {
            resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function (error) {
            reject(error);
        };
        xhr.send();
    });
}
exports.getXhrDatasetConfig = getXhrDatasetConfig;
var XhrDataset = (function (_super) {
    __extends(XhrDataset, _super);
    function XhrDataset(xhrDatasetConfig) {
        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
        _this.xhrDatasetConfig = xhrDatasetConfig;
        return _this;
    }
    XhrDataset.prototype.getNDArray = function (info) {
        var dataPromise = info.dataType === 'png' ?
            parseTypedArrayFromPng(info, info.shape) :
            parseTypedArrayFromBinary(info);
        var inputSize = util.sizeFromShape(info.shape);
        return dataPromise.then(function (data) {
            var ndarrays = [];
            for (var i = 0; i < data.length / inputSize; i++) {
                var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                var ndarray = ndarray_1.NDArray.make(info.shape, { values: new Float32Array(values) }, 'float32');
                ndarrays.push(ndarray);
            }
            return ndarrays;
        });
    };
    XhrDataset.prototype.fetchData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });
            Promise.all(promises).then(function (data) {
                _this.dataset = data;
                resolve();
            });
        });
    };
    return XhrDataset;
}(dataset_1.InMemoryDataset));
exports.XhrDataset = XhrDataset;
function parseTypedArrayFromBinary(info) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', info.path);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function (event) {
            var data = (info.dataType === 'float32') ?
                new Float32Array(xhr.response) :
                new Uint8Array(xhr.response);
            resolve(data);
        };
        xhr.onerror = function (err) { return reject(err); };
        xhr.send();
    });
}
function parseGrayscaleImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx++] = data[i];
    }
}
function parseRGBImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx] = data[i];
        result[idx + 1] = data[i + 1];
        result[idx + 2] = data[i + 2];
        idx += 3;
    }
}
function parseImage(img, shape) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var N = img.height;
    var inputSize = util.sizeFromShape(shape);
    var result = new Uint8Array(N * inputSize);
    if (img.width !== shape[0] * shape[1]) {
        throw new Error("Image width (" + img.width + ") must be multiple of " +
            ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the ndarray"));
    }
    canvas.width = img.width;
    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
    var sx = 0;
    var sWidth = canvas.width;
    var sHeight = canvas.height;
    var dx = 0;
    var dy = 0;
    var dWidth = sWidth;
    var dHeight = sHeight;
    var depth = shape[2];
    var offset = 0;
    var numPasses = Math.ceil(N / canvas.height);
    for (var pass = 0; pass < numPasses; ++pass) {
        var sy = pass * canvas.height;
        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
            canvas.height = N % canvas.height;
            sHeight = canvas.height;
            dHeight = sHeight;
        }
        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
            parseRGBImageData(data, result, offset);
        offset += canvas.height * inputSize;
    }
    return result;
}
function parseTypedArrayFromPng(info, shape) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.setAttribute('crossOrigin', '');
        img.onload = function () {
            var result = parseImage(img, shape);
            img.src = '';
            img = null;
            resolve(result);
        };
        img.src = info.path;
    });
}

},{"../math/ndarray":105,"../util":122,"./dataset":6}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],10:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var math_1 = require("./math/math");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    }
];
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :
        'EXT_disjoint_timer_query_webgl2';
    var ext = gl.getExtension(extensionName);
    var isExtEnabled = ext != null;
    if (gl != null) {
        loseContext(gl);
    }
    return isExtEnabled;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (gl.getExtension('OES_texture_float') == null) {
            return false;
        }
    }
    else {
        if (gl.getExtension('EXT_color_buffer_float') == null) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var ext = gl.getExtension('WEBGL_get_buffer_sub_data_async');
    var isEnabled = ext != null;
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        this.globalMath = null;
        this.BACKEND_REGISTRY = {};
        this.backends = this.BACKEND_REGISTRY;
        if (features != null) {
            this.features = features;
        }
    }
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.getBestBackendType = function () {
        var orderedBackends = ['webgl', 'cpu'];
        for (var i = 0; i < orderedBackends.length; ++i) {
            var backendId = orderedBackends[i];
            if (backendId in this.backends) {
                return backendId;
            }
        }
        throw new Error('No backend found in registry.');
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return false;
            }
            return isWebGLDisjointQueryTimerEnabled(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    Environment.prototype.setFeatures = function (features) {
        this.reset();
        this.features = features;
        this.backends = {};
    };
    Environment.prototype.reset = function () {
        this.features = getFeaturesFromURL();
        if (this.globalMath != null) {
            this.globalMath.dispose();
            this.globalMath = null;
        }
        if (this.backends !== this.BACKEND_REGISTRY) {
            for (var name_1 in this.backends) {
                this.backends[name_1].dispose();
            }
            this.backends = this.BACKEND_REGISTRY;
        }
    };
    Environment.prototype.setMath = function (math) {
        this.globalMath = math;
    };
    Environment.prototype.getBackend = function (name) {
        return this.backends[name];
    };
    Environment.prototype.addCustomBackend = function (name, factory) {
        if (name in this.backends) {
            throw new Error(name + " backend was already registered");
        }
        try {
            var backend = factory();
            this.backends[name] = backend;
            return true;
        }
        catch (err) {
            return false;
        }
    };
    Environment.prototype.registerBackend = function (name, factory) {
        if (name in this.BACKEND_REGISTRY) {
            throw new Error(name + " backend was already registered as global");
        }
        try {
            var backend = factory();
            this.BACKEND_REGISTRY[name] = backend;
            return true;
        }
        catch (err) {
            return false;
        }
    };
    Object.defineProperty(Environment.prototype, "math", {
        get: function () {
            if (this.globalMath == null) {
                var bestBackend = this.getBestBackendType();
                var safeMode = false;
                this.setMath(new math_1.NDArrayMath(bestBackend, safeMode));
            }
            return this.globalMath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Environment.prototype, "engine", {
        get: function () {
            return this.globalMath.engine;
        },
        enumerable: true,
        configurable: true
    });
    return Environment;
}());
exports.Environment = Environment;
var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
function getGlobalNamespace() {
    var ns;
    if (typeof (window) !== 'undefined') {
        ns = window;
    }
    else if (typeof (global) !== 'undefined') {
        ns = global;
    }
    else {
        throw new Error('Could not find a global object');
    }
    return ns;
}
function getOrMakeEnvironment() {
    var ns = getGlobalNamespace();
    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
    return ns.ENV;
}
exports.ENV = getOrMakeEnvironment();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./device_util":9,"./math/math":103,"./util":122}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var TanHFunc = (function () {
    function TanHFunc() {
        this.one = ndarray_1.Scalar.new(1);
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.tanh(x);
    };
    TanHFunc.prototype.der = function (math, x, y) {
        var _this = this;
        return math.scope(function () {
            var ySquared = math.multiplyStrict(y, y);
            return math.subtract(_this.one, ySquared);
        });
    };
    TanHFunc.prototype.dispose = function () {
        this.one.dispose();
    };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.relu(x);
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.step(x);
    };
    ReLUFunc.prototype.dispose = function () { };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var LeakyReluFunc = (function () {
    function LeakyReluFunc(alpha) {
        this.alpha = alpha;
    }
    LeakyReluFunc.prototype.output = function (math, x) {
        return math.leakyRelu(x, this.alpha);
    };
    LeakyReluFunc.prototype.der = function (math, x, y) {
        return math.step(x, this.alpha);
    };
    LeakyReluFunc.prototype.dispose = function () { };
    return LeakyReluFunc;
}());
exports.LeakyReluFunc = LeakyReluFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.sigmoid(x);
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.multiplyStrict(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    SigmoidFunc.prototype.dispose = function () { };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
        this.two = ndarray_1.Scalar.new(2);
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.multiplyStrict(x, x);
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.multiply(this.two, x);
    };
    SquareFunc.prototype.dispose = function () {
        this.two.dispose();
    };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;
var EluFunc = (function () {
    function EluFunc() {
    }
    EluFunc.prototype.output = function (math, x) {
        return math.elu(x);
    };
    EluFunc.prototype.der = function (math, x, y) {
        throw new Error('Not implemented');
    };
    EluFunc.prototype.dispose = function () { };
    return EluFunc;
}());
exports.EluFunc = EluFunc;

},{"../math/ndarray":105}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("../initializers");
var concat_util = require("../math/concat_util");
var conv_util = require("../math/conv_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var flatValues = util.flatten(value);
            var vals = new Float32Array(flatValues);
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat1d = function (x1, x2) {
        return this.addNodeAndReturnOutput(new Concat1DNode(this, x1, x2));
    };
    Graph.prototype.concat2d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat2DNode(this, x1, x2, axis));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.concat4d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat4DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.leakyRelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
    };
    Graph.prototype.prelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new PReLUNode(this, x, alpha));
    };
    Graph.prototype.elu = function (x) {
        return this.addNodeAndReturnOutput(new EluNode(this, x));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
            (" of shape (" + this.x.shape + ") does not match size of ") +
            ("requested shape " + this.shape + "."));
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                ("shape: " + this.c1.shape));
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                ("shape: " + this.c2.shape));
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1
            ? t2.shape
            : (t1.shape.length < t2.shape.length ? t2.shape : t1.shape))) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape) ||
            (this.t1.shape.length === 2 && this.t2.shape.length === 1 &&
                this.t1.shape[1] === this.t2.shape[0]) ||
            (this.t1.shape.length === 1 && this.t2.shape.length === 2 &&
                this.t1.shape[0] === this.t2.shape[1]), 'Error adding add operation op: one of inputs must be scalar, ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match,") +
            'or one of them can be broadcasted (2D and 1D).');
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat1DNode = (function (_super) {
    __extends(Concat1DNode, _super);
    function Concat1DNode(graph, x1, x2) {
        return _super.call(this, graph, 'Concat1D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape1D(x1.shape, x2.shape))) || this;
    }
    Concat1DNode.prototype.validate = function () { };
    Concat1DNode.X1 = 'x1';
    Concat1DNode.X2 = 'x2';
    return Concat1DNode;
}(Node));
exports.Concat1DNode = Concat1DNode;
var Concat2DNode = (function (_super) {
    __extends(Concat2DNode, _super);
    function Concat2DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat2D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat2DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat2DNode.X1 = 'x1';
    Concat2DNode.X2 = 'x2';
    Concat2DNode.AXIS = 'axis';
    return Concat2DNode;
}(Node));
exports.Concat2DNode = Concat2DNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
var Concat4DNode = (function (_super) {
    __extends(Concat4DNode, _super);
    function Concat4DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat4D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat4DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat4DNode.X1 = 'x1';
    Concat4DNode.X2 = 'x2';
    Concat4DNode.AXIS = 'axis';
    return Concat4DNode;
}(Node));
exports.Concat4DNode = Concat4DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                (this.x1.shape + " and " + this.x2.shape + " must match."));
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape.toString() +
                (" must match size of vector with shape " + this.x2.shape + "."));
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                " must match first dimension of matrix with " +
                ("shape " + this.x2.shape + "."));
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            (this.w.shape + "."));
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            (this.b.shape + "."));
        util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
            ("must match input depth for weights (" + this.w.shape[2] + ")."));
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var LeakyReLUNode = (function (_super) {
    __extends(LeakyReLUNode, _super);
    function LeakyReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'LeakyReLU', { x: x }, new Tensor(x.shape)) || this;
        _this.alpha = alpha;
        return _this;
    }
    LeakyReLUNode.prototype.validate = function () { };
    LeakyReLUNode.X = 'x';
    return LeakyReLUNode;
}(Node));
exports.LeakyReLUNode = LeakyReLUNode;
var PReLUNode = (function (_super) {
    __extends(PReLUNode, _super);
    function PReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'PReLU', { x: x, alpha: alpha }, new Tensor(x.shape)) || this;
        _this.x = x;
        _this.alpha = alpha;
        return _this;
    }
    PReLUNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.alpha.shape), 'Error adding pRelu op: the ' +
            ("shapes x: " + this.x.shape + " and alpha: " + this.alpha.shape + " must match."));
    };
    PReLUNode.X = 'x';
    PReLUNode.ALPHA = 'alpha';
    return PReLUNode;
}(Node));
exports.PReLUNode = PReLUNode;
var EluNode = (function (_super) {
    __extends(EluNode, _super);
    function EluNode(graph, x) {
        return _super.call(this, graph, 'Elu', { x: x }, new Tensor(x.shape)) || this;
    }
    EluNode.prototype.validate = function () { };
    EluNode.X = 'x';
    return EluNode;
}(Node));
exports.EluNode = EluNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
            ("must match target shape (" + this.target.shape + ")."));
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
            ("must match prediction shape (" + this.prediction.shape + ")."));
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
            ("must match x2 shape (" + this.x2.shape + ")."));
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;

},{"../initializers":46,"../math/concat_util":95,"../math/conv_util":97,"../math/ndarray":105,"../util":122}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var session_1 = require("./session");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        requestAnimationFrame(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            requestAnimationFrame(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    var nextCopy = feedEntry.data.getNextCopy(_this.math);
                    ndarrayFeedEntries.push({ tensor: feedEntry.tensor, data: nextCopy });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].dataSync();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
        window.clearTimeout(this.lastInferTimeoutID);
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue.toFloat());
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"../math/ndarray":105,"./session":42}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":12,"./priority_queue":41}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat_1 = require("./ops/concat");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.LeakyReLUNode) {
        return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
    }
    else if (node instanceof graph_1.PReLUNode) {
        return [new element_wise_activation_1.PReLU(node.inputs[graph_1.PReLUNode.X], node.inputs[graph_1.PReLUNode.ALPHA], node.output)];
    }
    else if (node instanceof graph_1.EluNode) {
        return [new element_wise_activation_1.Elu(node.inputs[graph_1.EluNode.X], node.output)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat1DNode) {
        return [new concat_1.Concat1D(node.inputs[graph_1.Concat1DNode.X1], node.inputs[graph_1.Concat1DNode.X2], node.output)];
    }
    else if (node instanceof graph_1.Concat2DNode) {
        return [new concat_1.Concat2D(node.inputs[graph_1.Concat2DNode.X1], node.inputs[graph_1.Concat2DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.Concat4DNode) {
        return [new concat_1.Concat4D(node.inputs[graph_1.Concat4DNode.X1], node.inputs[graph_1.Concat4DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error("Unsupported node type: " + node.constructor.name);
    }
}

},{"./graph":12,"./graph_util":14,"./ops/add":16,"./ops/argmax":17,"./ops/argmaxequals":18,"./ops/concat":19,"./ops/convolution":20,"./ops/divide":21,"./ops/element_wise_activation":22,"./ops/element_wise_cost":23,"./ops/exp":24,"./ops/linear_combination":25,"./ops/log":26,"./ops/matmul":27,"./ops/max_pool":28,"./ops/multiply":29,"./ops/reduce_sum":31,"./ops/reshape":32,"./ops/softmax":33,"./ops/subtract":34}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape) ||
            (x1Tensor.shape.length === 2 && x2Tensor.shape.length === 1 &&
                x1Tensor.shape[1] === x2Tensor.shape[0]) ||
            (x1Tensor.shape.length === 1 && x2Tensor.shape.length === 2 &&
                x1Tensor.shape[0] === x2Tensor.shape[1]), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape, ' +
            'or one of them can be broadcasted (2D and 1D).');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (_this.x1Tensor.shape.length === 1 &&
                    _this.x2Tensor.shape.length === 2 &&
                    _this.x1Tensor.shape[0] === _this.x2Tensor.shape[1]) {
                    var sum = math.sum(dy, 0);
                    gradientArrays.add(_this.x1Tensor, sum);
                }
                else if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.x1Tensor, sum);
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (_this.x1Tensor.shape.length === 2 &&
                    _this.x2Tensor.shape.length === 1 &&
                    _this.x1Tensor.shape[1] === _this.x2Tensor.shape[0]) {
                    var sum = math.sum(dy, 0);
                    gradientArrays.add(_this.x2Tensor, sum);
                }
                else if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.x2Tensor, sum);
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.clone(dy));
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../../util":122,"../graph_util":14,"./op":30}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"./op":30}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"./op":30}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../math/concat_util");
var util = require("../../util");
var op_1 = require("./op");
var Concat1D = (function (_super) {
    __extends(Concat1D, _super);
    function Concat1D(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Concat1D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat1D(x1, x2);
            inferecenArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat1D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        math.scope(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, 0, gradientArrays, inferenceArrays);
        });
    };
    return Concat1D;
}(op_1.Operation));
exports.Concat1D = Concat1D;
var Concat2D = (function (_super) {
    __extends(Concat2D, _super);
    function Concat2D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat2D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat2D(x1, x2, _this.axis);
            inferecenArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        math.scope(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat2D;
}(op_1.Operation));
exports.Concat2D = Concat2D;
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        math.scope(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;
var Concat4D = (function (_super) {
    __extends(Concat4D, _super);
    function Concat4D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat4D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat4D(x1, x2, _this.axis);
            inferecenArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat4D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        math.scope(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat4D;
}(op_1.Operation));
exports.Concat4D = Concat4D;
function concatBackProp(math, aTensor, bTensor, yTensor, axis, gradArrays, infArrays) {
    var dy = gradArrays.get(yTensor);
    var a = infArrays.get(aTensor);
    var b = infArrays.get(bTensor);
    var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
    var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
    var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
    var dy2D = dy.as2D(-1, a2D.shape[1] + b2D.shape[1]);
    var slice1Result = math.slice2D(dy2D, aBegin, aSize).reshapeAs(a);
    var slice2Result = math.slice2D(dy2D, bBegin, bSize).reshapeAs(b);
    gradArrays.add(aTensor, slice1Result);
    gradArrays.add(bTensor, slice2Result);
}

},{"../../math/concat_util":95,"../../util":122,"./op":30}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var filter = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var dw = math.conv2dDerFilter(x, dy, filter.shape, _this.stride, _this.zeroPad);
            var db = math.conv2dDerBias(dy);
            var dx = math.conv2dDerInput(x.shape, dy, filter, _this.stride, _this.zeroPad);
            gradientArrays.add(_this.wTensor, dw);
            gradientArrays.add(_this.bTensor, db);
            gradientArrays.add(_this.xTensor, dx);
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../../math/conv_util":97,"../../util":122,"./op":30}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(div));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../../util":122,"../graph_util":14,"./op":30}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = require("../activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
            dydx.dispose();
        });
    };
    ElementWiseActivation.prototype.dispose = function () {
        this.func.dispose();
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(xTensor, yTensor, alpha) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
    }
    return LeakyReLU;
}(ElementWiseActivation));
exports.LeakyReLU = LeakyReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;
var Elu = (function (_super) {
    __extends(Elu, _super);
    function Elu(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.EluFunc()) || this;
    }
    return Elu;
}(ElementWiseActivation));
exports.Elu = Elu;
var PReLU = (function (_super) {
    __extends(PReLU, _super);
    function PReLU(xTensor, alphaTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.alphaTensor = alphaTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    PReLU.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var alpha = inferenceArrays.get(this.alphaTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.prelu(x, alpha)));
        });
    };
    PReLU.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Not implemented');
    };
    return PReLU;
}(op_1.Operation));
exports.PReLU = PReLU;

},{"../activation_functions":11,"./op":30}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var cost_functions_1 = require("../../math/cost_functions");
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar =
            environment_1.ENV.math.keep(ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape)));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../../environment":10,"../../math/cost_functions":98,"../../math/ndarray":105,"../../util":122,"../graph_util":14,"./op":30}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../graph_util":14,"./op":30}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../graph_util":14,"./op":30}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.divide(dy, x));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../graph_util":14,"./op":30}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var matmul_1 = require("../../math/backends/types/matmul");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, matmul_1.MatrixOrientation.REGULAR, matmul_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, matmul_1.MatrixOrientation.TRANSPOSED, matmul_1.MatrixOrientation.REGULAR);
                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../../math/backends/types/matmul":54,"../graph_util":14,"./op":30}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../../math/conv_util":97,"../../util":122,"./op":30}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.add(_this.x2Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../../util":122,"../graph_util":14,"./op":30}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        _this.ones = environment_1.ENV.math.keep(ndarray_1.NDArray.ones(x.shape));
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function () {
            var dy = gradientArrays.get(_this.outTensor);
            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
        });
    };
    ReduceSum.prototype.dispose = function () {
        this.ones.dispose();
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../../environment":10,"../../math/ndarray":105,"../../util":122,"../graph_util":14,"./op":30}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var clone = math.clone(x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        var clone = math.clone(dy);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../../util":122,"./op":30}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_1 = require("../graph");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.output);
        var dy = gradientArrays.get(this.output);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.logitsTensor)) {
                var dlogits = math.elementWiseMul(math.subtract(dy, math.sum(math.elementWiseMul(dy, y))), y);
                gradientArrays.add(_this.logitsTensor, dlogits);
            }
        });
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        _this.epsilon = environment_1.ENV.math.keep(ndarray_1.Scalar.new(1e-5));
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function () {
            gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../../environment":10,"../../math/ndarray":105,"../../util":122,"../graph":12,"../graph_util":14,"./op":30}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.subtract(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.t1, sum);
                }
                else {
                    gradientArrays.add(_this.t1, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    gradientArrays.add(_this.t2, negSum);
                }
                else {
                    gradientArrays.add(_this.t2, math.neg(dy));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../../util":122,"../graph_util":14,"./op":30}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var optimizer_1 = require("../../math/optimizers/optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("Adadelta optimizer not yet implemented for eager mode.");
    };
    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var oldUpdates = _this.accumulatedUpdates.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
                var variable = math.scaledArrayAdd(_this.cGraph, updates, _this.one, oldVariable);
                var updateSquare = math.multiply(updates, updates);
                var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                _this.accumulatedUpdates.set(node.output, keep(newUpdates));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
                oldUpdates.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
        this.accumulatedUpdates.dispose();
    };
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/optimizer":108,"../tensor_array_map":44}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var optimizer_1 = require("../../math/optimizers/optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        return _this;
    }
    AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("Adagrad optimizer not yet implemented for eager mode.");
    };
    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.add(oldCache, gradientSquare);
                var variable = math.scaledArrayAdd(_this.cGraph, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdagradOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/optimizer":108,"../tensor_array_map":44}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var optimizer_1 = require("../../math/optimizers/optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
        return _this;
    }
    AdamOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("Adam optimizer not yet implemented for eager mode.");
    };
    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.secondMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldSecondMoment = _this.secondMoment.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var gradientSquare = math.multiply(gradient, gradient);
                var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
                var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
                var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
                var variable = math.scaledArrayAdd(_this.cGraph, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.secondMoment.set(node.output, keep(newSecondMoment));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldSecondMoment.dispose();
            });
            var oldAccB1 = _this.accB1;
            var oldAccB2 = _this.accB2;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
            oldAccB1.dispose();
            oldAccB2.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.secondMoment.dispose();
        this.eps.dispose();
        this.b1.dispose();
        this.b2.dispose();
        this.accB1.dispose();
        this.accB2.dispose();
    };
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/optimizer":108,"../tensor_array_map":44}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var optimizer_1 = require("../../math/optimizers/optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        return _this;
    }
    AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("Adamax optimizer not yet implemented for eager mode.");
    };
    AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.weightedInfNorm.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
                var ut1 = math.abs(gradient);
                var newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
                var variable = math.scaledArrayAdd(_this.one, oldVariable, math.divideStrict(_this.cGraph, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldWeightedInfNorm.dispose();
            });
            var oldAccB1 = _this.accB1;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            oldAccB1.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamaxOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.weightedInfNorm.dispose();
        this.eps.dispose();
        this.accB1.dispose();
        this.b1.dispose();
        this.b2.dispose();
    };
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/optimizer":108,"../tensor_array_map":44}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var sgd_optimizer_1 = require("../../math/optimizers/sgd_optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
        _this.m = ndarray_1.Scalar.new(_this.momentum);
        return _this;
    }
    MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("Momentum optimizer not yet implemented for eager mode.");
    };
    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.variableVelocities.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldVelocity = _this.variableVelocities.get(node.output);
                var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
                var variable = math.scaledArrayAdd(_this.cGraph, velocity, _this.one, oldVariable);
                _this.variableVelocities.set(node.output, keep(velocity));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldVelocity.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        this.variableVelocities.dispose();
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/sgd_optimizer":109,"../tensor_array_map":44}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var optimizer_1 = require("../../math/optimizers/optimizer");
var tensor_array_map_1 = require("../tensor_array_map");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
        throw new Error("RMSProp optimizer not yet implemented for eager mode.");
    };
    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var variable = math.scaledArrayAdd(_this.cGraph, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    RMSPropOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;

},{"../../math/ndarray":105,"../../math/optimizers/optimizer":108,"../tensor_array_map":44}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            if (this.batchSizeScalar != null) {
                this.batchSizeScalar.dispose();
            }
            this.batchSizeScalar = this.math.keep(ndarray_1.Scalar.new(batchSize));
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.nullify(costTensor);
        gradients.add(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function () {
            var cost = ndarray_1.Scalar.new(0);
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"../math/ndarray":105,"../util":122,"./operation_emitter":15,"./session_util":43,"./tensor_array_map":44}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.nullify(input);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;

},{"../math/ndarray":105,"../util":122,"./graph":12,"./graph_util":14}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMapBase = (function () {
    function TensorArrayMapBase() {
        this.dict = {};
    }
    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error("tensor " + tensor.id + " has null array.");
        }
        return nda;
    };
    TensorArrayMapBase.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMapBase.prototype.nullify = function (tensor) {
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMapBase.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMapBase;
}());
exports.TensorArrayMapBase = TensorArrayMapBase;
var TensorArrayMap = (function (_super) {
    __extends(TensorArrayMap, _super);
    function TensorArrayMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    return TensorArrayMap;
}(TensorArrayMapBase));
exports.TensorArrayMap = TensorArrayMap;
var SummedTensorArrayMap = (function (_super) {
    __extends(SummedTensorArrayMap, _super);
    function SummedTensorArrayMap(math) {
        var _this = _super.call(this) || this;
        _this.math = math;
        return _this;
    }
    SummedTensorArrayMap.prototype.add = function (tensor, array) {
        if (this.dict[tensor.id] == null) {
            this.dict[tensor.id] = this.math.keep(array);
        }
        else {
            var oldValue = this.get(tensor);
            var newValue = this.math.keep(this.math.addStrict(oldValue, array));
            this.dict[tensor.id] = newValue;
            oldValue.dispose();
        }
    };
    return SummedTensorArrayMap;
}(TensorArrayMapBase));
exports.SummedTensorArrayMap = SummedTensorArrayMap;

},{}],45:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var xhr_dataset = require("./data/xhr-dataset");
exports.xhr_dataset = xhr_dataset;
var environment = require("./environment");
exports.environment = environment;
var gpgpu_util = require("./math/backends/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = require("./math/backends/webgl/render_ndarray_gpu_util");
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = require("./math/backends/webgl/webgl_util");
exports.webgl_util = webgl_util;
var conv_util = require("./math/conv_util");
exports.conv_util = conv_util;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version = version_1.version;
var checkpoint_loader_1 = require("./data/checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./data/dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var input_provider_1 = require("./data/input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var xhr_dataset_1 = require("./data/xhr-dataset");
exports.XhrDataset = xhr_dataset_1.XhrDataset;
var environment_1 = require("./environment");
exports.ENV = environment_1.ENV;
exports.Environment = environment_1.Environment;
var graph_1 = require("./graph/graph");
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var graph_runner_1 = require("./graph/graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var adadelta_optimizer_1 = require("./graph/optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./graph/optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./graph/optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./graph/optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./graph/optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var rmsprop_optimizer_1 = require("./graph/optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var session_1 = require("./graph/session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var initializers_1 = require("./initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var backend_cpu_1 = require("./math/backends/backend_cpu");
exports.MathBackendCPU = backend_cpu_1.MathBackendCPU;
exports.NDArrayMathCPU = backend_cpu_1.NDArrayMathCPU;
var backend_webgl_1 = require("./math/backends/backend_webgl");
exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
exports.NDArrayMathGPU = backend_webgl_1.NDArrayMathGPU;
var matmul_1 = require("./math/backends/types/matmul");
exports.MatrixOrientation = matmul_1.MatrixOrientation;
var gpgpu_context_1 = require("./math/backends/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
var math_1 = require("./math/math");
exports.NDArrayMath = math_1.NDArrayMath;
var ndarray_1 = require("./math/ndarray");
exports.Array1D = ndarray_1.Array1D;
exports.Array2D = ndarray_1.Array2D;
exports.Array3D = ndarray_1.Array3D;
exports.Array4D = ndarray_1.Array4D;
exports.NDArray = ndarray_1.NDArray;
exports.Scalar = ndarray_1.Scalar;
exports.variable = ndarray_1.variable;
exports.Variable = ndarray_1.Variable;
var optimizer_1 = require("./math/optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var sgd_optimizer_1 = require("./math/optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var types_1 = require("./math/types");
exports.Rank = types_1.Rank;
__export(require("./math/ops"));

},{"./data/checkpoint_loader":5,"./data/dataset":6,"./data/input_provider":7,"./data/xhr-dataset":8,"./environment":10,"./graph/graph":12,"./graph/graph_runner":13,"./graph/optimizers/adadelta_optimizer":35,"./graph/optimizers/adagrad_optimizer":36,"./graph/optimizers/adam_optimizer":37,"./graph/optimizers/adamax_optimizer":38,"./graph/optimizers/momentum_optimizer":39,"./graph/optimizers/rmsprop_optimizer":40,"./graph/session":42,"./initializers":46,"./math/backends/backend_cpu":49,"./math/backends/backend_webgl":51,"./math/backends/types/matmul":54,"./math/backends/webgl/gpgpu_context":67,"./math/backends/webgl/gpgpu_util":69,"./math/backends/webgl/render_ndarray_gpu_util":79,"./math/backends/webgl/webgl_util":89,"./math/conv_util":97,"./math/math":103,"./math/ndarray":105,"./math/ops":107,"./math/optimizers/optimizer":108,"./math/optimizers/sgd_optimizer":109,"./math/types":119,"./test_util":121,"./util":122,"./version":123}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error("Unexpected distribution for variance scaling initializer: " +
                ("" + this.distribution));
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"./math/ndarray":105}],47:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var rand_1 = require("./rand");
var Ops = (function () {
    function Ops() {
    }
    Ops.ones = function (shape, dtype) {
        var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
        return ndarray_1.NDArray.make(shape, { values: values }, dtype);
    };
    Ops.zeros = function (shape, dtype) {
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return ndarray_1.NDArray.make(shape, { values: values }, dtype);
    };
    Ops.onesLike = function (x) {
        return Ops.ones(x.shape, x.dtype);
    };
    Ops.zerosLike = function (x) {
        return Ops.zeros(x.shape, x.dtype);
    };
    Ops.clone = function (x) {
        var newValues = util.copyTypedArray(x.dataSync(), x.dtype);
        return ndarray_1.NDArray.make(x.shape, { values: newValues }, x.dtype);
    };
    Ops.randNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
        return ndarray_1.NDArray.rand(shape, function () { return randGauss.nextValue(); }, dtype);
    };
    Ops.truncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
        return ndarray_1.NDArray.rand(shape, function () { return randGauss.nextValue(); }, dtype);
    };
    Ops.randUniform = function (shape, a, b, dtype) {
        return ndarray_1.NDArray.rand(shape, function () { return util.randUniform(a, b); }, dtype);
    };
    Ops.rand = function (shape, randFunction, dtype) {
        var size = util.sizeFromShape(shape);
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return ndarray_1.NDArray.make(shape, { values: values }, dtype);
    };
    Ops.multinomial = function (probabilities, numSamples, seed) {
        var numOutcomes = probabilities.size;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (probabilities.rank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + probabilities.rank);
        }
        seed = seed || Math.random();
        var origRank = probabilities.rank;
        if (probabilities.rank === 1) {
            probabilities = probabilities.as2D(1, -1);
        }
        var res = environment_1.ENV.engine.executeKernel('Multinomial', {
            inputs: { probs: probabilities },
            args: { numSamples: numSamples, seed: seed }
        });
        if (origRank === 1) {
            return res.as1D();
        }
        return res;
    };
    Ops.oneHot = function (indices, depth, onValue, offValue) {
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return environment_1.ENV.engine.executeKernel('OneHot', { inputs: { indices: indices }, args: { depth: depth, onValue: onValue, offValue: offValue } });
    };
    Ops.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');
        }
        return environment_1.ENV.math.fromPixels(pixels, numChannels);
    };
    Ops.reshape = function (x, newShape) {
        newShape = util.inferFromImplicitShape(newShape, x.size);
        util.assert(x.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        var grad = function (dy, y) {
            return { x: function () { return dy.reshape(x.shape); } };
        };
        return environment_1.ENV.engine.executeKernel('Reshape', { inputs: { x: x }, args: { newShape: newShape } }, grad);
    };
    Ops.cast = function (x, newDType) {
        var grad = function (dy, y) {
            return { x: function () { return dy.reshape(dy.shape); } };
        };
        return environment_1.ENV.engine.executeKernel('Cast', { inputs: { x: x }, args: { newDType: newDType } }, grad);
    };
    Ops.tile = function (x, reps) {
        util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of reps " + reps + "."));
        return environment_1.ENV.engine.executeKernel('Tile', { inputs: { x: x }, args: { reps: reps } });
    };
    Ops.gather = function (x, indices, axis) {
        if (axis === void 0) { axis = 0; }
        return environment_1.ENV.engine.executeKernel('Gather', { inputs: { x: x, indices: indices }, args: { axis: axis } });
    };
    Ops.pad1D = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2, 'Invalid number of paddings. Must be length of 2.');
        return environment_1.ENV.engine.executeKernel('Pad1D', { inputs: { x: x }, args: { paddings: paddings, constantValue: constantValue } });
    };
    Ops.pad2D = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2 && paddings[0].length === 2 &&
            paddings[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return environment_1.ENV.engine.executeKernel('Pad2D', { inputs: { x: x }, args: { paddings: paddings, constantValue: constantValue } });
    };
    __decorate([
        decorators_1.operation
    ], Ops, "ones", null);
    __decorate([
        decorators_1.operation
    ], Ops, "zeros", null);
    __decorate([
        decorators_1.operation
    ], Ops, "onesLike", null);
    __decorate([
        decorators_1.operation
    ], Ops, "zerosLike", null);
    __decorate([
        decorators_1.operation
    ], Ops, "clone", null);
    __decorate([
        decorators_1.operation
    ], Ops, "randNormal", null);
    __decorate([
        decorators_1.operation
    ], Ops, "truncatedNormal", null);
    __decorate([
        decorators_1.operation
    ], Ops, "randUniform", null);
    __decorate([
        decorators_1.operation
    ], Ops, "rand", null);
    __decorate([
        decorators_1.operation
    ], Ops, "multinomial", null);
    __decorate([
        decorators_1.operation
    ], Ops, "oneHot", null);
    __decorate([
        decorators_1.operation
    ], Ops, "fromPixels", null);
    __decorate([
        decorators_1.operation
    ], Ops, "reshape", null);
    __decorate([
        decorators_1.operation
    ], Ops, "cast", null);
    __decorate([
        decorators_1.operation
    ], Ops, "tile", null);
    __decorate([
        decorators_1.operation
    ], Ops, "gather", null);
    __decorate([
        decorators_1.operation
    ], Ops, "pad1D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "pad2D", null);
    return Ops;
}());
exports.Ops = Ops;
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function makeOnesTypedArray(size, dtype) {
    var array = makeZerosTypedArray(size, dtype);
    for (var i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}

},{"../environment":10,"../util":122,"./decorators":99,"./ndarray":105,"./rand":111}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    util.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis));
    util.assert(axis.every(function (ax) { return util.isInt(ax); }), "All values in axis param must be integers but " +
        ("got axis " + axis));
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " +
        ("Got axes " + axes + " and rank-" + rank + " input."));
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getAxesPermutation = getAxesPermutation;
function getUndoAxesPermutation(axes) {
    return axes.map(function (axis, i) { return [i, axis]; })
        .sort(function (a, b) { return a[1] - b[1]; })
        .map(function (x) { return x[0]; });
}
exports.getUndoAxesPermutation = getUndoAxesPermutation;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{"../util":122}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../broadcast_util");
var concat_util = require("../concat_util");
var math_1 = require("../math");
var ndarray_1 = require("../ndarray");
var ops = require("../ops");
var types = require("../types");
var axis_util = require("./../axis_util");
var matmul_1 = require("./types/matmul");
var MathBackendCPU = (function () {
    function MathBackendCPU() {
        this.data = {};
        if (typeof document !== 'undefined') {
            this.canvas = document.createElement('canvas');
        }
    }
    MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
        this.data[dataId] = null;
    };
    MathBackendCPU.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendCPU.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        this.data[dataId] = values;
    };
    MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendCPU.writePixels(): pixels can not be null');
        }
        var vals;
        if (pixels instanceof ImageData) {
            vals = pixels.data;
        }
        else if (pixels instanceof HTMLCanvasElement) {
            vals = pixels.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else if (pixels instanceof HTMLImageElement ||
            pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            vals = this.canvas.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else {
            throw new Error("pixels is of unknown type: " + pixels.constructor.name);
        }
        var values;
        if (numChannels === 4) {
            values = new Int32Array(vals);
        }
        else {
            var numPixels = pixels.width * pixels.height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
                for (var channel = 0; channel < numChannels; ++channel) {
                    values[i * numChannels + channel] = vals[i * 4 + channel];
                }
            }
        }
        var outShape = [pixels.height, pixels.width, numChannels];
        return ndarray_1.Array3D.new(outShape, values, 'int32');
    };
    MathBackendCPU.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfNoData(dataId);
                return [2, this.data[dataId]];
            });
        });
    };
    MathBackendCPU.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        return this.data[dataId];
    };
    MathBackendCPU.prototype.disposeData = function (dataId) {
        delete this.data[dataId];
    };
    MathBackendCPU.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start;
            return __generator(this, function (_a) {
                start = performance.now();
                query();
                return [2, performance.now() - start];
            });
        });
    };
    MathBackendCPU.prototype.throwIfNoData = function (dataId) {
        if (!(dataId in this.data)) {
            throw new Error("No data found for NDArray with data id " + dataId + ". " +
                "Use dl.ENV.math instead of constructing your own NDArrayMath. " +
                "If you need to construct your own math, make sure this array is " +
                "allocated after the math construction");
        }
    };
    MathBackendCPU.prototype.clone = function (x) {
        return ndarray_1.NDArray.make(x.shape, { values: new Float32Array(x.dataSync()) });
    };
    MathBackendCPU.prototype.slice1D = function (x, begin, size) {
        var newVals = x.dataSync().slice(begin, begin + size);
        return ndarray_1.Array1D.new(newVals, x.dtype);
    };
    MathBackendCPU.prototype.slice2D = function (x, begin, size) {
        var result = ops.zeros(size, x.dtype);
        var startI = begin[0], startJ = begin[1];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                var val = x.get(i + startI, j + startJ);
                result.set(val, i, j);
            }
        }
        return result;
    };
    MathBackendCPU.prototype.slice3D = function (x, begin, size) {
        var result = ops.zeros(size, x.dtype);
        var startI = begin[0], startJ = begin[1], startK = begin[2];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    var val = x.get(i + startI, j + startJ, k + startK);
                    result.set(val, i, j, k);
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.slice4D = function (x, begin, size) {
        var result = ops.zeros(size, x.dtype);
        var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    for (var l = 0; l < size[3]; ++l) {
                        var val = x.get(i + startI, j + startJ, k + startK, l + startL);
                        result.set(val, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.reverse4D = function (x, axis) {
        var result = ops.clone(x);
        var revAxis = function (i) { return axis.indexOf(i) !== -1 && x.shape[i] !== 1; };
        for (var b = 0; b < x.shape[0]; ++b) {
            for (var r = 0; r < x.shape[1]; ++r) {
                for (var c = 0; c < x.shape[2]; ++c) {
                    for (var d = 0; d < x.shape[3]; ++d) {
                        var b0 = revAxis(0) ? x.shape[0] - b - 1 : b;
                        var r0 = revAxis(1) ? x.shape[1] - r - 1 : r;
                        var c0 = revAxis(2) ? x.shape[2] - c - 1 : c;
                        var d0 = revAxis(3) ? x.shape[3] - d - 1 : d;
                        var val = x.get(b0, r0, c0, d0);
                        result.set(val, b, r, c, d);
                    }
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.concat = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 1);
        var result = ops.zeros(outShape);
        if (a.shape[0] === 1 && b.shape[0] === 1) {
            var aVals = a.dataSync();
            var bVals = b.dataSync();
            var vals = result.dataSync();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < a.shape[1]; ++j) {
                result.set(a.get(i, j), i, j);
            }
            for (var j = 0; j < b.shape[1]; ++j) {
                result.set(b.get(i, j), i, j + a.shape[1]);
            }
        }
        return result;
    };
    MathBackendCPU.prototype.neg = function (x) {
        return this.multiply(ndarray_1.Scalar.new(-1), x);
    };
    MathBackendCPU.prototype.add = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue + bValue; });
    };
    MathBackendCPU.prototype.subtract = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue - bValue; });
    };
    MathBackendCPU.prototype.pow = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.pow(aValue, bValue); });
    };
    MathBackendCPU.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = matmul_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = matmul_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    MathBackendCPU.prototype.multiply = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue * bValue; });
    };
    MathBackendCPU.prototype.divide = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'float32', function (aValue, bValue) { return aValue / bValue; });
    };
    MathBackendCPU.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    MathBackendCPU.prototype.argMin = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    minIndex = util.NAN_INT32;
                    break;
                }
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.argMax = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    maxIndex = util.NAN_INT32;
                    break;
                }
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.equal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal === bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.notEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal !== bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.less = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal < bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.lessEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal <= bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.greater = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal > bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.greaterEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal >= bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.logicalAnd = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return aVal && bVal;
            }
        });
    };
    MathBackendCPU.prototype.logicalOr = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return aVal || bVal;
            }
        });
    };
    MathBackendCPU.prototype.where = function (condition, a, b, dtype) {
        var values = condition.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var result = ops.zeros(a.shape, dtype);
        var newValues = result.dataSync();
        var index = 0;
        var offset = condition.rank > 1 || a.rank === 1 ? 1 : a.shape[1];
        for (var i = 0; i < values.length; i++) {
            for (var j = 0; j < offset; j++) {
                if (values[i] === 1) {
                    newValues[index++] = aValues[i];
                }
                else {
                    newValues[index++] = bValues[i];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.topKValues = function (x, k) {
        return this.topK(x, k).values;
    };
    MathBackendCPU.prototype.topKIndices = function (x, k) {
        return this.topK(x, k).indices;
    };
    MathBackendCPU.prototype.topK = function (x, k) {
        var values = x.dataSync();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = util.getTypedArrayFromDType(x.dtype, k);
        var topkIndices = new Int32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return {
            values: ndarray_1.Array1D.new(topkValues, x.dtype),
            indices: ndarray_1.Array1D.new(topkIndices)
        };
    };
    MathBackendCPU.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    min = Number.NaN;
                    break;
                }
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    MathBackendCPU.prototype.minimum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.min(aVal, bVal); });
    };
    MathBackendCPU.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    max = Number.NaN;
                    break;
                }
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    MathBackendCPU.prototype.maximum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.max(aVal, bVal); });
    };
    MathBackendCPU.prototype.ceil = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.floor = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.exp = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.square = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.relu = function (x) {
        var res = ops.zeros(x.shape, x.dtype);
        var resVals = res.dataSync();
        var inVals = x.dataSync();
        for (var i = 0; i < inVals.length; ++i) {
            var val = inVals[i];
            if (util.isValNaN(val, x.dtype)) {
                resVals[i] = util.getNaN(res.dtype);
            }
            else {
                resVals[i] = Math.max(0, inVals[i]);
            }
        }
        return res;
    };
    MathBackendCPU.prototype.elu = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.eluDer = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = 1;
            }
            else {
                resultValues[i] = Math.exp(v);
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.selu = function (x) {
        var scaleAlpha = 1.7580993408473768599402175208123;
        var scale = 1.0507009873554804934193349852946;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = scale * v;
            }
            else {
                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.leakyRelu = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alpha * v;
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.prelu = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var alphas = alpha.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alphas[i] * v;
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.preluDer = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var alphas = alpha.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v > 0) {
                resultValues[i] = 1;
            }
            else if (v < 0) {
                resultValues[i] = alphas[i];
            }
            else {
                resultValues[i] = v;
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.clip = function (x, min, max) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.abs = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.int = function (x) {
        var resultValues = new Int32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = values[i];
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues }, 'int32');
    };
    MathBackendCPU.prototype.sigmoid = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (util.isValNaN(value, x.dtype)) {
                resultValues[i] = util.getNaN(x.dtype);
            }
            else {
                resultValues[i] = value > 0 ? 1 : alpha;
            }
        }
        return ndarray_1.NDArray.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.conv2d = function (x, filter, bias, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ops.zeros(convInfo.outShape);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var dotProd = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        var biasVal = (bias != null) ? bias.get(d2) : 0;
                        y.set(dotProd + biasVal, b, yR, yC, d2);
                    }
                }
            }
        }
        return y;
    };
    MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dx = ops.zeros(convInfo.inShape);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var xR = 0; xR < convInfo.inHeight; ++xR) {
                    var xRCorner = xR - leftPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(convInfo.outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < convInfo.inWidth; ++xC) {
                        var xCCorner = xC - topPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(convInfo.outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                    var pixel = dy.get(b, yR, yC, d2);
                                    var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dx.set(dotProd, b, xR, xC, d1);
                    }
                }
            }
        }
        return dx;
    };
    MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.zeros(convInfo.filterShape);
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        var dotProd = 0;
                        for (var b = 0; b < convInfo.batchSize; ++b) {
                            for (var yR = yRMin; yR < yRMax; ++yR) {
                                var xR = wR + yR * strideHeight - topPad;
                                for (var yC = yCMin; yC < yCMax; ++yC) {
                                    var xC = wC + yC * strideWidth - leftPad;
                                    dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                }
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    MathBackendCPU.prototype.conv2dDerBias = function (dy) {
        var _a = dy.shape, batchSize = _a[0], numRows = _a[1], numCols = _a[2], outDepth = _a[3];
        var values = new Float32Array(outDepth);
        for (var d2 = 0; d2 < outDepth; ++d2) {
            var sum = 0;
            for (var b = 0; b < batchSize; ++b) {
                for (var r = 0; r < numRows; ++r) {
                    for (var c = 0; c < numCols; ++c) {
                        sum += dy.get(b, r, c, d2);
                    }
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        var y = ops.zeros(convInfo.outShape);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var xR = xRMin; xR < xRMax; ++xR) {
                                var wR = xR - xRCorner;
                                for (var xC = xCMin; xC < xCMax; ++xC) {
                                    var wC = xC - xCCorner;
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y;
    };
    MathBackendCPU.prototype.tile = function (x, reps) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[i] * reps[i];
        }
        var result = ops.zeros(newShape, x.dtype);
        var newValues = result.dataSync();
        var values = x.dataSync();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(x.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
            }
            var originalIndex = x.locToIndex(originalLoc);
            newValues[i] = values[originalIndex];
        }
        return result;
    };
    MathBackendCPU.prototype.pad1D = function (x, paddings, constantValue) {
        var leftPadding = paddings[0];
        var rightPadding = paddings[1];
        var values = x.dataSync();
        var result = ops.zeros([leftPadding + values.length + rightPadding], x.dtype);
        var newValues = result.dataSync();
        var z = 0;
        for (var i = 0; i < newValues.length; i++) {
            if (i >= leftPadding && i < leftPadding + values.length) {
                newValues[i] = values[z++];
            }
            else {
                newValues[i] = constantValue;
            }
        }
        return result;
    };
    MathBackendCPU.prototype.pad2D = function (x, paddings, constantValue) {
        var topPadding = paddings[0][0];
        var bottomPadding = paddings[0][1];
        var leftPadding = paddings[1][0];
        var rightPadding = paddings[1][1];
        var newShape = [
            topPadding + x.shape[0] + bottomPadding,
            leftPadding + x.shape[1] + rightPadding
        ];
        var result = ops.zeros(newShape, x.dtype);
        var newValues = result.dataSync();
        var values = x.dataSync();
        var z = 0;
        for (var i = 0; i < newShape[0]; i++) {
            var rangeStart = -1;
            var rangeEnd = -1;
            if (i >= topPadding && i < newShape[0] - bottomPadding) {
                rangeStart = i * newShape[1] + leftPadding;
                rangeEnd = rangeStart + x.shape[1] - 1;
            }
            for (var j = 0; j < newShape[1]; j++) {
                var v = i * newShape[1] + j;
                if (v >= rangeStart && v <= rangeEnd) {
                    newValues[v] = values[z++];
                }
                else {
                    newValues[v] = constantValue;
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.transpose = function (x, perm) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[perm[i]];
        }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < x.size; ++i) {
            var loc = x.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    MathBackendCPU.prototype.gather = function (x, indices, axis) {
        var newShape = x.shape.slice();
        var indicesValues = indices.dataSync();
        newShape[axis] = indicesValues.length;
        var result = ops.zeros(newShape, x.dtype);
        var values = x.dataSync();
        var resultValues = result.dataSync();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = newLoc.slice();
            originalLoc[axis] = indicesValues[newLoc[axis]];
            var originalIndex = x.locToIndex(originalLoc);
            resultValues[i] = values[originalIndex];
        }
        return result;
    };
    MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ops.zeros(convInfo.outShape);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                            Number.POSITIVE_INFINITY);
                        var avgValue = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var pixel = x.get(b, xR, xC, d);
                                if (isNaN(pixel)) {
                                    minMaxValue = NaN;
                                    avgValue = NaN;
                                    break;
                                }
                                if ((poolType === 'max' && pixel > minMaxValue) ||
                                    (poolType === 'min' && pixel < minMaxValue)) {
                                    minMaxValue = pixel;
                                }
                                else if (poolType === 'avg') {
                                    avgValue += pixel / (filterHeight * filterWidth);
                                }
                            }
                            if (isNaN(minMaxValue)) {
                                break;
                            }
                        }
                        y.set(poolType === 'avg' ? avgValue : minMaxValue, b, yR, yC, d);
                    }
                }
            }
        }
        return y;
    };
    MathBackendCPU.prototype.maxPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var maxPositions = ops.zeros(convInfo.outShape);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var maxValue = Number.NEGATIVE_INFINITY;
                        var maxPosition = -1;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                var pixel = x.get(b, xR, xC, d);
                                if (pixel > maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wR * filterWidth + wC;
                                }
                            }
                        }
                        maxPositions.set(maxPosition, b, yR, yC, d);
                    }
                }
            }
        }
        return maxPositions;
    };
    MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.zeros(x.shape);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var maxPos = filterHeight * filterWidth - 1 -
                                    maxPositions.get(b, dyR, dyC, d);
                                var curPos = wR * filterWidth + wC;
                                var mask = maxPos === curPos ? 1 : 0;
                                if (mask === 0) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel * mask;
                            }
                        }
                        dx.set(dotProd, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.asType(x.dtype);
    };
    MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.zeros(x.shape);
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel;
                            }
                        }
                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.asType(x.dtype);
    };
    MathBackendCPU.prototype.minPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'min');
    };
    MathBackendCPU.prototype.avgPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg').toFloat();
    };
    MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.zeros([batch, newHeight, newWidth, numChannels]);
        var effectiveInputSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutputSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceRowFloor = Math.floor(sourceFracRow);
                        var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                        var sourceColFloor = Math.floor(sourceFracCol);
                        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                        var topLeft = x.get(b, sourceRowFloor, sourceColFloor, d);
                        var bottomLeft = x.get(b, sourceRowCeil, sourceColFloor, d);
                        var topRight = x.get(b, sourceRowFloor, sourceColCeil, d);
                        var bottomRight = x.get(b, sourceRowCeil, sourceColCeil, d);
                        var rowFrac = sourceFracRow - sourceRowFloor;
                        var colFrac = sourceFracCol - sourceColFloor;
                        var top_1 = topLeft + (topRight - topLeft) * colFrac;
                        var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                        var newValue = top_1 + (bottom - top_1) * rowFrac;
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output;
    };
    MathBackendCPU.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : [1];
        var offsetValues = offset ? offset.dataSync() : [0];
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array2D.new(x.shape, outValues);
    };
    MathBackendCPU.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : [1];
        var offsetValues = offset ? offset.dataSync() : [0];
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array3D.new(x.shape, outValues);
    };
    MathBackendCPU.prototype.batchNormalization4D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : new Float32Array([1]);
        var offsetValues = offset ? offset.dataSync() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array4D.new(x.shape, outValues);
    };
    MathBackendCPU.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta, normRegion) {
        var output = ops.zeros(x.shape);
        var rad = radius;
        var maxW = output.shape[1] - 1;
        var maxH = output.shape[2] - 1;
        var maxD = output.shape[3] - 1;
        var sumAcrossChannels = function (b, r, c, d) {
            var sum = 0.0;
            for (var j = Math.max(0, d - rad); j <= Math.min(d + rad, maxD); j++) {
                var z = x.get(b, r, c, j);
                sum += z * z;
            }
            return sum;
        };
        var sumWithinChannel = function (b, r, c, d) {
            var sum = 0.0;
            for (var u = Math.max(0, r - rad); u <= Math.min(r + rad, maxW); u++) {
                for (var v = Math.max(0, c - rad); v <= Math.min(c + rad, maxH); v++) {
                    sum += Math.pow(x.get(b, u, v, d), 2);
                }
            }
            return sum;
        };
        for (var b = 0; b < output.shape[0]; b++) {
            for (var r = 0; r <= output.shape[1]; r++) {
                for (var c = 0; c < output.shape[2]; c++) {
                    for (var d = 0; d < output.shape[3]; d++) {
                        var sum = normRegion === 'withinChannel' ?
                            sumWithinChannel(b, r, c, d) :
                            sumAcrossChannels(b, r, c, d);
                        var val = x.get(b, r, c, d) * Math.pow(bias + alpha * sum, -beta);
                        output.set(val, b, r, c, d);
                    }
                }
            }
        }
        return output;
    };
    MathBackendCPU.prototype.multinomial = function (probabilities, numSamples, seed) {
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ops.zeros([batchSize, numSamples], 'int32');
        var resVals = res.dataSync();
        var probVals = probabilities.dataSync();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ndarray_1.Array2D.new([indices.size, depth], res);
    };
    MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ops.zeros(newShape, dtype);
        var newValues = result.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var _loop_1 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = a.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = b.locToIndex(bLoc);
            newValues[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < newValues.length; ++i) {
            _loop_1(i);
        }
        return result;
    };
    MathBackendCPU.prototype.dispose = function () { };
    return MathBackendCPU;
}());
exports.MathBackendCPU = MathBackendCPU;
environment_1.ENV.registerBackend('cpu', function () { return new MathBackendCPU(); });
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = this;
        console.warn('new NDArrayMathCPU() is deprecated. Please use the global ' +
            'dl.ENV.math. In rare cases, to construct your own NDArrayMath ' +
            'that runs on CPU, use math = new NDArrayMath(\'cpu\', safeMode); ' +
            'and make sure to set it as global: dl.ENV.setMath(math);');
        _this = _super.call(this, 'cpu', safeMode) || this;
        environment_1.ENV.setMath(_this);
        return _this;
    }
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../../environment":10,"../../util":122,"../broadcast_util":92,"../concat_util":95,"../math":103,"../ndarray":105,"../ops":107,"../types":119,"./../axis_util":48,"./types/matmul":54,"seedrandom":125}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var ndarray_1 = require("../ndarray");
var kernel_registry = require("./kernel_registry");
var tape_util = require("./tape_util");
var BackendEngine = (function () {
    function BackendEngine(backend, safeMode) {
        this.backend = backend;
        this.safeMode = safeMode;
        this.nextTapeNodeId = 0;
        this.gradientScopeCount = 0;
        this.customGradientDepth = 0;
        this.debugMode = false;
        this.activeScope = { keep: [], track: [] };
        this.scopeStack = [this.activeScope];
    }
    BackendEngine.prototype.enableDebugMode = function () {
        this.debugMode = true;
    };
    BackendEngine.prototype.executeKernel = function (kernelName, config, grad) {
        var start;
        if (this.debugMode) {
            start = performance.now();
        }
        var result = kernel_registry.executeKernel(this.backend, kernelName, config);
        if (this.debugMode) {
            var vals = result.dataSync();
            var time = util.rightPad(performance.now() - start + "ms", 9);
            var paddedName = util.rightPad(kernelName, 25);
            var rank = result.rank;
            var size = result.size;
            var shape = util.rightPad(result.shape.toString(), 14);
            console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
            util.checkForNaN(vals, result.dtype, name);
        }
        if (this.activeTape != null && this.customGradientDepth === 0) {
            config = tape_util.stripUndefinedInputsFromInputConfig(config);
            var evaluatedNode = {
                id: this.nextTapeNodeId++,
                type: 'kernel',
                name: "kernel: " + kernelName,
                kernel: kernelName,
                inputAndArgs: config,
                output: result,
                gradient: grad
            };
            this.activeTape.push(evaluatedNode);
        }
        return result;
    };
    BackendEngine.prototype.customGradient = function (f, inputs, name) {
        this.customGradientDepth++;
        var gradientsFunc;
        var gradientsMode = true;
        var result = this.scope('customGradient', function () {
            var _a = f(), value = _a.value, gradients = _a.gradients;
            gradientsFunc = gradients;
            return value;
        }, gradientsMode);
        this.customGradientDepth--;
        if (this.activeTape != null && this.customGradientDepth === 0) {
            var evaluatedNode = {
                id: this.nextTapeNodeId++,
                type: 'customGradient',
                name: name,
                inputAndArgs: { inputs: inputs },
                output: result,
                gradient: gradientsFunc
            };
            this.activeTape.push(evaluatedNode);
        }
        return result;
    };
    BackendEngine.prototype.gradients = function (f, xs, returnValue) {
        var _this = this;
        var gradientsMode = true;
        var result = this.scope('gradients', function () {
            var y = f();
            if (y.rank !== 0) {
                throw new Error("Cannot compute gradient of non-scalar y output of f(). " +
                    ("Got y with rank " + y.rank + " and shape " + y.shape + "."));
            }
            var gradients = _this.gradientWrt(y, xs);
            if (returnValue) {
                return [y].concat(gradients);
            }
            else {
                return gradients;
            }
        }, gradientsMode);
        if (returnValue) {
            return { value: result[0], gradients: result.slice(1) };
        }
        else {
            return result;
        }
    };
    BackendEngine.prototype.vjp = function (f, xs, dy) {
        var _this = this;
        var gradientsMode = true;
        return this.scope('vjp', function () {
            var y = f();
            if (!util.arraysEqual(y.shape, dy.shape)) {
                throw new Error("Cannot compute vector jacobian product, " +
                    ("y shape (" + y.shape + ") does not match dy shape (" + dy.shape + ")."));
            }
            return _this.gradientWrt(y, xs, dy);
        }, gradientsMode);
    };
    BackendEngine.prototype.variableGradientsAndValue = function (f, varList) {
        var _this = this;
        var gradientsMode = true;
        var variableNames;
        var result = this.scope('gradients', function () {
            var y = f();
            if (y.rank !== 0) {
                throw new Error("Cannot compute gradient of non-scalar y output of f(). " +
                    ("Got y with rank " + y.rank + " and shape " + y.shape + "."));
            }
            var inputVariables = tape_util.computeVariableInputs(_this.activeTape, varList);
            variableNames = inputVariables.map(function (variable) { return variable.name; });
            var gradients = inputVariables.length === 0 ?
                [] :
                _this.gradientWrt(y, inputVariables);
            return [y].concat(gradients);
        }, gradientsMode);
        var gradients = {};
        for (var i = 0; i < variableNames.length; i++) {
            gradients[variableNames[i]] = result[i + 1];
        }
        return { value: result[0], gradients: gradients };
    };
    BackendEngine.prototype.gradientWrt = function (y, xs, dy) {
        var filteredTape = tape_util.getFilteredNodesXToY(this.activeTape, xs, y);
        if (filteredTape.length === 0) {
            throw new Error("Cannot compute gradient: y is not a function of xs." +
                "Make sure the xs you are computing gradients with respect " +
                "to are used inside the gradient function.");
        }
        var arrayAccumulatedGradientMap = {};
        arrayAccumulatedGradientMap[y.id] =
            dy == null ? ndarray_1.Scalar.new(1, 'float32') : dy;
        tape_util.backpropagateGradients(arrayAccumulatedGradientMap, filteredTape);
        var gradients = xs.map(function (x) { return arrayAccumulatedGradientMap[x.id]; });
        gradients.forEach(function (grad, i) {
            if (grad == null) {
                throw new Error("Gradient error: y was not a function of xs[" + i + "]");
            }
        });
        return gradients;
    };
    BackendEngine.prototype.scope = function (name, scopeFn, gradientsMode) {
        var _this = this;
        this.startScope(gradientsMode);
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return ndarray; };
        var result = scopeFn(keepFn, trackFn);
        if (result instanceof Promise) {
            result.then(function (r) { return _this.endScope(r, gradientsMode); });
            return result;
        }
        else {
            this.endScope(result, gradientsMode);
            return result;
        }
    };
    BackendEngine.prototype.startScope = function (gradientsMode) {
        if (gradientsMode && this.gradientScopeCount === 0) {
            this.activeTape = [];
        }
        if (gradientsMode) {
            this.gradientScopeCount++;
        }
        var newScopeArrays = { keep: [], track: [] };
        this.scopeStack.push(newScopeArrays);
        this.activeScope = newScopeArrays;
    };
    BackendEngine.prototype.endScope = function (result, gradientsMode) {
        var _this = this;
        if (gradientsMode) {
            this.gradientScopeCount--;
            if (this.gradientScopeCount === 0) {
                this.activeTape = null;
            }
        }
        var arraysToKeep = this.activeScope.keep;
        var arraysToTrackInParent = tape_util.extractNDArraysFromScopeResult(result);
        arraysToKeep = arraysToKeep.concat(arraysToTrackInParent);
        for (var i = 0; i < this.activeScope.track.length; i++) {
            var ndarray = this.activeScope.track[i];
            if (util.isNDArrayInList(ndarray, arraysToKeep)) {
                continue;
            }
            if (this.activeTape != null) {
                arraysToTrackInParent.push(ndarray);
            }
            else {
                ndarray.dispose();
            }
        }
        this.scopeStack.pop();
        this.activeScope = this.scopeStack.length === 0 ?
            null :
            this.scopeStack[this.scopeStack.length - 1];
        arraysToTrackInParent.forEach(function (ndarray) {
            if (!util.isNDArrayInList(ndarray, _this.activeScope.keep)) {
                _this.track(ndarray);
            }
        });
    };
    BackendEngine.prototype.keep = function (result) {
        if (this.scopeStack.length === 1) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
        }
        this.activeScope.keep.push(result);
        return result;
    };
    BackendEngine.prototype.track = function (result) {
        if (this.scopeStack.length === 1) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
        }
        this.activeScope.track.push(result);
        return result;
    };
    BackendEngine.prototype.getBackend = function () {
        return this.backend;
    };
    return BackendEngine;
}());
exports.BackendEngine = BackendEngine;

},{"../../util":122,"../ndarray":105,"./kernel_registry":52,"./tape_util":53}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var axis_util = require("../axis_util");
var math_1 = require("../math");
var ndarray_1 = require("../ndarray");
var reduce_util = require("../reduce_util");
var types = require("../types");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var copy_gpu_1 = require("./webgl/copy_gpu");
var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
var gather_gpu_1 = require("./webgl/gather_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var logical_gpu_1 = require("./webgl/logical_gpu");
var lrn_gpu_1 = require("./webgl/lrn_gpu");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pad_gpu_1 = require("./webgl/pad_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var reverse_gpu_1 = require("./webgl/reverse_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var tex_util_1 = require("./webgl/tex_util");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu, delayedStorage) {
        if (delayedStorage === void 0) { delayedStorage = true; }
        this.gpgpu = gpgpu;
        this.delayedStorage = delayedStorage;
        this.texData = {};
        this.binaryCache = {};
        this.disposed = false;
        if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
            throw new Error('WebGL is not supported on this device');
        }
        if (gpgpu == null) {
            this.gpgpu = new gpgpu_context_1.GPGPUContext();
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpuCreatedLocally = false;
        }
        if (typeof document !== 'undefined') {
            this.canvas = document.createElement('canvas');
        }
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
    }
    MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
        if (dataId in this.texData) {
            throw new Error("data id " + dataId + " already registered");
        }
        this.texData[dataId] = {
            shape: shape,
            dtype: dtype,
            values: null,
            texture: null,
            texShape: null,
            texType: tex_util_1.TextureType.FLOAT
        };
    };
    MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendWebGL.writePixels(): pixels can not be null');
        }
        var texShape = [pixels.height, pixels.width];
        var outShape = [pixels.height, pixels.width, numChannels];
        if (pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            pixels = this.canvas;
        }
        var tempPixelArray = ndarray_1.NDArray.make(texShape, {}, 'int32');
        this.texData[tempPixelArray.dataId].texType = tex_util_1.TextureType.UNSIGNED_BYTE;
        this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);
        var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
        var res = this.compileAndRun(program, [tempPixelArray]);
        tempPixelArray.dispose();
        return res;
    };
    MathBackendWebGL.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendWebGL.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        var _a = this.texData[dataId], texture = _a.texture, texShape = _a.texShape, texType = _a.texType;
        if (texture != null) {
            this.textureManager.releaseTexture(texture, texShape, texType);
            this.texData[dataId].texture = null;
            this.texData[dataId].texShape = null;
        }
        this.texData[dataId].values = values;
        if (!this.delayedStorage) {
            this.uploadToGPU(dataId);
        }
    };
    MathBackendWebGL.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        var _a = this.texData[dataId], texture = _a.texture, values = _a.values, texShape = _a.texShape;
        if (values != null) {
            this.cacheOnCPU(dataId);
            return values;
        }
        var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
        this.cacheOnCPU(dataId, float32Values);
        return this.texData[dataId].values;
    };
    MathBackendWebGL.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, texture, values, texShape, float32Values;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.throwIfNoData(dataId);
                        _a = this.texData[dataId], texture = _a.texture, values = _a.values, texShape = _a.texShape;
                        if (values != null) {
                            this.cacheOnCPU(dataId);
                            return [2, values];
                        }
                        if (!environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) return [3, 2];
                        return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                    case 1:
                        float32Values = _b.sent();
                        this.cacheOnCPU(dataId, float32Values);
                        return [2, this.texData[dataId].values];
                    case 2:
                        if (!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) {
                            return [2, this.readSync(dataId)];
                        }
                        return [4, this.gpgpu.runQuery(function () { })];
                    case 3:
                        _b.sent();
                        return [2, this.readSync(dataId)];
                }
            });
        });
    };
    MathBackendWebGL.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start, a;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) return [3, 2];
                        start = performance.now();
                        a = query();
                        return [4, a.data()];
                    case 1:
                        _a.sent();
                        return [2, performance.now() - start];
                    case 2: return [2, this.gpgpu.runQuery(query)];
                }
            });
        });
    };
    MathBackendWebGL.prototype.disposeData = function (dataId) {
        if (dataId in this.texData) {
            var _a = this.texData[dataId], texture = _a.texture, texShape = _a.texShape, texType = _a.texType;
            if (texture != null) {
                this.textureManager.releaseTexture(texture, texShape, texType);
            }
            delete this.texData[dataId];
        }
    };
    MathBackendWebGL.prototype.getTexture = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData[dataId].texture;
    };
    MathBackendWebGL.prototype.getTextureData = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData[dataId];
    };
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.clone = function (x) {
        this.throwIfNoData(x.dataId);
        this.uploadToGPU(x.dataId);
        var texShape = this.texData[x.dataId].texShape;
        var source = x.as2D(texShape[0], texShape[1]);
        var output = this.makeOutputArray(texShape, x.dtype);
        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
        return output.reshape(x.shape);
    };
    MathBackendWebGL.prototype.slice1D = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram([size]);
        var customSetup = program.getCustomSetupFunc([begin]);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.slice2D = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.slice3D = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.slice4D = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.reverse4D = function (x, axis) {
        var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.copy2D = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
        this.compileAndRun(program, [source], dest, customSetup);
    };
    MathBackendWebGL.prototype.concat = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.neg = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.batchNormalization4D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta, normRegion) {
        var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta, normRegion);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tile = function (x, reps) {
        var program = new tile_gpu_1.TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad1D = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.Pad1DProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad2D = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.Pad2DProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.transpose = function (x, perm) {
        var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.gather = function (x, indices, axis) {
        var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
    };
    MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
        this.compileAndRun(program, [x], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
        var inputs = [x];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(x, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types.sumOutType(x.dtype);
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.argMin = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.equal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.notEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.less = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.lessEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greater = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greaterEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalAnd = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalOr = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {
        var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);
        var output = this.makeOutputArray(program.outputShape, dtype);
        return this.compileAndRun(program, [condition, a, b], output);
    };
    MathBackendWebGL.prototype.topKValues = function (x, k) {
        throw new Error('topKValues GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.topKIndices = function (x, k) {
        throw new Error('topKIndices GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.minimum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.maximum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.divide = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.pow = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.ceil = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.floor = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.exp = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.elu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.eluDer = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU_DER);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.selu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.leakyRelu = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.prelu = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.preluDer = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU_DER, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.int = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.clip = function (x, min, max) {
        var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.abs = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sigmoid = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.step = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, bias, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
        var inputs = bias != null ? [x, filter, bias] : [x, filter];
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.conv2dDerBias = function (dy) {
        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dy.shape);
        return this.compileAndRun(program, [dy]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.minPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
        return this.compileAndRun(avgPoolBackpropProgram, [dy], output);
    };
    MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.multinomial = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        return ndarray_1.NDArray.make(shape, {}, dtype);
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var inputsData = inputs.map(function (input) {
            _this.uploadToGPU(input.dataId);
            return { array: input, texData: _this.texData[input.dataId] };
        });
        this.uploadToGPU(output.dataId);
        var outputData = { array: output, texData: this.texData[output.dataId] };
        var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
        });
        gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
        return output;
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
        this.disposed = true;
    };
    MathBackendWebGL.prototype.throwIfNoData = function (dataId) {
        if (!(dataId in this.texData)) {
            throw new Error("No data found for NDArray with data id " + dataId + ". " +
                "Use dl.ENV.math instead of constructing your own NDArrayMath. " +
                "If you need to construct your own math, make sure this array is " +
                "allocated after the math construction");
        }
    };
    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
        this.throwIfNoData(dataId);
        var _a = this.texData[dataId], shape = _a.shape, values = _a.values, texture = _a.texture, dtype = _a.dtype, texType = _a.texType;
        if (texture != null) {
            return;
        }
        var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        this.texData[dataId].texShape = texShape;
        var newTexture = this.textureManager.acquireTexture(texShape, texType);
        this.texData[dataId].texture = newTexture;
        if (values != null) {
            this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
            this.texData[dataId].values = null;
        }
    };
    MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
        var dontKeepCopyOnGPU = this.delayedStorage;
        var _a = this.texData[dataId], texture = _a.texture, texShape = _a.texShape, dtype = _a.dtype, texType = _a.texType;
        if (dontKeepCopyOnGPU && texture != null) {
            this.textureManager.releaseTexture(texture, texShape, texType);
            this.texData[dataId].texture = null;
            this.texData[dataId].texShape = null;
        }
        if (float32Values != null) {
            this.texData[dataId].values = float32ToTypedArray(float32Values, dtype);
        }
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
environment_1.ENV.registerBackend('webgl', function () { return new MathBackendWebGL(); });
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = this;
        console.warn('new NDArrayMathGPU() is deprecated. Please use the global ' +
            'dl.ENV.math. In rare cases, to construct your own NDArrayMath ' +
            'that runs on GPU, use math = new NDArrayMath(\'webgl\', safeMode); ' +
            'and make sure to set it as global: dl.ENV.setMath(math);');
        _this = _super.call(this, new MathBackendWebGL(gpgpu), safeMode) || this;
        environment_1.ENV.setMath(_this);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.engine.getBackend().getGPGPUContext();
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.engine.getBackend().getTextureManager();
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            var val = a[i];
            val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
            result[i] = val;
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    if (a instanceof Float32Array) {
        return a;
    }
    else {
        var res = new Float32Array(a.length);
        for (var i = 0; i < res.length; i++) {
            var val = a[i];
            res[i] = util.isValNaN(val, dtype) ? NaN : val;
        }
        return res;
    }
}

},{"../../environment":10,"../../util":122,"../axis_util":48,"../math":103,"../ndarray":105,"../reduce_util":112,"../types":119,"./webgl/argminmax_gpu":55,"./webgl/avg_pool_backprop_gpu":56,"./webgl/batchnorm_gpu":57,"./webgl/binaryop_gpu":58,"./webgl/clip_gpu":59,"./webgl/concat_gpu":60,"./webgl/conv_backprop_gpu":61,"./webgl/conv_gpu":62,"./webgl/conv_gpu_depthwise":63,"./webgl/copy_gpu":64,"./webgl/from_pixels_gpu":65,"./webgl/gather_gpu":66,"./webgl/gpgpu_context":67,"./webgl/gpgpu_math":68,"./webgl/logical_gpu":70,"./webgl/lrn_gpu":71,"./webgl/max_pool_backprop_gpu":72,"./webgl/mulmat_gpu":73,"./webgl/multinomial_gpu":74,"./webgl/onehot_gpu":75,"./webgl/pad_gpu":76,"./webgl/pool_gpu":77,"./webgl/reduce_gpu":78,"./webgl/resize_bilinear_gpu":80,"./webgl/reverse_gpu":81,"./webgl/slice_gpu":83,"./webgl/tex_util":84,"./webgl/texture_manager":85,"./webgl/tile_gpu":86,"./webgl/transpose_gpu":87,"./webgl/unaryop_gpu":88,"./webgl/webgl_util":89}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var ndarray_1 = require("../ndarray");
function executeKernel(backend, kernelName, inputAndArgs) {
    if (kernelName === 'MatMul') {
        var config = inputAndArgs;
        return backend.matMul(config.inputs.a, config.inputs.b, config.args.aOrientation, config.args.bOrientation);
    }
    else if (kernelName === 'Clone') {
        var config = inputAndArgs;
        return backend.clone(config.inputs.x);
    }
    else if (kernelName === 'Slice1D') {
        var config = inputAndArgs;
        return backend.slice1D(config.inputs.x, config.args.begin, config.args.size);
    }
    else if (kernelName === 'Slice2D') {
        var config = inputAndArgs;
        return backend.slice2D(config.inputs.x, config.args.begin, config.args.size);
    }
    else if (kernelName === 'Slice3D') {
        var config = inputAndArgs;
        return backend.slice3D(config.inputs.x, config.args.begin, config.args.size);
    }
    else if (kernelName === 'Slice4D') {
        var config = inputAndArgs;
        return backend.slice4D(config.inputs.x, config.args.begin, config.args.size);
    }
    else if (kernelName === 'Reverse4D') {
        var config = inputAndArgs;
        return backend.reverse4D(config.inputs.x, config.args.axis);
    }
    else if (kernelName === 'Concat') {
        var config = inputAndArgs;
        return backend.concat(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Neg') {
        var config = inputAndArgs;
        return backend.neg(config.inputs.x);
    }
    else if (kernelName === 'Add') {
        var config = inputAndArgs;
        return backend.add(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Sub') {
        var config = inputAndArgs;
        return backend.subtract(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Mul') {
        var config = inputAndArgs;
        return backend.multiply(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Div') {
        var config = inputAndArgs;
        return backend.divide(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Sum') {
        var config = inputAndArgs;
        return backend.sum(config.inputs.x, config.args.axes);
    }
    else if (kernelName === 'ArgMax') {
        var config = inputAndArgs;
        return backend.argMax(config.inputs.x, config.args.axes);
    }
    else if (kernelName === 'ArgMin') {
        var config = inputAndArgs;
        return backend.argMin(config.inputs.x, config.args.axes);
    }
    else if (kernelName === 'Equal') {
        var config = inputAndArgs;
        return backend.equal(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'NotEqual') {
        var config = inputAndArgs;
        return backend.notEqual(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Less') {
        var config = inputAndArgs;
        return backend.less(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'LessEqual') {
        var config = inputAndArgs;
        return backend.lessEqual(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Greater') {
        var config = inputAndArgs;
        return backend.greater(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'GreaterEqual') {
        var config = inputAndArgs;
        return backend.greaterEqual(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'LogicalAnd') {
        var config = inputAndArgs;
        return backend.logicalAnd(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'LogicalOr') {
        var config = inputAndArgs;
        return backend.logicalOr(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Where') {
        var config = inputAndArgs;
        return backend.where(config.inputs.condition, config.inputs.a, config.inputs.b, config.args.dtype);
    }
    else if (kernelName === 'TopKValues') {
        var config = inputAndArgs;
        return backend.topKValues(config.inputs.x, config.args.k);
    }
    else if (kernelName === 'TopKIndices') {
        var config = inputAndArgs;
        return backend.topKIndices(config.inputs.x, config.args.k);
    }
    else if (kernelName === 'Min') {
        var config = inputAndArgs;
        return backend.min(config.inputs.x, config.args.axes);
    }
    else if (kernelName === 'Minimum') {
        var config = inputAndArgs;
        return backend.minimum(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Max') {
        var config = inputAndArgs;
        return backend.max(config.inputs.x, config.args.axes);
    }
    else if (kernelName === 'Maximum') {
        var config = inputAndArgs;
        return backend.maximum(config.inputs.a, config.inputs.b);
    }
    else if (kernelName === 'Ceil') {
        var config = inputAndArgs;
        return backend.ceil(config.inputs.x);
    }
    else if (kernelName === 'Floor') {
        var config = inputAndArgs;
        return backend.floor(config.inputs.x);
    }
    else if (kernelName === 'Pow') {
        var config = inputAndArgs;
        return backend.pow(config.inputs.base, config.inputs.exp);
    }
    else if (kernelName === 'Exp') {
        var config = inputAndArgs;
        return backend.exp(config.inputs.x);
    }
    else if (kernelName === 'Log') {
        var config = inputAndArgs;
        return backend.log(config.inputs.x);
    }
    else if (kernelName === 'Sqrt') {
        var config = inputAndArgs;
        return backend.sqrt(config.inputs.x);
    }
    else if (kernelName === 'Square') {
        var config = inputAndArgs;
        return backend.square(config.inputs.x);
    }
    else if (kernelName === 'Relu') {
        var config = inputAndArgs;
        return backend.relu(config.inputs.x);
    }
    else if (kernelName === 'Reshape') {
        var config = inputAndArgs;
        var x = config.inputs.x;
        var newShape = config.args.newShape;
        return ndarray_1.NDArray.make(newShape, { dataId: x.dataId }, x.dtype);
    }
    else if (kernelName === 'Cast') {
        var config = inputAndArgs;
        var x = config.inputs.x;
        var newDType = config.args.newDType;
        if (!util.hasEncodingLoss(x.dtype, newDType)) {
            return ndarray_1.NDArray.make(x.shape, { dataId: x.dataId }, newDType);
        }
        if (newDType === 'int32') {
            return backend.int(x);
        }
        else if (newDType === 'bool') {
            return backend.notEqual(x, ndarray_1.Scalar.new(0, x.dtype));
        }
        else {
            throw new Error("Error in Cast: unknown dtype argument (" + newDType + ")");
        }
    }
    else if (kernelName === 'LeakyRelu') {
        var config = inputAndArgs;
        return backend.leakyRelu(config.inputs.x, config.args.alpha);
    }
    else if (kernelName === 'PReLU') {
        var config = inputAndArgs;
        return backend.prelu(config.inputs.x, config.inputs.alpha);
    }
    else if (kernelName === 'PReLUDer') {
        var config = inputAndArgs;
        return backend.preluDer(config.inputs.x, config.inputs.alpha);
    }
    else if (kernelName === 'Elu') {
        var config = inputAndArgs;
        return backend.elu(config.inputs.x);
    }
    else if (kernelName === 'EluDer') {
        var config = inputAndArgs;
        return backend.eluDer(config.inputs.x);
    }
    else if (kernelName === 'Selu') {
        var config = inputAndArgs;
        return backend.selu(config.inputs.x);
    }
    else if (kernelName === 'Abs') {
        var config = inputAndArgs;
        return backend.abs(config.inputs.x);
    }
    else if (kernelName === 'Sigmoid') {
        var config = inputAndArgs;
        return backend.sigmoid(config.inputs.x);
    }
    else if (kernelName === 'Step') {
        var config = inputAndArgs;
        return backend.step(config.inputs.x, config.args.alpha);
    }
    else if (kernelName === 'Sin') {
        var config = inputAndArgs;
        return backend.sin(config.inputs.x);
    }
    else if (kernelName === 'Cos') {
        var config = inputAndArgs;
        return backend.cos(config.inputs.x);
    }
    else if (kernelName === 'Tan') {
        var config = inputAndArgs;
        return backend.tan(config.inputs.x);
    }
    else if (kernelName === 'Asin') {
        var config = inputAndArgs;
        return backend.asin(config.inputs.x);
    }
    else if (kernelName === 'Acos') {
        var config = inputAndArgs;
        return backend.acos(config.inputs.x);
    }
    else if (kernelName === 'Atan') {
        var config = inputAndArgs;
        return backend.atan(config.inputs.x);
    }
    else if (kernelName === 'Sinh') {
        var config = inputAndArgs;
        return backend.sinh(config.inputs.x);
    }
    else if (kernelName === 'Cosh') {
        var config = inputAndArgs;
        return backend.cosh(config.inputs.x);
    }
    else if (kernelName === 'Tanh') {
        var config = inputAndArgs;
        return backend.tanh(config.inputs.x);
    }
    else if (kernelName === 'Clip') {
        var config = inputAndArgs;
        return backend.clip(config.inputs.x, config.args.min, config.args.max);
    }
    else if (kernelName === 'Tile') {
        var config = inputAndArgs;
        return backend.tile(config.inputs.x, config.args.reps);
    }
    else if (kernelName === 'Gather') {
        var config = inputAndArgs;
        return backend.gather(config.inputs.x, config.inputs.indices, config.args.axis);
    }
    else if (kernelName === 'Pad1D') {
        var config = inputAndArgs;
        return backend.pad1D(config.inputs.x, config.args.paddings, config.args.constantValue);
    }
    else if (kernelName === 'Pad2D') {
        var config = inputAndArgs;
        return backend.pad2D(config.inputs.x, config.args.paddings, config.args.constantValue);
    }
    else if (kernelName === 'Transpose') {
        var config = inputAndArgs;
        return backend.transpose(config.inputs.x, config.args.perm);
    }
    else if (kernelName === 'Conv2D') {
        var config = inputAndArgs;
        return backend.conv2d(config.inputs.x, config.inputs.filter, config.inputs.bias, config.args.convInfo);
    }
    else if (kernelName === 'Conv2DDerInput') {
        var config = inputAndArgs;
        return backend.conv2dDerInput(config.inputs.dy, config.inputs.filter, config.args.convInfo);
    }
    else if (kernelName === 'Conv2DDerFilter') {
        var config = inputAndArgs;
        return backend.conv2dDerFilter(config.inputs.x, config.inputs.dy, config.args.convInfo);
    }
    else if (kernelName === 'Conv2DDerBias') {
        var config = inputAndArgs;
        return backend.conv2dDerBias(config.inputs.dy);
    }
    else if (kernelName === 'DepthwiseConv2D') {
        var config = inputAndArgs;
        return backend.depthwiseConv2D(config.inputs.x, config.inputs.filter, config.args.convInfo);
    }
    else if (kernelName === 'MaxPool') {
        var config = inputAndArgs;
        return backend.maxPool(config.inputs.x, config.args.convInfo);
    }
    else if (kernelName === 'MaxPoolBackprop') {
        var config = inputAndArgs;
        return backend.maxPoolBackprop(config.inputs.dy, config.inputs.x, config.args.convInfo);
    }
    else if (kernelName === 'AvgPool') {
        var config = inputAndArgs;
        return backend.avgPool(config.inputs.x, config.args.convInfo);
    }
    else if (kernelName === 'AvgPoolBackprop') {
        var config = inputAndArgs;
        return backend.avgPoolBackprop(config.inputs.dy, config.inputs.x, config.args.convInfo);
    }
    else if (kernelName === 'MinPool') {
        var config = inputAndArgs;
        return backend.minPool(config.inputs.x, config.args.convInfo);
    }
    else if (kernelName === 'ResizeBilinear') {
        var config = inputAndArgs;
        return backend.resizeBilinear(config.inputs.x, config.args.newHeight, config.args.newWidth, config.args.alignCorners);
    }
    else if (kernelName === 'BatchNorm4D') {
        var config = inputAndArgs;
        return backend.batchNormalization4D(config.inputs.x, config.inputs.mean, config.inputs.variance, config.args.varianceEpsilon, config.inputs.scale, config.inputs.offset);
    }
    else if (kernelName === 'BatchNorm3D') {
        var config = inputAndArgs;
        return backend.batchNormalization3D(config.inputs.x, config.inputs.mean, config.inputs.variance, config.args.varianceEpsilon, config.inputs.scale, config.inputs.offset);
    }
    else if (kernelName === 'BatchNorm2D') {
        var config = inputAndArgs;
        return backend.batchNormalization2D(config.inputs.x, config.inputs.mean, config.inputs.variance, config.args.varianceEpsilon, config.inputs.scale, config.inputs.offset);
    }
    else if (kernelName === 'LRN4D') {
        var config = inputAndArgs;
        return backend.localResponseNormalization4D(config.inputs.x, config.args.radius, config.args.bias, config.args.alpha, config.args.beta, config.args.normRegion);
    }
    else if (kernelName === 'Multinomial') {
        var config = inputAndArgs;
        return backend.multinomial(config.inputs.probs, config.args.numSamples, config.args.seed);
    }
    else if (kernelName === 'OneHot') {
        var config = inputAndArgs;
        return backend.oneHot(config.inputs.indices, config.args.depth, config.args.onValue, config.args.offValue);
    }
    throw new Error("No backend method found for kernel " + kernelName);
}
exports.executeKernel = executeKernel;

},{"../../util":122,"../ndarray":105}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var ndarray_1 = require("../ndarray");
function getFilteredNodesXToY(tape, xs, y) {
    var arraysFromX = {};
    var nodesFromX = {};
    for (var i = 0; i < xs.length; i++) {
        arraysFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var nodeInputs = node.inputAndArgs.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            var anyInputFromX = false;
            for (var j = 0; j < xs.length; j++) {
                if (arraysFromX[input.id]) {
                    if (node.output instanceof ndarray_1.NDArray) {
                        arraysFromX[node.output.id] = true;
                    }
                    else {
                        var keys = Object.keys(node.output);
                        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                            var key = keys_1[_i];
                            arraysFromX[node.output[key].id] = true;
                        }
                    }
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    var arraysLeadToY = {};
    arraysLeadToY[y.id] = true;
    var nodesToY = {};
    for (var i = tape.length - 1; i >= 0; i--) {
        var node = tape[i];
        var nodeInputs = node.inputAndArgs.inputs;
        var outputs = [];
        if (node.output instanceof ndarray_1.NDArray) {
            outputs.push(node.output);
        }
        else {
            var keys = Object.keys(node.output);
            for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
                var key = keys_2[_a];
                outputs.push(node.output[key]);
            }
        }
        for (var j = 0; j < outputs.length; j++) {
            if (arraysLeadToY[outputs[j].id]) {
                for (var inputName in nodeInputs) {
                    arraysLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    var filteredTape = [];
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputAndArgs.inputs) {
                var nodeInput = node.inputAndArgs.inputs[inputName];
                if (arraysFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedOutputs = void 0;
            if (node.output instanceof ndarray_1.NDArray) {
                prunedOutputs = node.output;
            }
            else {
                prunedOutputs = {};
                for (var outputName in node.output) {
                    var output = node.output[outputName];
                    if (arraysLeadToY[output.id]) {
                        prunedOutputs[outputName] = node.output[outputName];
                    }
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputAndArgs = { inputs: prunedInputs };
            prunedNode.output = prunedOutputs;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(arrayAccumulatedGradientMap, filteredTape) {
    for (var i = filteredTape.length - 1; i >= 0; i--) {
        var node = filteredTape[i];
        var dy = void 0;
        if (node.output instanceof ndarray_1.NDArray) {
            dy = arrayAccumulatedGradientMap[node.output.id];
        }
        else {
            dy = {};
            var keys = Object.keys(node.output);
            for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
                var key = keys_3[_i];
                dy[key] = arrayAccumulatedGradientMap[node.output[key].id];
            }
        }
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found " +
                ("for " + node.name + "."));
        }
        var inputGradients = node.gradient(dy, node.output);
        for (var inputName in node.inputAndArgs.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName + ". " +
                    ("Available gradients found: " + Object.keys(inputGradients) + "."));
            }
            var dx = inputGradients[inputName]();
            var x = node.inputAndArgs.inputs[inputName];
            if (!util.arraysEqual(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.name + ". The gradient of input " +
                    ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") +
                    ("the shape of the input '" + x.shape + "'"));
            }
            if (arrayAccumulatedGradientMap[x.id] == null) {
                arrayAccumulatedGradientMap[x.id] = dx;
            }
            else {
                var curGradient = arrayAccumulatedGradientMap[x.id];
                arrayAccumulatedGradientMap[x.id] = curGradient.add(dx);
                curGradient.dispose();
            }
        }
    }
}
exports.backpropagateGradients = backpropagateGradients;
function computeVariableInputs(tape, varList) {
    var trainableVariables = [];
    var trainableVariablesSeen = {};
    var variableIds = {};
    varList.forEach(function (variable) {
        variableIds[variable.id] = true;
    });
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var inputs = node.inputAndArgs.inputs;
        var keys = Object.keys(inputs);
        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
            var key = keys_4[_i];
            var input = inputs[key];
            if (input instanceof ndarray_1.Variable && !trainableVariablesSeen[input.id]) {
                if (varList != null) {
                    if (variableIds[input.id] == null) {
                        continue;
                    }
                }
                trainableVariables.push(input);
                trainableVariablesSeen[inputs[key].id] = true;
            }
        }
    }
    return trainableVariables;
}
exports.computeVariableInputs = computeVariableInputs;
function extractNDArraysFromScopeResult(result) {
    if (result == null) {
        return [];
    }
    if (result instanceof ndarray_1.NDArray) {
        return [result];
    }
    var list = [];
    var resultObj = result;
    for (var k in resultObj) {
        list.push.apply(list, util.flatten(resultObj[k]));
    }
    return list;
}
exports.extractNDArraysFromScopeResult = extractNDArraysFromScopeResult;
function stripUndefinedInputsFromInputConfig(config) {
    var keys = Object.keys(config.inputs);
    keys.forEach(function (key) {
        if (config.inputs[key] == null) {
            delete config.inputs[key];
        }
    });
    return config;
}
exports.stripUndefinedInputsFromInputConfig = stripUndefinedInputsFromInputConfig;

},{"../../util":122,"../ndarray":105}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));

},{}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AvgPool2DBackpropProgram = (function () {
    function AvgPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return AvgPool2DBackpropProgram;
}());
exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram;

},{}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../../broadcast_util":92}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../broadcast_util");
var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
exports.EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a == b);\n";
exports.NOT_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a != b);\n";
exports.LESS = CHECK_NAN_SNIPPET + "\n  return float(a < b);\n";
exports.LESS_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a <= b);\n";
exports.GREATER = CHECK_NAN_SNIPPET + "\n  return float(a > b);\n";
exports.GREATER_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a >= b);\n";
exports.LOGICAL_AND = CHECK_NAN_SNIPPET + "\n  return float(a >= 1.0 && b >= 1.0);\n";
exports.LOGICAL_OR = CHECK_NAN_SNIPPET + "\n  return float(a >= 1.0 || b >= 1.0);\n";
exports.PRELU = "\n  return (a >= 0.0) ? a : b * a;\n";
exports.PRELU_DER = "\n  return (a > 0.0) ? 1.0 : ((a < 0.0) ? b : a);\n";
exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../broadcast_util":92}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../concat_util");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.outputShape =
            concat_util.computeOutShape(aShape, bShape, 1);
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;

},{"../../concat_util":95}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DDerFilterProgram = (function () {
    function Conv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerFilterProgram;
}());
exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
var Conv2DDerBiasProgram = (function () {
    function Conv2DDerBiasProgram(yShape) {
        this.variableNames = ['dy'];
        var batchSize = yShape[0], yNumRows = yShape[1], yNumCols = yShape[2], outputDepth = yShape[3];
        this.outputShape = [outputDepth];
        this.userCode = "\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int b = 0; b < " + batchSize + "; b++) {\n          for (int yR = 0; yR < " + yNumRows + "; yR++) {\n            for (int yC = 0; yC < " + yNumCols + "; yC++) {\n              derBias += getDy(b, yR, yC, d2);\n            }\n          }\n        }\n        setOutput(derBias);\n      }\n    ";
    }
    return Conv2DDerBiasProgram;
}());
exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;

},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo, hasBias) {
        this.variableNames = ['x', 'W'];
        if (hasBias) {
            this.variableNames.push('bias');
        }
        this.outputShape = convInfo.outShape;
        var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        var inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        " + biasSnippet + "\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inHeight;
        var xNumCols = convInfo.inWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Copy2DProgram = (function () {
    function Copy2DProgram(srcNumCols, destNumCols) {
        this.variableNames = ['source'];
        this.outputShape = null;
        this.userCode = "\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * " + destNumCols + " + destCoords.y;\n        int r = index / " + srcNumCols + ";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * " + srcNumCols + ");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";
    }
    Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
        return function (gpgpu, webGLProgram) {
            gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
            var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');
            gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
            var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');
            gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
        };
    };
    return Copy2DProgram;
}());
exports.Copy2DProgram = Copy2DProgram;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromPixelsProgram = (function () {
    function FromPixelsProgram(outputShape) {
        this.variableNames = ['A'];
        var height = outputShape[0], width = outputShape[1];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    }
    return FromPixelsProgram;
}());
exports.FromPixelsProgram = FromPixelsProgram;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherProgram = (function () {
    function GatherProgram(aShape, indicesLength, axis) {
        this.variableNames = ['A', 'indices'];
        var outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape, axis);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return GatherProgram;
}());
exports.GatherProgram = GatherProgram;
function getSourceCoords(aShape, axis) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Gather for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "int(getIndices(resRC))";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        if (i === axis) {
            sourceCoords.push("int(getIndices(" + currentCoords[i] + "))");
        }
        else {
            sourceCoords.push("" + currentCoords[i]);
        }
    }
    return sourceCoords.join();
}

},{"./shader_compiler":82}],67:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../../environment");
var util = require("../../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
        if (shouldThrow === void 0) { shouldThrow = true; }
        this.throwIfDisposed();
        if (shouldThrow) {
            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);
        }
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function (attribLocations) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
            return this.runQueryWebGL2(queryFn);
        }
        return this.runQueryWebGL1(queryFn);
    };
    GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');
        var query = this.gl.createQuery();
        this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        this.gl.endQuery(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"../../../environment":10,"../../../util":122,"./gpgpu_util":69,"./tex_util":84,"./webgl_util":89}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../../environment");
var util = require("../../../util");
var shader_compiler = require("./shader_compiler");
var ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.array.shape,
            texShape: input.texData.texShape
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.array.shape,
        texShape: output.texData.texShape
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    var attributeLocations = {};
    ATTRIBUTE_NAMES.forEach(function (attribute) {
        attributeLocations[attribute] =
            gpgpu.getAttributeLocation(webGLProgram, attribute);
    });
    if (shouldUploadNaNUniform()) {
        var throwIfNaNUniformIsNotUsed = false;
        uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].array.shape;
        var texShapeB = inputs[i].texData.texShape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.texData.texture;
    var outTexShape = output.texData.texShape;
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.texData.texture;
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram(binary.attributeLocations);
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.array.shape + "_" + x.texData.texShape;
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../../environment":10,"../../../util":122,"./shader_compiler":82}],69:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var downloadTarget;
    if (isFloatTexture) {
        downloadTarget =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    }
    else {
        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
    }
    return downloadTarget;
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../../environment":10,"./tex_util":84,"./webgl_util":89}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var WhereProgram = (function () {
    function WhereProgram(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        var cCoords;
        var abCoords;
        if (rank > 4) {
            throw Error("Where for rank " + rank + " is not yet supported");
        }
        if (rank === 1) {
            abCoords = "resRC";
            cCoords = "resRC";
        }
        else {
            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            var cCoordVars = [];
            var abCoordVars = [];
            for (var i = 0; i < shape.length; i++) {
                abCoordVars.push("" + currentCoords[i]);
                if (i < cRank) {
                    cCoordVars.push("" + currentCoords[i]);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        var dtype = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    ";
    }
    return WhereProgram;
}());
exports.WhereProgram = WhereProgram;

},{"./shader_compiler":82}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNProgram = (function () {
    function LRNProgram(xShape, radius, bias, alpha, beta, normRegion) {
        this.variableNames = ['x'];
        this.outputShape = [];
        var rad = radius;
        var maxW = xShape[1] - 1;
        var maxH = xShape[2] - 1;
        var maxD = xShape[3] - 1;
        this.outputShape = xShape;
        var powOperator;
        var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
        if (beta === 0.5) {
            powOperator = "inversesqrt(" + basis + ")";
        }
        else if (beta === 1.0) {
            powOperator = "1.0/(" + basis + ")";
        }
        else {
            powOperator = "exp(log(" + basis + ") * float(-" + beta + "));";
        }
        if (normRegion === 'withinChannel') {
            this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int b = coords[0];\n          int r = coords[1];\n          int c = coords[2];\n          int d = coords[3];\n          float x = getX(b, r, c, d);\n          float sum = 0.0;\n          for (int u = -" + rad + "; u <= " + rad + "; u++) {\n            for (int v = -" + rad + "; v <= " + rad + "; v++) {\n              int idx = r + u;\n              int idy = c + v;\n              if (idx >= 0 && idx <= " + maxW + " && idy >= 0 && idy <= " + maxH + ") {\n                float z = getX(b, idx, idy, d);\n                sum += z * z;\n              }\n            }\n          }\n          float val = x * " + powOperator + ";\n          setOutput(val);\n        }\n      ";
        }
        else {
            this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int b = coords[0];\n          int r = coords[1];\n          int c = coords[2];\n          int d = coords[3];\n          float x = getX(b, r, c, d);\n          float sum = 0.0;\n          for (int j = -" + rad + "; j <= " + rad + "; j++) {\n            int idx = d + j;\n            if (idx >= 0 && idx <=  " + maxD + ") {\n              float z = getX(b, r, c, idx);\n              sum += z * z;\n            }\n          }\n          float val = x * " + powOperator + ";\n          setOutput(val);\n        }\n      ";
        }
    }
    return LRNProgram;
}());
exports.LRNProgram = LRNProgram;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var matmul_1 = require("../types/matmul");
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = matmul_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = matmul_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = (aOrient === matmul_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === matmul_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === matmul_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return (aOrient === matmul_1.MatrixOrientation.REGULAR) ?
                "aRow, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", aRow";
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return (bOrient === matmul_1.MatrixOrientation.REGULAR) ?
                indexVar + " + " + vec4Offset + ", bCol" :
                "bCol, " + indexVar + " + " + vec4Offset;
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{"../types/matmul":54}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pad1DProgram = (function () {
    function Pad1DProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        var leftPadding = paddings[0];
        var rightPadding = paddings[1];
        this.outputShape = [leftPadding + xShape[0] + rightPadding];
        this.rank = 1;
        this.userCode = "\n      void main() {\n        int resRC = getOutputCoords();\n        if (resRC < " + leftPadding + " || resRC >= " + leftPadding + " + " + xShape[0] + ") {\n          setOutput(float(" + constantValue + "));\n        } else {\n          setOutput(getX(resRC - " + leftPadding + "));\n        }\n      }\n    ";
    }
    return Pad1DProgram;
}());
exports.Pad1DProgram = Pad1DProgram;
var Pad2DProgram = (function () {
    function Pad2DProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        var topPadding = paddings[0][0];
        var bottomPadding = paddings[0][1];
        var leftPadding = paddings[1][0];
        var rightPadding = paddings[1][1];
        this.outputShape = [
            topPadding + xShape[0] + bottomPadding,
            leftPadding + xShape[1] + rightPadding
        ];
        this.rank = 2;
        var sourceCoords = "resRC.x - " + topPadding + ", resRC.y - " + leftPadding;
        this.userCode = "\n      void main() {\n        ivec2 resRC = getOutputCoords();\n        int topShape = " + topPadding + " + " + xShape[0] + ";\n        int leftShape = " + leftPadding + " + " + xShape[1] + ";\n        if (resRC.x < " + topPadding + " || resRC.x >= topShape ||\n            resRC.y < " + leftPadding + " || resRC.y >= leftShape) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          setOutput(getX(" + sourceCoords + "));\n        }\n      }\n    ";
    }
    return Pad2DProgram;
}());
exports.Pad2DProgram = Pad2DProgram;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            if (poolType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        if (computePositions) {
            var compareOp_1 = poolType === 'min' ? '<=' : '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = poolType === 'min' ? 'min' : 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = require("./webgl_util");
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');
    gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;

},{"./webgl_util":89}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearProgram = (function () {
    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinearProgram;
}());
exports.ResizeBilinearProgram = ResizeBilinearProgram;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReverseProgram = (function () {
    function ReverseProgram(xShape, axis) {
        this.variableNames = ['x'];
        this.outputShape = xShape;
        var getRevVar = function (i) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return xShape[i] + " - coords[" + i + "] - 1";
            }
            return "coords[" + i + "]";
        };
        var b = getRevVar(0);
        var r = getRevVar(1);
        var c = getRevVar(2);
        var d = getRevVar(3);
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        float val = getX(" + b + ", " + r + ", " + c + ", " + d + ");\n        setOutput(val);\n      }\n    ";
    }
    return ReverseProgram;
}());
exports.ReverseProgram = ReverseProgram;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../../environment");
var util = require("../../../util");
var broadcast_util = require("../../broadcast_util");
var tex_util = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col', 'depth'];
        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
    }
    if (texNumC === stride0) {
        return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
    }
    if (texNumC === stride1) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank === 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../../environment":10,"../../../util":122,"../../broadcast_util":92,"./tex_util":84}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":82}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["FLOAT"] = 0] = "FLOAT";
    TextureType[TextureType["UNSIGNED_BYTE"] = 1] = "UNSIGNED_BYTE";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util_1 = require("./tex_util");
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.allocatedTextures = [];
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shapeRC, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        var newTexture = this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
        this.allocatedTextures.push(newTexture);
        return newTexture;
    };
    TextureManager.prototype.releaseTexture = function (texture, shape, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shape, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        var _this = this;
        if (this.allocatedTextures == null) {
            return;
        }
        this.allocatedTextures.forEach(function (texture) {
            _this.gpgpu.deleteMatrixTexture(texture);
        });
        this.freeTextures = null;
        this.allocatedTextures = null;
        this.usedTextureCount = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol, texType) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + texType;
}

},{"./tex_util":84}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":82}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 4) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":82}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
var CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) return x;\n";
exports.ABS = "\n  return abs(x);\n";
exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
exports.ELU_DER = "\n  return (x >= 0.0) ? 1.0 : exp(x);\n";
exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768599402175208123;\n  float scale = 1.0507009873554804934193349852946;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
function LEAKY_RELU(alpha) {
    return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
}
exports.LEAKY_RELU = LEAKY_RELU;
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
}
exports.STEP = STEP;
exports.NEG = "\n  return -x;\n";
exports.CEIL = "\n  return ceil(x);\n";
exports.FLOOR = "\n  return floor(x);\n";
exports.EXP = "\n  return exp(x);\n";
exports.LOG = "\n  return log(x);\n";
exports.SQRT = CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
exports.SIN = CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "\n  return tan(x);\n";
exports.ASIN = CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
exports.ACOS = CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.SQUARE = "\n  return x * x;\n";
exports.TO_INT = "\n  return float(int(x));\n";

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../../util");
var environment_1 = require("../../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
    var loc = -1;
    if ((attribLocations != null) && (attribute in attribLocations)) {
        loc = attribLocations[attribute];
    }
    else {
        loc = gl.getAttribLocation(program, attribute);
    }
    if (loc === -1) {
        return;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
exports.getProgramUniformLocation = getProgramUniformLocation;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../../environment":10,"../../../util":122}],90:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return environment_1.ENV.engine.executeKernel('BatchNorm2D', {
            inputs: { x: x, mean: mean, variance: variance, scale: scale, offset: offset },
            args: { varianceEpsilon: varianceEpsilon }
        });
    };
    Ops.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return environment_1.ENV.engine.executeKernel('BatchNorm3D', {
            inputs: { x: x, mean: mean, variance: variance, scale: scale, offset: offset },
            args: { varianceEpsilon: varianceEpsilon }
        });
    };
    Ops.batchNormalization4D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 4 || mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 4 || variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 4 || scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 4 || offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return environment_1.ENV.engine.executeKernel('BatchNorm4D', {
            inputs: { x: x, mean: mean, variance: variance, scale: scale, offset: offset },
            args: { varianceEpsilon: varianceEpsilon }
        });
    };
    Ops.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        if (x.rank === 0) {
            throw new Error("Batchnorm for scalar is not supported");
        }
        else if (x.rank === 1) {
            throw new Error("Batchnorm for rank 1 is not yet implemented");
        }
        else if (x.rank === 2) {
            return Ops.batchNormalization2D(x, mean, variance, varianceEpsilon, scale, offset);
        }
        else if (x.rank === 3) {
            return Ops.batchNormalization3D(x, mean, variance, varianceEpsilon, scale, offset);
        }
        else if (x.rank === 4) {
            return Ops.batchNormalization4D(x, mean, variance, varianceEpsilon, scale, offset);
        }
        else {
            throw new Error("Batchnorm for rank " + x.rank + " is not yet implemented");
        }
    };
    __decorate([
        decorators_1.operation
    ], Ops, "batchNormalization2D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "batchNormalization3D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "batchNormalization4D", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./decorators":99}],91:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var Ops = (function () {
    function Ops() {
    }
    Ops.add = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy, y) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.executeKernel('Add', { inputs: { a: a, b: b } }, der);
    };
    Ops.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return a.add(b);
    };
    Ops.sub = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy, y) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.neg().reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.executeKernel('Sub', { inputs: { a: a, b: b } }, der);
    };
    Ops.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return a.sub(b);
    };
    Ops.pow = function (base, exp) {
        util.assert(exp.dtype === 'int32', 'only supports int32 data type for the exponent parameter.');
        broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);
        var gradient = function (dy, y) {
            if (!util.arraysEqual(base.shape, exp.shape)) {
                throw new Error("Gradient of pow not yet supported for broadcasted shapes.");
            }
            var derBase = function () {
                var dx = exp.toFloat().mul(base.pow(exp.sub(ndarray_1.Scalar.new(1, 'int32'))).toFloat());
                return dy.mul(dx);
            };
            var derExp = function () {
                throw new Error("Backprop through exponent of math.pow not " +
                    "implemented yet.");
            };
            return { base: derBase, exp: derExp };
        };
        return environment_1.ENV.engine.executeKernel('Pow', { inputs: { base: base, exp: exp } }, gradient);
    };
    Ops.powStrict = function (base, exp) {
        util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');
        return base.pow(exp);
    };
    Ops.mul = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy, y) {
            var derA = function () {
                var res = dy.mul(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.executeKernel('Mul', { inputs: { a: a, b: b } }, der);
    };
    Ops.elementWiseMul = function (a, b) {
        return a.mulStrict(b);
    };
    Ops.mulStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return a.mul(b);
    };
    Ops.div = function (a, b) {
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy, y) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.executeKernel('Div', { inputs: { a: a, b: b } }, der);
    };
    Ops.divStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return a.div(b);
    };
    Ops.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return c.div(a);
    };
    Ops.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return a.div(c);
    };
    Ops.minimum = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('Minimum', { inputs: { a: a, b: b } });
    };
    Ops.minimumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.minimum(b);
    };
    Ops.maximum = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('Maximum', { inputs: { a: a, b: b } });
    };
    Ops.maximumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.maximum(b);
    };
    __decorate([
        decorators_1.operation
    ], Ops, "add", null);
    __decorate([
        decorators_1.operation
    ], Ops, "addStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sub", null);
    __decorate([
        decorators_1.operation
    ], Ops, "subStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "pow", null);
    __decorate([
        decorators_1.operation
    ], Ops, "powStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "mul", null);
    __decorate([
        decorators_1.operation
    ], Ops, "elementWiseMul", null);
    __decorate([
        decorators_1.operation
    ], Ops, "mulStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "div", null);
    __decorate([
        decorators_1.operation
    ], Ops, "divStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "scalarDividedByArray", null);
    __decorate([
        decorators_1.operation
    ], Ops, "arrayDividedByScalar", null);
    __decorate([
        decorators_1.operation
    ], Ops, "minimum", null);
    __decorate([
        decorators_1.operation
    ], Ops, "minimumStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "maximum", null);
    __decorate([
        decorators_1.operation
    ], Ops, "maximumStrict", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./broadcast_util":92,"./decorators":99,"./ndarray":105}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function getReductionAxes(inShape, outShape) {
    var result = [];
    for (var i = 0; i < outShape.length; i++) {
        var inDim = inShape[inShape.length - i - 1];
        var outAxis = outShape.length - i - 1;
        var outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
exports.getReductionAxes = getReductionAxes;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],93:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.notEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('NotEqual', { inputs: { a: a, b: b } });
    };
    Ops.notEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in notEqualStrict: ');
        return a.notEqual(b);
    };
    Ops.less = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('Less', { inputs: { a: a, b: b } });
    };
    Ops.lessStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessStrict: ');
        return a.less(b);
    };
    Ops.equal = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('Equal', { inputs: { a: a, b: b } });
    };
    Ops.equalStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in equalStrict: ');
        return a.equal(b);
    };
    Ops.lessEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('LessEqual', { inputs: { a: a, b: b } });
    };
    Ops.lessEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessEqualStrict: ');
        return a.lessEqual(b);
    };
    Ops.greater = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('Greater', { inputs: { a: a, b: b } });
    };
    Ops.greaterStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterStrict: ');
        return a.greater(b);
    };
    Ops.greaterEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('GreaterEqual', { inputs: { a: a, b: b } });
    };
    Ops.greaterEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterEqualStrict: ');
        return a.greaterEqual(b);
    };
    __decorate([
        decorators_1.operation
    ], Ops, "notEqual", null);
    __decorate([
        decorators_1.operation
    ], Ops, "notEqualStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "less", null);
    __decorate([
        decorators_1.operation
    ], Ops, "lessStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "equal", null);
    __decorate([
        decorators_1.operation
    ], Ops, "equalStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "lessEqual", null);
    __decorate([
        decorators_1.operation
    ], Ops, "lessEqualStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "greater", null);
    __decorate([
        decorators_1.operation
    ], Ops, "greaterStrict", null);
    __decorate([
        decorators_1.operation
    ], Ops, "greaterEqual", null);
    __decorate([
        decorators_1.operation
    ], Ops, "greaterEqualStrict", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./broadcast_util":92,"./decorators":99}],94:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var concat_util = require("./concat_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.concat1D = function (a, b) {
        return Ops.concat(a, b, 0);
    };
    Ops.concat2D = function (a, b, axis) {
        return Ops.concat(a, b, axis);
    };
    Ops.concat3D = function (a, b, axis) {
        return Ops.concat(a, b, axis);
    };
    Ops.concat4D = function (a, b, axis) {
        return Ops.concat(a, b, axis);
    };
    Ops.concat = function (a, b, axis) {
        concat_util.assertParams(a.shape, b.shape, axis);
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
        var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
        var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
        var der = function (dy) {
            return {
                a: function () { return dy.slice(aBegin, aSize); },
                b: function () { return dy.slice(bBegin, bSize); }
            };
        };
        var res = environment_1.ENV.engine.executeKernel('Concat', { inputs: { a: a2D, b: b2D } }, der);
        return res.reshape(outShape);
    };
    __decorate([
        decorators_1.operation
    ], Ops, "concat1D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "concat2D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "concat3D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "concat4D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "concat", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./concat_util":95,"./decorators":99}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape1D(x1Shape, x2Shape) {
    util.assert(x1Shape.length === 1 && x2Shape.length === 1, 'x1 and x2 should be 1d array.');
    var outputShape = x1Shape.slice();
    outputShape[0] += x2Shape[0];
    return outputShape;
}
exports.computeOutShape1D = computeOutShape1D;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;
function computeGradientSliceShapes(aShape, bShape) {
    return {
        aBegin: [0, 0],
        aSize: aShape,
        bBegin: [0, aShape[1]],
        bSize: bShape
    };
}
exports.computeGradientSliceShapes = computeGradientSliceShapes;

},{"../util":122}],96:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.conv1d = function (input, filter, bias, stride, pad, dimRoundingMode) {
        var input3D = input;
        var reshapedTo3D = false;
        if (input.rank === 2) {
            reshapedTo3D = true;
            input3D = input.as3D(1, input.shape[0], input.shape[1]);
        }
        util.assert(input3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + input3D.rank + ".");
        util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
            (filter.rank + "."));
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv1d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(input3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + input3D.shape[2] + ") must match  " +
            ("input depth for filter " + filter.shape[1] + "."));
        var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
        var input4D = input3D.as4D(input3D.shape[0], 1, input3D.shape[1], input3D.shape[2]);
        var strides = [1, stride];
        var res = Ops.conv2d(input4D, filter4D, bias, strides, pad, dimRoundingMode);
        if (reshapedTo3D) {
            return res.as2D(res.shape[2], res.shape[3]);
        }
        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
    };
    Ops.conv2d = function (x, filter, bias, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match  " +
            ("input depth for filter " + filter.shape[2] + "."));
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, pad, dimRoundingMode);
        var gradients = function (dy, y) {
            return {
                x: function () { return Ops.conv2dDerInput(x4D.shape, dy, filter, strides, pad); },
                filter: function () { return Ops.conv2dDerFilter(x4D, dy, filter.shape, strides, pad); },
                bias: function () { return Ops.conv2dDerBias(dy); }
            };
        };
        var res = environment_1.ENV.engine.executeKernel('Conv2D', { inputs: { x: x4D, filter: filter, bias: bias }, args: { convInfo: convInfo } }, gradients);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {
        util.assert(xShape.length === dy.rank, "Length of inShape " +
            ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
        var xShape4D = xShape;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
            xShape4D = [1, xShape[0], xShape[1], xShape[2]];
        }
        var inDepth = xShape4D[3];
        var outDepth = dy4D.shape[3];
        util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
            (xShape4D.length + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
            ("rank " + dy4D.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
            ("match output depth for filter " + filter.shape[3] + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.executeKernel('Conv2DDerInput', { inputs: { dy: dy4D, filter: filter }, args: { convInfo: convInfo } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.conv2dDerBias = function (dy) {
        var dy4D = dy;
        if (dy.rank === 3) {
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        return environment_1.ENV.engine.executeKernel('Conv2DDerBias', { inputs: { dy: dy4D } });
    };
    Ops.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {
        var x4D = x;
        if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var dy4D = dy;
        if (dy4D.rank === 3) {
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
            (x4D.shape + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
            (dy4D.shape + "."));
        util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
            (filterShape + "."));
        util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " +
            ("match input depth in filter (" + filterShape[2] + "."));
        util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
            ("match output depth for filter (" + filterShape[3] + ")."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, pad, dimRoundingMode);
        return environment_1.ENV.engine.executeKernel('Conv2DDerFilter', { inputs: { x: x4D, dy: dy4D }, args: { convInfo: convInfo } });
    };
    Ops.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {
        return Ops.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode);
    };
    Ops.depthwiseConv2D = function (input, filter, strides, pad, rates, dimRoundingMode) {
        if (rates === void 0) { rates = [1, 1]; }
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
            ("rank " + input4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
            ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        rates = rates || [1, 1];
        var _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
        util.assert(rateHeight === 1 && rateWidth === 1, 'Error in depthwiseConv2D: rates greater than 1 are not yet ' +
            ("supported. Got rates '" + rates + "'"));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in depthwiseConv2D: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(input4D.shape, filter.shape, strides, pad, dimRoundingMode, true);
        var res = environment_1.ENV.engine.executeKernel('DepthwiseConv2D', { inputs: { x: input4D, filter: filter }, args: { convInfo: convInfo } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        decorators_1.operation
    ], Ops, "conv1d", null);
    __decorate([
        decorators_1.operation
    ], Ops, "conv2d", null);
    __decorate([
        decorators_1.operation
    ], Ops, "conv2dDerInput", null);
    __decorate([
        decorators_1.operation
    ], Ops, "conv2dDerBias", null);
    __decorate([
        decorators_1.operation
    ], Ops, "conv2dDerFilter", null);
    __decorate([
        decorators_1.operation
    ], Ops, "conv2dTranspose", null);
    __decorate([
        decorators_1.operation
    ], Ops, "depthwiseConv2D", null);
    return Ops;
}());
exports.Ops = Ops;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}

},{"../environment":10,"../util":122,"./conv_util":97,"./decorators":99}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
    var filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    return computeConv2DInfo(inShape, filterShape, strides, pad, roundingMode, false, dataFormat);
}
exports.computePool2DInfo = computePool2DInfo;
function computeConv2DInfo(inShape, filterShape, strides, pad, roundingMode, depthwise, dataFormat) {
    if (depthwise === void 0) { depthwise = false; }
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
    if (dataFormat === 'channelsLast') {
        batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
    }
    else if (dataFormat === 'channelsFirst') {
        batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
    var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
    var _c = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode), padInfo = _c.padInfo, outHeight = _c.outHeight, outWidth = _c.outWidth;
    var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    var outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
    return [filterHeight, filterWidth, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        padInfo = { top: pad, bottom: pad, left: pad, right: pad };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
function conditionalRound(value, roundingMode) {
    if (!roundingMode) {
        return value;
    }
    switch (roundingMode) {
        case 'round':
            return Math.round(value);
        case 'ceil':
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error("Unknown roundingMode " + roundingMode);
    }
}

},{"../util":122}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var ndarray_1 = require("./ndarray");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = environment_1.ENV.math.keep(ndarray_1.Scalar.new(0.5));
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.multiplyStrict(diff, diff);
        var result = math.multiply(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"../environment":10,"./ndarray":105}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
function operation(target, name, descriptor) {
    var fn = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return environment_1.ENV.math.scope(name, function () { return fn.apply(void 0, args); });
    };
    return descriptor;
}
exports.operation = operation;

},{"../environment":10}],100:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.resizeBilinear = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " +
            (size + "."));
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var res = environment_1.ENV.engine.executeKernel('ResizeBilinear', { inputs: { x: batchImages }, args: { newHeight: newHeight, newWidth: newWidth, alignCorners: alignCorners } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        decorators_1.operation
    ], Ops, "resizeBilinear", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./decorators":99}],101:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var decorators_1 = require("./decorators");
var types = require("./types");
var Ops = (function () {
    function Ops() {
    }
    Ops.logicalAnd = function (a, b) {
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('LogicalAnd', { inputs: { a: a, b: b } });
    };
    Ops.logicalOr = function (a, b) {
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.executeKernel('LogicalOr', { inputs: { a: a, b: b } });
    };
    Ops.where = function (condition, a, b) {
        util.assert(condition.dtype === 'bool' || a.dtype === 'bool' || b.dtype === 'bool', 'Error Array must be of type bool.');
        util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');
        if (condition.rank === 1) {
            util.assert(condition.shape[0] === a.shape[0], 'The first dimension of `a` must match the size of `condition`.');
        }
        else {
            util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');
        }
        var dtype = types.upcastType(a.dtype, b.dtype);
        return environment_1.ENV.engine.executeKernel('Where', { inputs: { condition: condition, a: a, b: b }, args: { dtype: dtype } });
    };
    __decorate([
        decorators_1.operation
    ], Ops, "logicalAnd", null);
    __decorate([
        decorators_1.operation
    ], Ops, "logicalOr", null);
    __decorate([
        decorators_1.operation
    ], Ops, "where", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./broadcast_util":92,"./decorators":99,"./types":119}],102:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.multiRNNCell = function (lstmCells, data, c, h) {
        var input = data;
        var newStates = [];
        for (var i = 0; i < lstmCells.length; i++) {
            var output = lstmCells[i](input, c[i], h[i]);
            newStates.push(output[0]);
            newStates.push(output[1]);
            input = output[1];
        }
        var newC = [];
        var newH = [];
        for (var i = 0; i < newStates.length; i += 2) {
            newC.push(newStates[i]);
            newH.push(newStates[i + 1]);
        }
        return [newC, newH];
    };
    Ops.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var combined = data.concat(h, 1);
        var weighted = combined.matMul(lstmKernel);
        var res = weighted.add(lstmBias);
        var batchSize = res.shape[0];
        var sliceCols = res.shape[1] / 4;
        var sliceSize = [batchSize, sliceCols];
        var i = res.slice([0, 0], sliceSize);
        var j = res.slice([0, sliceCols], sliceSize);
        var f = res.slice([0, sliceCols * 2], sliceSize);
        var o = res.slice([0, sliceCols * 3], sliceSize);
        var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));
        var newH = newC.tanh().mulStrict(o.sigmoid());
        return [newC, newH];
    };
    __decorate([
        decorators_1.operation
    ], Ops, "multiRNNCell", null);
    __decorate([
        decorators_1.operation
    ], Ops, "basicLSTMCell", null);
    return Ops;
}());
exports.Ops = Ops;

},{"./decorators":99}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var array_ops = require("./array_ops");
var backend_engine_1 = require("./backends/backend_engine");
var batchnorm = require("./batchnorm");
var binary_ops = require("./binary_ops");
var compare = require("./compare");
var concat = require("./concat");
var conv = require("./conv");
var image_ops = require("./image_ops");
var logical = require("./logical_ops");
var lstm_ops = require("./lstm");
var matmul = require("./matmul");
var ndarray_1 = require("./ndarray");
var norm = require("./norm");
var ops = require("./ops");
var pool = require("./pool");
var reduction_ops = require("./reduction_ops");
var reverse = require("./reverse");
var slice = require("./slice");
var softmax_ops = require("./softmax");
var transpose = require("./transpose");
var unary_ops = require("./unary_ops");
var NDArrayMath = (function () {
    function NDArrayMath(backend, safeMode) {
        this.registeredArrays = new Map();
        this.customBackend = false;
        this.matMul = matmul.Ops.matMul;
        this.vectorTimesMatrix = matmul.Ops.vectorTimesMatrix;
        this.outerProduct = matmul.Ops.outerProduct;
        this.matrixTimesVector = matmul.Ops.matrixTimesVector;
        this.dotProduct = matmul.Ops.dotProduct;
        this.slice = slice.Ops.slice;
        this.slice1D = slice.Ops.slice1D;
        this.slice2D = slice.Ops.slice2D;
        this.slice3D = slice.Ops.slice3D;
        this.slice4D = slice.Ops.slice4D;
        this.reverse = reverse.Ops.reverse;
        this.reverse1D = reverse.Ops.reverse1D;
        this.reverse2D = reverse.Ops.reverse2D;
        this.reverse3D = reverse.Ops.reverse3D;
        this.reverse4D = reverse.Ops.reverse4D;
        this.concat = concat.Ops.concat;
        this.concat1D = concat.Ops.concat1D;
        this.concat2D = concat.Ops.concat2D;
        this.concat3D = concat.Ops.concat3D;
        this.concat4D = concat.Ops.concat4D;
        this.batchNormalization = batchnorm.Ops.batchNormalization;
        this.batchNormalization2D = batchnorm.Ops.batchNormalization2D;
        this.batchNormalization3D = batchnorm.Ops.batchNormalization3D;
        this.batchNormalization4D = batchnorm.Ops.batchNormalization4D;
        this.avgPool = pool.Ops.avgPool;
        this.maxPool = pool.Ops.maxPool;
        this.minPool = pool.Ops.minPool;
        this.maxPoolBackprop = pool.Ops.maxPoolBackprop;
        this.conv1d = conv.Ops.conv1d;
        this.conv2d = conv.Ops.conv2d;
        this.conv2dTranspose = conv.Ops.conv2dTranspose;
        this.depthwiseConv2D = conv.Ops.depthwiseConv2D;
        this.conv2dDerBias = conv.Ops.conv2dDerBias;
        this.conv2dDerFilter = conv.Ops.conv2dDerFilter;
        this.conv2dDerInput = conv.Ops.conv2dDerInput;
        this.argMax = reduction_ops.Ops.argMax;
        this.argMaxEquals = reduction_ops.Ops.argMaxEquals;
        this.argMin = reduction_ops.Ops.argMin;
        this.logSumExp = reduction_ops.Ops.logSumExp;
        this.max = reduction_ops.Ops.max;
        this.mean = reduction_ops.Ops.mean;
        this.min = reduction_ops.Ops.min;
        this.moments = reduction_ops.Ops.moments;
        this.sum = reduction_ops.Ops.sum;
        this.add = binary_ops.Ops.add;
        this.addStrict = binary_ops.Ops.addStrict;
        this.arrayDividedByScalar = binary_ops.Ops.arrayDividedByScalar;
        this.div = binary_ops.Ops.div;
        this.divide = this.div;
        this.divStrict = binary_ops.Ops.divStrict;
        this.divideStrict = this.divStrict;
        this.elementWiseMul = binary_ops.Ops.elementWiseMul;
        this.maximum = binary_ops.Ops.maximum;
        this.maximumStrict = binary_ops.Ops.maximumStrict;
        this.minimum = binary_ops.Ops.minimum;
        this.minimumStrict = binary_ops.Ops.minimumStrict;
        this.mul = binary_ops.Ops.mul;
        this.multiply = this.mul;
        this.mulStrict = binary_ops.Ops.mulStrict;
        this.multiplyStrict = this.mulStrict;
        this.pow = binary_ops.Ops.pow;
        this.powStrict = binary_ops.Ops.powStrict;
        this.scalarDividedByArray = binary_ops.Ops.scalarDividedByArray;
        this.sub = binary_ops.Ops.sub;
        this.subtract = this.sub;
        this.subStrict = binary_ops.Ops.subStrict;
        this.logicalAnd = logical.Ops.logicalAnd;
        this.logicalOr = logical.Ops.logicalOr;
        this.where = logical.Ops.where;
        this.transpose = transpose.Ops.transpose;
        this.equal = compare.Ops.equal;
        this.equalStrict = compare.Ops.equalStrict;
        this.greater = compare.Ops.greater;
        this.greaterStrict = compare.Ops.greaterStrict;
        this.greaterEqual = compare.Ops.greaterEqual;
        this.greaterEqualStrict = compare.Ops.greaterEqualStrict;
        this.less = compare.Ops.less;
        this.lessStrict = compare.Ops.lessStrict;
        this.lessEqual = compare.Ops.lessEqual;
        this.lessEqualStrict = compare.Ops.lessEqualStrict;
        this.notEqual = compare.Ops.notEqual;
        this.notEqualStrict = compare.Ops.notEqualStrict;
        this.abs = unary_ops.Ops.abs;
        this.acos = unary_ops.Ops.acos;
        this.asin = unary_ops.Ops.asin;
        this.atan = unary_ops.Ops.atan;
        this.ceil = unary_ops.Ops.ceil;
        this.clip = unary_ops.Ops.clip;
        this.cos = unary_ops.Ops.cos;
        this.cosh = unary_ops.Ops.cosh;
        this.elu = unary_ops.Ops.elu;
        this.exp = unary_ops.Ops.exp;
        this.floor = unary_ops.Ops.floor;
        this.leakyRelu = unary_ops.Ops.leakyRelu;
        this.log = unary_ops.Ops.log;
        this.neg = unary_ops.Ops.neg;
        this.prelu = unary_ops.Ops.prelu;
        this.relu = unary_ops.Ops.relu;
        this.selu = unary_ops.Ops.selu;
        this.sigmoid = unary_ops.Ops.sigmoid;
        this.sin = unary_ops.Ops.sin;
        this.sinh = unary_ops.Ops.sinh;
        this.sqrt = unary_ops.Ops.sqrt;
        this.square = unary_ops.Ops.square;
        this.step = unary_ops.Ops.step;
        this.tan = unary_ops.Ops.tan;
        this.tanh = unary_ops.Ops.tanh;
        this.norm = norm.Ops.norm;
        this.basicLSTMCell = lstm_ops.Ops.basicLSTMCell;
        this.multiRNNCell = lstm_ops.Ops.multiRNNCell;
        this.softmax = softmax_ops.Ops.softmax;
        this.softmaxCrossEntropy = softmax_ops.Ops.softmaxCrossEntropy;
        this.cast = array_ops.Ops.cast;
        this.clone = array_ops.Ops.clone;
        this.gather = array_ops.Ops.gather;
        this.reshape = array_ops.Ops.reshape;
        this.tile = array_ops.Ops.tile;
        this.oneHot = array_ops.Ops.oneHot;
        this.multinomial = array_ops.Ops.multinomial;
        this.pad1D = array_ops.Ops.pad1D;
        this.pad2D = array_ops.Ops.pad2D;
        this.resizeBilinear3D = image_ops.Ops.resizeBilinear;
        this.registeredVariables = {};
        if (typeof backend === 'string') {
            this.backend = environment_1.ENV.getBackend(backend);
        }
        else {
            this.customBackend = true;
            this.backend = backend;
        }
        this.engine = new backend_engine_1.BackendEngine(this.backend, safeMode);
        environment_1.ENV.setMath(this);
    }
    NDArrayMath.prototype.time = function (query) {
        return this.backend.time(query);
    };
    NDArrayMath.prototype.getNumArrays = function () {
        return this.registeredArrays.size;
    };
    NDArrayMath.prototype.register = function (a) {
        var refCount = this.registeredArrays.has(a.dataId) ?
            this.registeredArrays.get(a.dataId) :
            0;
        if (refCount === 0) {
            this.backend.register(a.dataId, a.shape, a.dtype);
        }
        this.registeredArrays.set(a.dataId, refCount + 1);
        if (!(a instanceof ndarray_1.Variable)) {
            this.engine.track(a);
        }
    };
    NDArrayMath.prototype.registerVariable = function (v) {
        if (this.registeredVariables[v.name] != null) {
            throw new Error("Variable with name " + v.name + " was already registered");
        }
        this.registeredVariables[v.name] = v;
    };
    NDArrayMath.prototype.fromPixels = function (pixels, numChannels) {
        return this.backend.fromPixels(pixels, numChannels);
    };
    NDArrayMath.prototype.write = function (dataId, values) {
        this.backend.write(dataId, values);
    };
    NDArrayMath.prototype.readSync = function (dataId) {
        return this.backend.readSync(dataId);
    };
    NDArrayMath.prototype.read = function (dataId) {
        return this.backend.read(dataId);
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.engine.enableDebugMode();
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.scope = function (nameOrScopeFn, scopeFn, gradientsMode) {
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (scopeFn == null) {
            if (typeof nameOrScopeFn !== 'function') {
                throw new Error('Please provide a function to math.scope()');
            }
            scopeFn = nameOrScopeFn;
            nameOrScopeFn = 'scope';
        }
        else {
            if (typeof nameOrScopeFn !== 'string' &&
                !(nameOrScopeFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to math.scope() must be a string');
            }
            if (typeof scopeFn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to math.scope() must be a function');
            }
        }
        return this.engine.scope(nameOrScopeFn, scopeFn, gradientsMode);
    };
    NDArrayMath.prototype.gradientsScope = function (nameOrScopeFn, scopeFn) {
        var gradientsMode = true;
        return this.scope(nameOrScopeFn, scopeFn, gradientsMode);
    };
    NDArrayMath.prototype.startScope = function () {
        var gradientsMode = false;
        this.engine.startScope(gradientsMode);
    };
    NDArrayMath.prototype.endScope = function (result) {
        var gradientsMode = false;
        this.engine.endScope(result, gradientsMode);
    };
    NDArrayMath.prototype.keep = function (result) {
        return this.engine.keep(result);
    };
    NDArrayMath.prototype.track = function (result) {
        return result;
    };
    NDArrayMath.prototype.dispose = function () {
        if (this.customBackend) {
            this.backend.dispose();
        }
    };
    NDArrayMath.prototype.topK = function (x, k) {
        var _this = this;
        util.assert(k <= x.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + x.shape + "."));
        var values;
        var indices;
        this.scope('topK', function () {
            values =
                _this.engine.executeKernel('TopKValues', { inputs: { x: x }, args: { k: k } });
            indices =
                _this.engine.executeKernel('TopKIndices', { inputs: { x: x }, args: { k: k } });
            return values;
        });
        var result = { values: values, indices: indices };
        return result;
    };
    NDArrayMath.prototype.switchDim = function (x, perm) {
        return ops.transpose(x, perm);
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.subtract(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.subtract(a, c);
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var _this = this;
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.scope('scaledArrayAdd', function () {
            return _this.add(_this.multiply(c1, a), _this.multiply(c2, b));
        });
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.localResponseNormalization3D = function (x, radius, bias, alpha, beta, normRegion) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        if (normRegion === void 0) { normRegion = 'acrossChannels'; }
        util.assert(x.rank === 3, "Error in localResponseNormalization3D: x must be rank 3 but got\n         rank " + x.rank + ".");
        util.assert(util.isInt(radius), "Error in localResponseNormalization3D: radius must be an integer\n         but got radius " + radius + ".");
        var input4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        var res = this.localResponseNormalization4D(input4D, radius, bias, alpha, beta, normRegion);
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    };
    NDArrayMath.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta, normRegion) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        if (normRegion === void 0) { normRegion = 'acrossChannels'; }
        util.assert(x.rank === 4, "Error in localResponseNormalization4D: x must be rank 4 but got\n         rank " + x.rank + ".");
        util.assert(util.isInt(radius), "Error in localResponseNormalization3D: radius must be an integer\n         but got radius " + radius + ".");
        return this.engine.executeKernel('LRN4D', { inputs: { x: x }, args: { radius: radius, bias: bias, alpha: alpha, beta: beta, normRegion: normRegion } });
    };
    NDArrayMath.prototype.vjp = function (f, x, dy) {
        var keys = x instanceof ndarray_1.NDArray ? null : Object.keys(x);
        var xs = util.flattenNameArrayMap(x, keys);
        var vjp = this.engine.vjp(f, xs, dy);
        if (x instanceof ndarray_1.NDArray) {
            return vjp[0];
        }
        else {
            return util.unflattenToNameArrayMap(keys, vjp);
        }
    };
    NDArrayMath.prototype.gradients = function (f, x) {
        var keys = x instanceof ndarray_1.NDArray ? null : Object.keys(x);
        var xs = util.flattenNameArrayMap(x, keys);
        var returnValue = false;
        var gradients = this.engine.gradients(f, xs, returnValue);
        if (x instanceof ndarray_1.NDArray) {
            return gradients[0];
        }
        else {
            return util.unflattenToNameArrayMap(keys, gradients);
        }
    };
    NDArrayMath.prototype.variableGradients = function (f, varList) {
        if (varList == null) {
            varList = [];
            var varNames = Object.keys(this.registeredVariables);
            for (var i = 0; i < varNames.length; i++) {
                var variable = this.registeredVariables[varNames[i]];
                if (variable.trainable) {
                    varList.push(variable);
                }
            }
        }
        else {
            varList = varList.filter(function (variable) { return variable.trainable; });
        }
        return this.engine.variableGradientsAndValue(f, varList);
    };
    NDArrayMath.prototype.valueAndGradients = function (f, x) {
        var keys = x instanceof ndarray_1.NDArray ? null : Object.keys(x);
        var xs = util.flattenNameArrayMap(x, keys);
        var returnValue = true;
        var valueAndGradients = this.engine.gradients(f, xs, returnValue);
        var gradients;
        if (x instanceof ndarray_1.NDArray) {
            gradients = valueAndGradients.gradients[0];
        }
        else {
            gradients =
                util.unflattenToNameArrayMap(keys, valueAndGradients.gradients);
        }
        return { value: valueAndGradients.value, gradients: gradients };
    };
    NDArrayMath.prototype.customGradient = function (name, f, inputs) {
        return this.engine.customGradient(f, inputs, name == null ? '' : name);
    };
    NDArrayMath.prototype.disposeData = function (dataId) {
        if (!this.registeredArrays.has(dataId)) {
            return;
        }
        var refCount = this.registeredArrays.get(dataId);
        if (refCount <= 1) {
            this.registeredArrays.delete(dataId);
            this.backend.disposeData(dataId);
        }
        else {
            this.registeredArrays.set(dataId, refCount - 1);
        }
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;

},{"../environment":10,"../util":122,"./array_ops":47,"./backends/backend_engine":50,"./batchnorm":90,"./binary_ops":91,"./compare":93,"./concat":94,"./conv":96,"./image_ops":100,"./logical_ops":101,"./lstm":102,"./matmul":104,"./ndarray":105,"./norm":106,"./ops":107,"./pool":110,"./reduction_ops":113,"./reverse":114,"./slice":115,"./softmax":117,"./transpose":118,"./unary_ops":120}],104:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var matmul_1 = require("./backends/types/matmul");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.matMul = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = matmul_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = matmul_1.MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + matmul_1.MatrixOrientation[aOrientation]) +
            (" and " + matmul_1.MatrixOrientation[bOrientation] + " must match."));
        return environment_1.ENV.engine.executeKernel('MatMul', { inputs: { a: a, b: b }, args: { aOrientation: aOrientation, bOrientation: bOrientation } }, function (dy, y) {
            if (aOrientation === matmul_1.MatrixOrientation.TRANSPOSED ||
                bOrientation === matmul_1.MatrixOrientation.TRANSPOSED) {
                throw new Error("Backprop for transposed MatMul not yet implemented.");
            }
            return {
                a: function () { return dy.matMul(b.toFloat(), matmul_1.MatrixOrientation.REGULAR, matmul_1.MatrixOrientation.TRANSPOSED); },
                b: function () { return a.toFloat().matMul(dy, matmul_1.MatrixOrientation.TRANSPOSED, matmul_1.MatrixOrientation.REGULAR); }
            };
        });
    };
    Ops.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return v.as2D(1, -1).matMul(matrix).as1D();
    };
    Ops.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return matrix.matMul(v.as2D(-1, 1)).as1D();
    };
    Ops.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar();
    };
    Ops.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return v1.as2D(-1, 1).matMul(v2.as2D(1, -1));
    };
    __decorate([
        decorators_1.operation
    ], Ops, "matMul", null);
    __decorate([
        decorators_1.operation
    ], Ops, "vectorTimesMatrix", null);
    __decorate([
        decorators_1.operation
    ], Ops, "matrixTimesVector", null);
    __decorate([
        decorators_1.operation
    ], Ops, "dotProduct", null);
    __decorate([
        decorators_1.operation
    ], Ops, "outerProduct", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./backends/types/matmul":54,"./decorators":99}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var matmul_1 = require("./backends/types/matmul");
var ops = require("./ops");
var NDArray = (function () {
    function NDArray(shape, dtype, values, dataId) {
        this.isDisposed = false;
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            util.assert(this.size === values.length, "Constructing ndarray of shape (" + this.size + ") should match the " +
                ("length of values (" + values.length + ")"));
        }
        this.shape = shape;
        this.dtype = dtype || 'float32';
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
        this.dataId = dataId != null ? dataId : NDArray.nextDataId++;
        this.id = NDArray.nextId++;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
        environment_1.ENV.math.register(this);
        if (values != null) {
            environment_1.ENV.math.write(this.dataId, values);
        }
    }
    NDArray.ones = function (shape, dtype) {
        return ops.ones(shape, dtype);
    };
    NDArray.zeros = function (shape, dtype) {
        return ops.zeros(shape, dtype);
    };
    NDArray.onesLike = function (x) {
        return ops.onesLike(x);
    };
    NDArray.zerosLike = function (x) {
        return ops.zerosLike(x);
    };
    NDArray.like = function (x) {
        return ops.clone(x);
    };
    NDArray.make = function (shape, data, dtype) {
        return new NDArray(shape, dtype, data.values, data.dataId);
    };
    NDArray.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        return ops.fromPixels(pixels, numChannels);
    };
    NDArray.rand = function (shape, randFunction, dtype) {
        return ops.rand(shape, randFunction, dtype);
    };
    NDArray.randNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return ops.randNormal(shape, mean, stdDev, dtype, seed);
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return ops.truncatedNormal(shape, mean, stdDev, dtype, seed);
    };
    NDArray.randUniform = function (shape, a, b, dtype) {
        return ops.randUniform(shape, a, b, dtype);
    };
    NDArray.prototype.squeeze = function (axis) {
        this.throwIfDisposed();
        return this.reshape(util.squeezeShape(this.shape, axis).newShape);
    };
    NDArray.prototype.flatten = function () {
        this.throwIfDisposed();
        return this.as1D();
    };
    NDArray.prototype.asScalar = function () {
        this.throwIfDisposed();
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        this.throwIfDisposed();
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        this.throwIfDisposed();
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth, depth2]);
    };
    NDArray.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        this.throwIfDisposed();
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.dataSync()[index];
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        this.throwIfDisposed();
        util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
            ("match the rank (" + this.rank + ")"));
        var index = locs.length > 0 ? locs[locs.length - 1] : 0;
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        var vals = this.dataSync();
        vals[index] = value;
        environment_1.ENV.math.write(this.dataId, vals);
    };
    NDArray.prototype.val = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (locs.length === 0) {
                            locs = [0];
                        }
                        this.throwIfDisposed();
                        return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get.apply(this, locs)];
                }
            });
        });
    };
    NDArray.prototype.locToIndex = function (locs) {
        this.throwIfDisposed();
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        this.throwIfDisposed();
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.throwIfDisposed();
        var vals = this.dataSync();
        vals.fill(value);
        environment_1.ENV.math.write(this.dataId, vals);
    };
    NDArray.prototype.getValues = function () {
        return this.dataSync();
    };
    NDArray.prototype.getValuesAsync = function () {
        return this.data();
    };
    NDArray.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfDisposed();
                return [2, environment_1.ENV.math.read(this.dataId)];
            });
        });
    };
    NDArray.prototype.dataSync = function () {
        this.throwIfDisposed();
        return environment_1.ENV.math.readSync(this.dataId);
    };
    NDArray.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        environment_1.ENV.math.disposeData(this.dataId);
    };
    NDArray.prototype.throwIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("NDArray is disposed.");
        }
    };
    NDArray.prototype.toFloat = function () {
        return this.asType('float32');
    };
    NDArray.prototype.toInt = function () {
        return this.asType('int32');
    };
    NDArray.prototype.toBool = function () {
        return this.asType('bool');
    };
    NDArray.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        return ops.reshape(this, newShape);
    };
    NDArray.prototype.reshapeAs = function (x) {
        this.throwIfDisposed();
        return this.reshape(x.shape);
    };
    NDArray.prototype.tile = function (reps) {
        this.throwIfDisposed();
        return ops.tile(this, reps);
    };
    NDArray.prototype.gather = function (indices, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.gather(this, indices);
    };
    NDArray.prototype.matMul = function (b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = matmul_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = matmul_1.MatrixOrientation.REGULAR; }
        this.throwIfDisposed();
        return ops.matMul(this, b, aOrientation, bOrientation);
    };
    NDArray.prototype.slice = function (begin, size) {
        this.throwIfDisposed();
        return ops.slice(this, begin, size);
    };
    NDArray.prototype.reverse = function (axis) {
        this.throwIfDisposed();
        return ops.reverse(this, axis);
    };
    NDArray.prototype.concat = function (x, axis) {
        this.throwIfDisposed();
        return ops.concat(this, x, axis);
    };
    NDArray.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        this.throwIfDisposed();
        return ops.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset);
    };
    NDArray.prototype.clone = function () {
        this.throwIfDisposed();
        return ops.clone(this);
    };
    NDArray.prototype.logSumExp = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.logSumExp(this, axis, keepDims);
    };
    NDArray.prototype.sum = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.sum(this, axis, keepDims);
    };
    NDArray.prototype.mean = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.mean(this, axis, keepDims);
    };
    NDArray.prototype.min = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.min(this, axis, keepDims);
    };
    NDArray.prototype.max = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.max(this, axis, keepDims);
    };
    NDArray.prototype.argMin = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMin(this, axis);
    };
    NDArray.prototype.argMax = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMax(this, axis);
    };
    NDArray.prototype.argMaxEquals = function (x) {
        this.throwIfDisposed();
        return ops.argMaxEquals(this, x);
    };
    NDArray.prototype.add = function (x) {
        this.throwIfDisposed();
        return ops.add(this, x);
    };
    NDArray.prototype.addStrict = function (x) {
        this.throwIfDisposed();
        return ops.addStrict(this, x);
    };
    NDArray.prototype.sub = function (x) {
        this.throwIfDisposed();
        return ops.sub(this, x);
    };
    NDArray.prototype.subStrict = function (x) {
        this.throwIfDisposed();
        return ops.subStrict(this, x);
    };
    NDArray.prototype.pow = function (exp) {
        this.throwIfDisposed();
        return ops.pow(this, exp);
    };
    NDArray.prototype.powStrict = function (exp) {
        this.throwIfDisposed();
        return ops.powStrict(this, exp);
    };
    NDArray.prototype.mul = function (x) {
        this.throwIfDisposed();
        return ops.mul(this, x);
    };
    NDArray.prototype.mulStrict = function (x) {
        this.throwIfDisposed();
        return ops.mulStrict(this, x);
    };
    NDArray.prototype.div = function (x) {
        this.throwIfDisposed();
        return ops.div(this, x);
    };
    NDArray.prototype.divStrict = function (x) {
        this.throwIfDisposed();
        return ops.divStrict(this, x);
    };
    NDArray.prototype.minimum = function (x) {
        this.throwIfDisposed();
        return ops.minimum(this, x);
    };
    NDArray.prototype.minimumStrict = function (x) {
        this.throwIfDisposed();
        return ops.minimumStrict(this, x);
    };
    NDArray.prototype.maximum = function (x) {
        this.throwIfDisposed();
        return ops.maximum(this, x);
    };
    NDArray.prototype.maximumStrict = function (x) {
        this.throwIfDisposed();
        return ops.maximumStrict(this, x);
    };
    NDArray.prototype.transpose = function (perm) {
        this.throwIfDisposed();
        return ops.transpose(this, perm);
    };
    NDArray.prototype.notEqual = function (x) {
        this.throwIfDisposed();
        return ops.notEqual(this, x);
    };
    NDArray.prototype.notEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.notEqualStrict(this, x);
    };
    NDArray.prototype.less = function (x) {
        this.throwIfDisposed();
        return ops.less(this, x);
    };
    NDArray.prototype.lessStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessStrict(this, x);
    };
    NDArray.prototype.equal = function (x) {
        this.throwIfDisposed();
        return ops.equal(this, x);
    };
    NDArray.prototype.equalStrict = function (x) {
        this.throwIfDisposed();
        return ops.equalStrict(this, x);
    };
    NDArray.prototype.lessEqual = function (x) {
        this.throwIfDisposed();
        return ops.lessEqual(this, x);
    };
    NDArray.prototype.lessEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessEqualStrict(this, x);
    };
    NDArray.prototype.greater = function (x) {
        this.throwIfDisposed();
        return ops.greater(this, x);
    };
    NDArray.prototype.greaterStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterStrict(this, x);
    };
    NDArray.prototype.greaterEqual = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqual(this, x);
    };
    NDArray.prototype.greaterEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqualStrict(this, x);
    };
    NDArray.prototype.logicalAnd = function (x) {
        this.throwIfDisposed();
        return ops.logicalAnd(this, x);
    };
    NDArray.prototype.logicalOr = function (x) {
        this.throwIfDisposed();
        return ops.logicalOr(this, x);
    };
    NDArray.prototype.where = function (condition, x) {
        this.throwIfDisposed();
        return ops.where(condition, this, x);
    };
    NDArray.prototype.neg = function () {
        this.throwIfDisposed();
        return ops.neg(this);
    };
    NDArray.prototype.ceil = function () {
        this.throwIfDisposed();
        return ops.ceil(this);
    };
    NDArray.prototype.floor = function () {
        this.throwIfDisposed();
        return ops.floor(this);
    };
    NDArray.prototype.exp = function () {
        this.throwIfDisposed();
        return ops.exp(this);
    };
    NDArray.prototype.log = function () {
        this.throwIfDisposed();
        return ops.log(this);
    };
    NDArray.prototype.sqrt = function () {
        this.throwIfDisposed();
        return ops.sqrt(this);
    };
    NDArray.prototype.square = function () {
        this.throwIfDisposed();
        return ops.square(this);
    };
    NDArray.prototype.abs = function () {
        this.throwIfDisposed();
        return ops.abs(this);
    };
    NDArray.prototype.clip = function (min, max) {
        this.throwIfDisposed();
        return ops.clip(this, min, max);
    };
    NDArray.prototype.relu = function () {
        this.throwIfDisposed();
        return ops.relu(this);
    };
    NDArray.prototype.elu = function () {
        this.throwIfDisposed();
        return ops.elu(this);
    };
    NDArray.prototype.selu = function () {
        this.throwIfDisposed();
        return ops.selu(this);
    };
    NDArray.prototype.leakyRelu = function (alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        this.throwIfDisposed();
        return ops.leakyRelu(this, alpha);
    };
    NDArray.prototype.prelu = function (alpha) {
        this.throwIfDisposed();
        return ops.prelu(this, alpha);
    };
    NDArray.prototype.sigmoid = function () {
        this.throwIfDisposed();
        return ops.sigmoid(this);
    };
    NDArray.prototype.sin = function () {
        this.throwIfDisposed();
        return ops.sin(this);
    };
    NDArray.prototype.cos = function () {
        this.throwIfDisposed();
        return ops.cos(this);
    };
    NDArray.prototype.tan = function () {
        this.throwIfDisposed();
        return ops.tan(this);
    };
    NDArray.prototype.asin = function () {
        this.throwIfDisposed();
        return ops.asin(this);
    };
    NDArray.prototype.acos = function () {
        this.throwIfDisposed();
        return ops.acos(this);
    };
    NDArray.prototype.atan = function () {
        this.throwIfDisposed();
        return ops.atan(this);
    };
    NDArray.prototype.sinh = function () {
        this.throwIfDisposed();
        return ops.sinh(this);
    };
    NDArray.prototype.cosh = function () {
        this.throwIfDisposed();
        return ops.cosh(this);
    };
    NDArray.prototype.tanh = function () {
        this.throwIfDisposed();
        return ops.tanh(this);
    };
    NDArray.prototype.step = function (alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        this.throwIfDisposed();
        return ops.step(this, alpha);
    };
    NDArray.prototype.softmax = function (dim) {
        if (dim === void 0) { dim = -1; }
        this.throwIfDisposed();
        return ops.softmax(this, dim);
    };
    NDArray.prototype.resizeBilinear = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeBilinear(this, newShape2D, alignCorners);
    };
    NDArray.prototype.conv1d = function (filter, bias, stride, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv1d(this, filter, bias, stride, pad, dimRoundingMode);
    };
    NDArray.prototype.conv2d = function (filter, bias, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2d(this, filter, bias, strides, pad, dimRoundingMode);
    };
    NDArray.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
    };
    NDArray.prototype.depthwiseConv2D = function (filter, strides, pad, rates, dimRoundingMode) {
        if (rates === void 0) { rates = [1, 1]; }
        this.throwIfDisposed();
        return ops.depthwiseConv2D(this, filter, strides, pad, rates, dimRoundingMode);
    };
    NDArray.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.avgPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    NDArray.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.maxPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    NDArray.prototype.minPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.minPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    NDArray.nextId = 0;
    NDArray.nextDataId = 0;
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Scalar.new = function (value, dtype) {
        var values = [value];
        return new Scalar([], dtype, toTypedArray(values, dtype));
    };
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Array1D.new = function (values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D([values.length], dtype, toTypedArray(values, dtype));
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Array2D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, dtype, toTypedArray(values, dtype));
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Array3D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, dtype, toTypedArray(values, dtype));
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Array4D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, dtype, toTypedArray(values, dtype));
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(initialValue, trainable, name) {
        if (trainable === void 0) { trainable = true; }
        var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
        _this.trainable = trainable;
        initialValue.dispose();
        _this.name = name;
        if (_this.name == null) {
            _this.name = Variable.nextVarId.toString();
            Variable.nextVarId++;
        }
        environment_1.ENV.math.registerVariable(_this);
        return _this;
    }
    Variable.variable = function (initialValue, trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.asType(dtype);
        }
        return new Variable(initialValue, trainable, name);
    };
    Variable.prototype.assign = function (newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                ("previous value (" + this.dtype + ") must match"));
        }
        if (!util.arraysEqual(newValue.shape, this.shape)) {
            throw new Error("shape of the new value (" + newValue.shape + ") and " +
                ("previous value (" + this.shape + ") must match"));
        }
        environment_1.ENV.math.disposeData(this.dataId);
        this.dataId = newValue.dataId;
        environment_1.ENV.math.register(this);
        newValue.dispose();
    };
    Variable.nextVarId = 0;
    return Variable;
}(NDArray));
exports.Variable = Variable;
var variable = Variable.variable;
exports.variable = variable;
function instanceofTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return util.copyTypedArray(a, dtype);
}

},{"../environment":10,"../util":122,"./backends/types/matmul":54,"./ops":107}],106:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var axis_util = require("./axis_util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var Ops = (function () {
    function Ops() {
    }
    Ops.norm = function (x, ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var norm = normInternal(x, ord, axis);
        var keepDimsShape = norm.shape;
        if (keepDims) {
            var axes = axis_util.parseAxisParam(axis, x.shape);
            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
        }
        return norm.reshape(keepDimsShape);
    };
    __decorate([
        decorators_1.operation
    ], Ops, "norm", null);
    return Ops;
}());
exports.Ops = Ops;
function normInternal(x, p, axis) {
    if (axis === void 0) { axis = null; }
    if (x.rank === 0) {
        return x.abs();
    }
    if (x.rank !== 1 && axis === null) {
        return normInternal(x.reshape([-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === 'number' ||
        axis instanceof Array && axis.length === 1) {
        if (p === 1) {
            return x.abs().sum(axis);
        }
        if (p === Infinity) {
            return x.abs().max(axis);
        }
        if (p === -Infinity) {
            return x.abs().min(axis);
        }
        if (p === 'euclidean' || p === 2) {
            return x.abs().pow(ndarray_1.Scalar.new(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    if (axis instanceof Array && axis.length === 2) {
        if (p === 1) {
            return x.abs().sum(axis[0]).max(axis[1] - 1);
        }
        if (p === Infinity) {
            return x.abs().sum(axis[1]).max(axis[0]);
        }
        if (p === -Infinity) {
            return x.abs().sum(axis[1]).min(axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            return x.pow(ndarray_1.Scalar.new(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    throw new Error("Error in norm: invalid axis: " + axis);
}

},{"./axis_util":48,"./decorators":99,"./ndarray":105}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops = require("./array_ops");
var batchnorm_ops = require("./batchnorm");
var binary_ops = require("./binary_ops");
var compare_ops = require("./compare");
var concat_ops = require("./concat");
var conv_ops = require("./conv");
var image_ops = require("./image_ops");
var logical_ops = require("./logical_ops");
var lstm_ops = require("./lstm");
var matmul_ops = require("./matmul");
var norm_ops = require("./norm");
var pool_ops = require("./pool");
var reduction_ops = require("./reduction_ops");
var reverse_ops = require("./reverse");
var slice_ops = require("./slice");
var softmax_ops = require("./softmax");
var transpose_ops = require("./transpose");
var unary_ops = require("./unary_ops");
exports.batchNormalization = batchnorm_ops.Ops.batchNormalization;
exports.batchNormalization2D = batchnorm_ops.Ops.batchNormalization2D;
exports.batchNormalization3D = batchnorm_ops.Ops.batchNormalization3D;
exports.batchNormalization4D = batchnorm_ops.Ops.batchNormalization4D;
exports.concat = concat_ops.Ops.concat;
exports.concat1D = concat_ops.Ops.concat1D;
exports.concat2D = concat_ops.Ops.concat2D;
exports.concat3D = concat_ops.Ops.concat3D;
exports.concat4D = concat_ops.Ops.concat4D;
exports.conv1d = conv_ops.Ops.conv1d;
exports.conv2d = conv_ops.Ops.conv2d;
exports.conv2dTranspose = conv_ops.Ops.conv2dTranspose;
exports.depthwiseConv2D = conv_ops.Ops.depthwiseConv2D;
exports.dotProduct = matmul_ops.Ops.dotProduct;
exports.matMul = matmul_ops.Ops.matMul;
exports.matrixTimesVector = matmul_ops.Ops.matrixTimesVector;
exports.outerProduct = matmul_ops.Ops.outerProduct;
exports.vectorTimesMatrix = matmul_ops.Ops.vectorTimesMatrix;
exports.avgPool = pool_ops.Ops.avgPool;
exports.maxPool = pool_ops.Ops.maxPool;
exports.minPool = pool_ops.Ops.minPool;
exports.transpose = transpose_ops.Ops.transpose;
exports.reverse = reverse_ops.Ops.reverse;
exports.reverse1D = reverse_ops.Ops.reverse1D;
exports.reverse2D = reverse_ops.Ops.reverse2D;
exports.reverse3D = reverse_ops.Ops.reverse3D;
exports.reverse4D = reverse_ops.Ops.reverse4D;
exports.slice = slice_ops.Ops.slice;
exports.slice1D = slice_ops.Ops.slice1D;
exports.slice2D = slice_ops.Ops.slice2D;
exports.slice3D = slice_ops.Ops.slice3D;
exports.slice4D = slice_ops.Ops.slice4D;
exports.argMax = reduction_ops.Ops.argMax;
exports.argMaxEquals = reduction_ops.Ops.argMaxEquals;
exports.argMin = reduction_ops.Ops.argMin;
exports.logSumExp = reduction_ops.Ops.logSumExp;
exports.max = reduction_ops.Ops.max;
exports.mean = reduction_ops.Ops.mean;
exports.min = reduction_ops.Ops.min;
exports.moments = reduction_ops.Ops.moments;
exports.sum = reduction_ops.Ops.sum;
exports.equal = compare_ops.Ops.equal;
exports.equalStrict = compare_ops.Ops.equalStrict;
exports.greater = compare_ops.Ops.greater;
exports.greaterStrict = compare_ops.Ops.greaterStrict;
exports.greaterEqual = compare_ops.Ops.greaterEqual;
exports.greaterEqualStrict = compare_ops.Ops.greaterEqualStrict;
exports.less = compare_ops.Ops.less;
exports.lessStrict = compare_ops.Ops.lessStrict;
exports.lessEqual = compare_ops.Ops.lessEqual;
exports.lessEqualStrict = compare_ops.Ops.lessEqualStrict;
exports.notEqual = compare_ops.Ops.notEqual;
exports.notEqualStrict = compare_ops.Ops.notEqualStrict;
exports.logicalAnd = logical_ops.Ops.logicalAnd;
exports.logicalOr = logical_ops.Ops.logicalOr;
exports.where = logical_ops.Ops.where;
exports.abs = unary_ops.Ops.abs;
exports.acos = unary_ops.Ops.acos;
exports.asin = unary_ops.Ops.asin;
exports.atan = unary_ops.Ops.atan;
exports.ceil = unary_ops.Ops.ceil;
exports.clip = unary_ops.Ops.clip;
exports.cos = unary_ops.Ops.cos;
exports.cosh = unary_ops.Ops.cosh;
exports.elu = unary_ops.Ops.elu;
exports.exp = unary_ops.Ops.exp;
exports.floor = unary_ops.Ops.floor;
exports.leakyRelu = unary_ops.Ops.leakyRelu;
exports.log = unary_ops.Ops.log;
exports.neg = unary_ops.Ops.neg;
exports.prelu = unary_ops.Ops.prelu;
exports.relu = unary_ops.Ops.relu;
exports.selu = unary_ops.Ops.selu;
exports.sigmoid = unary_ops.Ops.sigmoid;
exports.sin = unary_ops.Ops.sin;
exports.sinh = unary_ops.Ops.sinh;
exports.sqrt = unary_ops.Ops.sqrt;
exports.square = unary_ops.Ops.square;
exports.step = unary_ops.Ops.step;
exports.tan = unary_ops.Ops.tan;
exports.tanh = unary_ops.Ops.tanh;
exports.add = binary_ops.Ops.add;
exports.addStrict = binary_ops.Ops.addStrict;
exports.div = binary_ops.Ops.div;
exports.divStrict = binary_ops.Ops.divStrict;
exports.maximum = binary_ops.Ops.maximum;
exports.maximumStrict = binary_ops.Ops.maximumStrict;
exports.minimum = binary_ops.Ops.minimum;
exports.minimumStrict = binary_ops.Ops.minimumStrict;
exports.mul = binary_ops.Ops.mul;
exports.mulStrict = binary_ops.Ops.mulStrict;
exports.pow = binary_ops.Ops.pow;
exports.powStrict = binary_ops.Ops.powStrict;
exports.sub = binary_ops.Ops.sub;
exports.subStrict = binary_ops.Ops.subStrict;
exports.norm = norm_ops.Ops.norm;
exports.cast = array_ops.Ops.cast;
exports.clone = array_ops.Ops.clone;
exports.fromPixels = array_ops.Ops.fromPixels;
exports.ones = array_ops.Ops.ones;
exports.onesLike = array_ops.Ops.onesLike;
exports.zeros = array_ops.Ops.zeros;
exports.zerosLike = array_ops.Ops.zerosLike;
exports.rand = array_ops.Ops.rand;
exports.randNormal = array_ops.Ops.randNormal;
exports.truncatedNormal = array_ops.Ops.truncatedNormal;
exports.randUniform = array_ops.Ops.randUniform;
exports.reshape = array_ops.Ops.reshape;
exports.tile = array_ops.Ops.tile;
exports.gather = array_ops.Ops.gather;
exports.multinomial = array_ops.Ops.multinomial;
exports.oneHot = array_ops.Ops.oneHot;
exports.pad1D = array_ops.Ops.pad1D;
exports.pad2D = array_ops.Ops.pad2D;
exports.basicLSTMCell = lstm_ops.Ops.basicLSTMCell;
exports.multiRNNCell = lstm_ops.Ops.multiRNNCell;
exports.softmax = softmax_ops.Ops.softmax;
var ndarray_1 = require("./ndarray");
var types_1 = require("./types");
[ndarray_1.NDArray, types_1.Rank, ndarray_1.Array3D, ndarray_1.Array4D];
exports.losses = {
    softmaxCrossEntropy: softmax_ops.Ops.softmaxCrossEntropy
};
exports.image = {
    resizeBilinear: image_ops.Ops.resizeBilinear
};

},{"./array_ops":47,"./batchnorm":90,"./binary_ops":91,"./compare":93,"./concat":94,"./conv":96,"./image_ops":100,"./logical_ops":101,"./lstm":102,"./matmul":104,"./ndarray":105,"./norm":106,"./pool":110,"./reduction_ops":113,"./reverse":114,"./slice":115,"./softmax":117,"./transpose":118,"./types":119,"./unary_ops":120}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var session_util = require("../../graph/session_util");
var tensor_array_map_1 = require("../../graph/tensor_array_map");
var ndarray_1 = require("../../math/ndarray");
var Optimizer = (function () {
    function Optimizer(learningRate, specifiedVariableList) {
        this.learningRate = learningRate;
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
        this.one = environment_1.ENV.math.keep(ndarray_1.Scalar.new(1));
    }
    Optimizer.prototype.minimize = function (f, returnCost, varList) {
        if (returnCost === void 0) { returnCost = false; }
        var _a = this.computeGradients(f, varList), value = _a.value, gradients = _a.gradients;
        this.applyGradients(gradients);
        var varNames = Object.keys(gradients);
        varNames.forEach(function (varName) { return gradients[varName].dispose(); });
        if (returnCost) {
            return value;
        }
        else {
            value.dispose();
            return null;
        }
    };
    Optimizer.prototype.computeGradients = function (f, varList) {
        return environment_1.ENV.math.variableGradients(f, varList);
    };
    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.cGraph != null) {
                this.cGraph.dispose();
            }
            this.prevBatchSize = batchSize;
            this.cGraph = math.keep(ndarray_1.Scalar.new(-this.learningRate / batchSize));
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, math.keep(ndarray_1.NDArray.zeros(node.output.shape))); });
    };
    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    Optimizer.prototype.dispose = function () {
        if (this.cGraph != null) {
            this.cGraph.dispose();
        }
        this.one.dispose();
        if (this.variableNodes != null) {
            this.variableNodes.forEach(function (node) {
                node.data.dispose();
            });
        }
        if (this.specifiedVariableNodes != null) {
            this.specifiedVariableNodes.forEach(function (node) {
                node.data.dispose();
            });
        }
    };
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{"../../environment":10,"../../graph/session_util":43,"../../graph/tensor_array_map":44,"../../math/ndarray":105}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tensor_array_map_1 = require("../../graph/tensor_array_map");
var ndarray_1 = require("../ndarray");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.setLearningRate(learningRate);
        return _this;
    }
    SGDOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var math = environment_1.ENV.math;
        var varNames = Object.keys(variableGradients);
        varNames.forEach(function (varName) {
            var gradient = variableGradients[varName];
            var value = math.registeredVariables[varName];
            var newValue = math.scope(function () {
                return math.add(math.multiply(_this.c, gradient), value);
            });
            value.assign(newValue);
        });
    };
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.cGraph, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        this.c.dispose();
        _super.prototype.dispose.call(this);
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
            this.c.dispose();
        }
        this.c = environment_1.ENV.math.keep(ndarray_1.Scalar.new(-learningRate));
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"../../environment":10,"../../graph/tensor_array_map":44,"../ndarray":105,"./optimizer":108}],110:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
        var gradients = function (dy, y) {
            return { x: function () { return Ops.maxPoolBackprop(dy, x4D, filterSize, strides, pad); } };
        };
        var res = environment_1.ENV.engine.executeKernel('MaxPool', { inputs: { x: x4D }, args: { convInfo: convInfo } }, gradients);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.maxPoolBackprop = function (dy, input, filterSize, strides, pad, dimRoundingMode) {
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.executeKernel('MaxPoolBackprop', { inputs: { dy: dy4D, x: input4D }, args: { convInfo: convInfo } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.minPool = function (input, filterSize, strides, pad, dimRoundingMode) {
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in minPool: x must be rank 4 but got rank " + input4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in minPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.executeKernel('MinPool', { inputs: { x: input4D }, args: { convInfo: convInfo } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
        var gradients = function (dy, y) {
            return { x: function () { return Ops.avgPoolBackprop(dy, x4D, filterSize, strides, pad); } };
        };
        var res = environment_1.ENV.engine.executeKernel('AvgPool', { inputs: { x: x4D }, args: { convInfo: convInfo } }, gradients);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    Ops.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
        var res = environment_1.ENV.engine.executeKernel('AvgPoolBackprop', { inputs: { dy: dy4D, x: input4D }, args: { convInfo: convInfo } });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        decorators_1.operation
    ], Ops, "maxPool", null);
    __decorate([
        decorators_1.operation
    ], Ops, "maxPoolBackprop", null);
    __decorate([
        decorators_1.operation
    ], Ops, "minPool", null);
    __decorate([
        decorators_1.operation
    ], Ops, "avgPool", null);
    __decorate([
        decorators_1.operation
    ], Ops, "avgPoolBackprop", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./conv_util":97,"./decorators":99}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var MPRandGauss = (function () {
    function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        var seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    MPRandGauss.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
            var value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        var resultX, resultY;
        var isValid = false;
        while (!isValid) {
            var v1 = void 0, v2 = void 0, s = void 0;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            var mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    };
    MPRandGauss.prototype.convertValue = function (value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    };
    MPRandGauss.prototype.isValidTruncated = function (value) {
        return value <= this.upper && value >= this.lower;
    };
    return MPRandGauss;
}());
exports.MPRandGauss = MPRandGauss;

},{"seedrandom":125}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],113:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var Ops = (function () {
    function Ops() {
    }
    Ops.logSumExp = function (input, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var xMax = input.max(axes, true);
        var a = input.sub(xMax);
        var b = a.exp();
        var c = b.sum(axes);
        var d = c.log();
        var res = xMax.reshape(d.shape).add(d);
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
            return res.reshape(newShape);
        }
        return res;
    };
    Ops.sum = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        return environment_1.ENV.math.customGradient('sum', function () {
            var permutation = axis_util.getAxesPermutation(axes, x.rank);
            var reductionAxes = axes;
            var permutedX = x;
            if (permutation != null) {
                permutedX = x.transpose(permutation);
                reductionAxes =
                    axis_util.getInnerMostAxes(reductionAxes.length, x.rank);
            }
            var value = environment_1.ENV.engine.executeKernel('Sum', { inputs: { x: permutedX }, args: { axes: reductionAxes } });
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
                value = value.reshape(newShape);
            }
            var gradients = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = function () { return expandedDy.mul(ndarray_1.NDArray.ones(x.shape, 'float32')); };
                return { x: derX };
            };
            return { value: value, gradients: gradients };
        }, { x: x });
    };
    Ops.mean = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        return environment_1.ENV.math.customGradient('mean', function () {
            var reduceSizeScalar = ndarray_1.Scalar.new(reduceSize);
            var res = x.div(reduceSizeScalar);
            var value = res.sum(axis, keepDims);
            var gradients = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = function () { return expandedDy.mul(ndarray_1.NDArray.ones(x.shape, 'float32'))
                    .div(reduceSizeScalar); };
                return { x: derX };
            };
            return { value: value, gradients: gradients };
        }, { x: x });
    };
    Ops.min = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.executeKernel('Min', { inputs: { x: x }, args: { axes: axes } });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    Ops.max = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.executeKernel('Max', { inputs: { x: x }, args: { axes: axes } });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    Ops.argMin = function (x, axis) {
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.executeKernel('ArgMin', { inputs: { x: x }, args: { axes: axes } });
    };
    Ops.argMax = function (x, axis) {
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.executeKernel('ArgMax', { inputs: { x: x }, args: { axes: axes } });
    };
    Ops.argMaxEquals = function (x1, x2) {
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return x1.argMax().equal(x2.argMax());
    };
    Ops.moments = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var mean = x.mean(axes, keepDims);
        var keepDimsShape = mean.shape;
        if (!keepDims) {
            keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
        }
        var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
        var variance = devSquared.mean(axes, keepDims);
        return { mean: mean, variance: variance };
    };
    __decorate([
        decorators_1.operation
    ], Ops, "logSumExp", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sum", null);
    __decorate([
        decorators_1.operation
    ], Ops, "mean", null);
    __decorate([
        decorators_1.operation
    ], Ops, "min", null);
    __decorate([
        decorators_1.operation
    ], Ops, "max", null);
    __decorate([
        decorators_1.operation
    ], Ops, "argMin", null);
    __decorate([
        decorators_1.operation
    ], Ops, "argMax", null);
    __decorate([
        decorators_1.operation
    ], Ops, "argMaxEquals", null);
    __decorate([
        decorators_1.operation
    ], Ops, "moments", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./axis_util":48,"./decorators":99,"./ndarray":105}],114:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.reverse1D = function (x) {
        util.assert(x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + x.rank + ".");
        var input4D = x.as4D(1, 1, 1, x.shape[0]);
        var res = Ops.reverse4D(input4D, [3]);
        return res.as1D();
    };
    Ops.reverse2D = function (x, axis) {
        util.assert(x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + x.rank + ".");
        var axisCleaned = axis_util.parseAxisParam(axis, x.shape).map(function (a) { return a + 2; });
        var input4D = x.as4D(1, 1, x.shape[0], x.shape[1]);
        var res = Ops.reverse4D(input4D, axisCleaned);
        return res.as2D(res.shape[2], res.shape[3]);
    };
    Ops.reverse3D = function (x, axis) {
        util.assert(x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + x.rank + ".");
        var axisCleaned = axis_util.parseAxisParam(axis, x.shape).map(function (a) { return a + 1; });
        var input4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        var res = Ops.reverse4D(input4D, axisCleaned);
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    };
    Ops.reverse4D = function (x, axis) {
        util.assert(x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + x.rank + ".");
        var axisCleaned = axis_util.parseAxisParam(axis, x.shape);
        return environment_1.ENV.engine.executeKernel('Reverse4D', { inputs: { x: x }, args: { axis: axisCleaned } });
    };
    Ops.reverse = function (x, axis) {
        if (x.rank === 0) {
            return x.reshape(x.shape);
        }
        else if (x.rank === 1) {
            return Ops.reverse1D(x);
        }
        else if (x.rank === 2) {
            return Ops.reverse2D(x, axis);
        }
        else if (x.rank === 3) {
            return Ops.reverse3D(x, axis);
        }
        else if (x.rank === 4) {
            return Ops.reverse4D(x, axis);
        }
        else {
            throw new Error("Reverse for rank " + x.rank + " is not yet implemented");
        }
    };
    __decorate([
        decorators_1.operation
    ], Ops, "reverse1D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "reverse2D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "reverse3D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "reverse4D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "reverse", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./axis_util":48,"./decorators":99}],115:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var decorators_1 = require("./decorators");
var slice_util = require("./slice_util");
var Ops = (function () {
    function Ops() {
    }
    Ops.slice1D = function (x, begin, size) {
        slice_util.assertParamsValid(x, [begin], [size]);
        return environment_1.ENV.engine.executeKernel('Slice1D', { inputs: { x: x }, args: { begin: begin, size: size } });
    };
    Ops.slice2D = function (x, begin, size) {
        slice_util.assertParamsValid(x, begin, size);
        return environment_1.ENV.engine.executeKernel('Slice2D', { inputs: { x: x }, args: { begin: begin, size: size } });
    };
    Ops.slice3D = function (x, begin, size) {
        slice_util.assertParamsValid(x, begin, size);
        return environment_1.ENV.engine.executeKernel('Slice3D', { inputs: { x: x }, args: { begin: begin, size: size } });
    };
    Ops.slice4D = function (x, begin, size) {
        slice_util.assertParamsValid(x, begin, size);
        return environment_1.ENV.engine.executeKernel('Slice4D', { inputs: { x: x }, args: { begin: begin, size: size } });
    };
    Ops.slice = function (x, begin, size) {
        if (x.rank === 0) {
            throw new Error('Slicing scalar is not possible');
        }
        else if (x.rank === 1) {
            return Ops.slice1D(x, begin[0], size[0]);
        }
        else if (x.rank === 2) {
            return Ops.slice2D(x, begin, size);
        }
        else if (x.rank === 3) {
            return Ops.slice3D(x, begin, size);
        }
        else if (x.rank === 4) {
            return Ops.slice4D(x, begin, size);
        }
        else {
            throw new Error("Slicing for rank " + x.rank + " not implemented yet");
        }
    };
    __decorate([
        decorators_1.operation
    ], Ops, "slice1D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "slice2D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "slice3D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "slice4D", null);
    __decorate([
        decorators_1.operation
    ], Ops, "slice", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"./decorators":99,"./slice_util":116}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;

},{"../util":122}],117:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var Ops = (function () {
    function Ops() {
    }
    Ops.softmax = function (logits, dim) {
        if (dim === void 0) { dim = -1; }
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        var gradients = function (dy, y) {
            return {
                logits: function () {
                    var dyTimesY = dy.mul(y);
                    var keepDims = true;
                    return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y));
                }
            };
        };
        return environment_1.ENV.math.customGradient('softmax', function () {
            var keepDims = true;
            var lse = logits.logSumExp([dim], keepDims);
            var logResult = logits.toFloat().sub(lse);
            var value = logResult.exp();
            return { value: value, gradients: gradients };
        }, { logits: logits });
    };
    Ops.softmaxCrossEntropy = function (labels, logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertShapesMatch(labels.shape, logits.shape, 'Error in softmaxCrossEntropy: ');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error("Softmax cross entropy along a non-last dimension is not yet " +
                ("supported. Labels / logits was rank " + logits.rank + " ") +
                ("and dim was " + dim));
        }
        return environment_1.ENV.math.customGradient('softmaxCrossEntropy', function () {
            var softmaxLogits = logits.softmax(dim);
            var costVector = ndarray_1.Scalar.new(1e-5).add(softmaxLogits).log().mul(labels).neg();
            var value = costVector.sum([dim]);
            var gradients = function (dy, y) {
                var dyShape = axis_util.expandShapeToKeepDim(dy.shape, [dim]);
                return {
                    logits: function () {
                        return dy.reshape(dyShape).mul(softmaxLogits.sub(labels.toFloat()));
                    },
                    labels: function () { return dy.reshape(dyShape).mul(labels.sub(softmaxLogits)); }
                };
            };
            return { value: value, gradients: gradients };
        }, { labels: labels, logits: logits });
    };
    __decorate([
        decorators_1.operation
    ], Ops, "softmax", null);
    __decorate([
        decorators_1.operation
    ], Ops, "softmaxCrossEntropy", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./axis_util":48,"./decorators":99,"./ndarray":105}],118:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var decorators_1 = require("./decorators");
var Ops = (function () {
    function Ops() {
    }
    Ops.transpose = function (x, perm) {
        if (perm == null) {
            perm = x.shape.map(function (s, i) { return i; }).reverse();
        }
        var der = function (dy) {
            var undoPerm = axis_util.getUndoAxesPermutation(perm);
            var derX = function () { return dy.transpose(undoPerm); };
            return { x: derX };
        };
        util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of perm " + perm + "."));
        return environment_1.ENV.engine.executeKernel('Transpose', { inputs: { x: x }, args: { perm: perm } }, der);
    };
    __decorate([
        decorators_1.operation
    ], Ops, "transpose", null);
    return Ops;
}());
exports.Ops = Ops;

},{"../environment":10,"../util":122,"./axis_util":48,"./decorators":99}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
})(Rank = exports.Rank || (exports.Rank = {}));
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var upcastTypeMap = {
    float32: UpcastFloat32AndMap,
    int32: UpcastInt32AndMap,
    bool: UpcastBoolAndMap
};
function upcastType(typeA, typeB) {
    return upcastTypeMap[typeA][typeB];
}
exports.upcastType = upcastType;
function sumOutType(type) {
    return upcastType(type, 'int32');
}
exports.sumOutType = sumOutType;

},{}],120:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var decorators_1 = require("./decorators");
var ndarray_1 = require("./ndarray");
var Ops = (function () {
    function Ops() {
    }
    Ops.neg = function (x) {
        return environment_1.ENV.engine.executeKernel('Neg', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.neg(); } };
        });
    };
    Ops.ceil = function (x) {
        return environment_1.ENV.engine.executeKernel('Ceil', { inputs: { x: x } });
    };
    Ops.floor = function (x) {
        return environment_1.ENV.engine.executeKernel('Floor', { inputs: { x: x } });
    };
    Ops.exp = function (x) {
        return environment_1.ENV.engine.executeKernel('Exp', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.mul(y); } };
        });
    };
    Ops.log = function (x) {
        return environment_1.ENV.engine.executeKernel('Log', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.div(x.toFloat()); } };
        });
    };
    Ops.sqrt = function (x) {
        return environment_1.ENV.engine.executeKernel('Sqrt', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.div(x.toFloat().sqrt().mul(ndarray_1.Scalar.new(2))); } };
        });
    };
    Ops.square = function (x) {
        return environment_1.ENV.engine.executeKernel('Square', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.mul(x.toFloat().mul(ndarray_1.Scalar.new(2))); } };
        });
    };
    Ops.abs = function (x) {
        return environment_1.ENV.engine.executeKernel('Abs', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.mul(x.toFloat().step(-1)); } };
        });
    };
    Ops.clip = function (x, min, max) {
        util.assert((min <= max), "Error in clip: min (" + min + ") must be" +
            ("less than or equal to max (" + max + ")."));
        return environment_1.ENV.engine.executeKernel('Clip', { inputs: { x: x }, args: { min: min, max: max } });
    };
    Ops.relu = function (x) {
        return environment_1.ENV.engine.executeKernel('Relu', { inputs: { x: x } }, function (dy, y) {
            var stepRes = x.step();
            return { x: function () { return dy.mul(stepRes.toFloat()); } };
        });
    };
    Ops.elu = function (x) {
        var der = function (dy) {
            return {
                x: function () { return dy.mul(eluDer(x)); },
                alpha: function () {
                    throw new Error('Derivative of prelu with respect to alpha is ' +
                        'not implemented yet');
                }
            };
        };
        return environment_1.ENV.engine.executeKernel('Elu', { inputs: { x: x } }, der);
    };
    Ops.selu = function (x) {
        return environment_1.ENV.engine.executeKernel('Selu', { inputs: { x: x } });
    };
    Ops.leakyRelu = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        return environment_1.ENV.engine.executeKernel('LeakyRelu', { inputs: { x: x }, args: { alpha: alpha } });
    };
    Ops.prelu = function (x, alpha) {
        var der = function (dy) {
            return {
                x: function () { return dy.mul(preluDer(x, alpha)); },
                alpha: function () {
                    throw new Error('Derivative of prelu with respect to alpha is ' +
                        'not implemented yet');
                }
            };
        };
        return environment_1.ENV.engine.executeKernel('PReLU', { inputs: { x: x, alpha: alpha } }, der);
    };
    Ops.sigmoid = function (x) {
        return environment_1.ENV.engine.executeKernel('Sigmoid', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.mul(y.mul(ndarray_1.Scalar.new(1).sub(y))); } };
        });
    };
    Ops.sin = function (x) {
        return environment_1.ENV.engine.executeKernel('Sin', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return x.toFloat().cos().mul(dy); } };
        });
    };
    Ops.cos = function (x) {
        return environment_1.ENV.engine.executeKernel('Cos', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return x.toFloat().sin().neg().mul(dy); } };
        });
    };
    Ops.tan = function (x) {
        return environment_1.ENV.engine.executeKernel('Tan', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.div(x.cos().square()); } };
        });
    };
    Ops.asin = function (x) {
        return environment_1.ENV.engine.executeKernel('Asin', { inputs: { x: x } }, function (dy, y) {
            return {
                x: function () { return dy.div(Ops.sqrt(ndarray_1.Scalar.new(1).sub(x.toFloat().square()))); }
            };
        });
    };
    Ops.acos = function (x) {
        return environment_1.ENV.engine.executeKernel('Acos', { inputs: { x: x } }, function (dy, y) {
            return {
                x: function () { return dy.div(Ops.sqrt(ndarray_1.Scalar.new(1).sub(x.toFloat().square()))).neg(); }
            };
        });
    };
    Ops.atan = function (x) {
        return environment_1.ENV.engine.executeKernel('Atan', { inputs: { x: x } }, function (dy, y) {
            return { x: function () { return dy.div(ndarray_1.Scalar.new(1).add(x.toFloat().square())); } };
        });
    };
    Ops.sinh = function (x) {
        return environment_1.ENV.engine.executeKernel('Sinh', { inputs: { x: x } });
    };
    Ops.cosh = function (x) {
        return environment_1.ENV.engine.executeKernel('Cosh', { inputs: { x: x } });
    };
    Ops.tanh = function (x) {
        return environment_1.ENV.engine.executeKernel('Tanh', { inputs: { x: x } });
    };
    Ops.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        return environment_1.ENV.engine.executeKernel('Step', { inputs: { x: x }, args: { alpha: alpha } });
    };
    __decorate([
        decorators_1.operation
    ], Ops, "neg", null);
    __decorate([
        decorators_1.operation
    ], Ops, "ceil", null);
    __decorate([
        decorators_1.operation
    ], Ops, "floor", null);
    __decorate([
        decorators_1.operation
    ], Ops, "exp", null);
    __decorate([
        decorators_1.operation
    ], Ops, "log", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sqrt", null);
    __decorate([
        decorators_1.operation
    ], Ops, "square", null);
    __decorate([
        decorators_1.operation
    ], Ops, "abs", null);
    __decorate([
        decorators_1.operation
    ], Ops, "clip", null);
    __decorate([
        decorators_1.operation
    ], Ops, "relu", null);
    __decorate([
        decorators_1.operation
    ], Ops, "elu", null);
    __decorate([
        decorators_1.operation
    ], Ops, "selu", null);
    __decorate([
        decorators_1.operation
    ], Ops, "leakyRelu", null);
    __decorate([
        decorators_1.operation
    ], Ops, "prelu", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sigmoid", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sin", null);
    __decorate([
        decorators_1.operation
    ], Ops, "cos", null);
    __decorate([
        decorators_1.operation
    ], Ops, "tan", null);
    __decorate([
        decorators_1.operation
    ], Ops, "asin", null);
    __decorate([
        decorators_1.operation
    ], Ops, "acos", null);
    __decorate([
        decorators_1.operation
    ], Ops, "atan", null);
    __decorate([
        decorators_1.operation
    ], Ops, "sinh", null);
    __decorate([
        decorators_1.operation
    ], Ops, "cosh", null);
    __decorate([
        decorators_1.operation
    ], Ops, "tanh", null);
    __decorate([
        decorators_1.operation
    ], Ops, "step", null);
    return Ops;
}());
exports.Ops = Ops;
function preluDer(x, alpha) {
    return environment_1.ENV.engine.executeKernel('PReLUDer', { inputs: { x: x, alpha: alpha } });
}
function eluDer(x) {
    return environment_1.ENV.engine.executeKernel('EluDer', { inputs: { x: x } });
}

},{"../environment":10,"../util":122,"./decorators":99,"./ndarray":105}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var backend_cpu_1 = require("./math/backends/backend_cpu");
var backend_webgl_1 = require("./math/backends/backend_webgl");
var math_1 = require("./math/math");
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
exports.TEST_EPSILON = 1e-2;
function mean(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum / values.length;
}
exports.mean = mean;
function standardDeviation(values, mean) {
    var squareDiffSum = 0;
    for (var i = 0; i < values.length; i++) {
        var diff = values[i] - mean;
        squareDiffSum += diff * diff;
    }
    return Math.sqrt(squareDiffSum / values.length);
}
exports.standardDeviation = standardDeviation;
function kurtosis(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum4 = 0;
    for (var i = 0; i < n; i++) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum4 += Math.pow(v, 4);
    }
    return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2);
}
exports.kurtosis = kurtosis;
function skewness(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum3 = 0;
    for (var i = 0; i < n; i++) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum3 += Math.pow(v, 3);
    }
    return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
}
exports.skewness = skewness;
function jarqueBeraNormalityTest(a) {
    var values;
    if (a instanceof ndarray_1.NDArray) {
        values = a.dataSync();
    }
    else {
        values = a;
    }
    var n = values.length;
    var s = skewness(values);
    var k = kurtosis(values);
    var jb = n / 6 * (Math.pow(s, 2) + 0.25 * Math.pow(k - 3, 2));
    var CHI_SQUARE_2DEG = 5.991;
    if (jb > CHI_SQUARE_2DEG) {
        throw new Error("Invalid p-value for JB: " + jb);
    }
}
exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;
function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var actualValues;
    if (actual instanceof ndarray_1.NDArray) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    var actualMean = mean(actualValues);
    expectNumbersClose(actualMean, expectedMean, epsilon);
    expectNumbersClose(standardDeviation(actualValues, actualMean), expectedStdDev, epsilon);
}
exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!(actual instanceof ndarray_1.NDArray) && !(expected instanceof ndarray_1.NDArray)) {
        var aType = actual.constructor.name;
        var bType = expected.constructor.name;
        if (aType !== bType) {
            throw new Error("Arrays are of different type actual: " + aType + " " +
                ("vs expected: " + bType));
        }
    }
    else if (actual instanceof ndarray_1.NDArray && expected instanceof ndarray_1.NDArray) {
        if (actual.dtype !== expected.dtype) {
            throw new Error("Arrays are of different type actual: " + actual.dtype + " " +
                ("vs expected: " + expected.dtype + "."));
        }
        if (!util.arraysEqual(actual.shape, expected.shape)) {
            throw new Error("Arrays are of different shape actual: " + actual.shape + " " +
                ("vs expected: " + expected.shape + "."));
        }
    }
    var actualValues;
    var expectedValues;
    if (actual instanceof ndarray_1.NDArray) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    if (expected instanceof ndarray_1.NDArray) {
        expectedValues = expected.dataSync();
    }
    else {
        expectedValues = expected;
    }
    if (actualValues.length !== expectedValues.length) {
        throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " +
            ("expected: " + expectedValues.length + ".\n") +
            ("Actual:   " + actualValues + ".\n") +
            ("Expected: " + expectedValues + "."));
    }
    for (var i = 0; i < expectedValues.length; ++i) {
        var a = actualValues[i];
        var e = expectedValues[i];
        if (!areClose(a, Number(e), epsilon)) {
            throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" +
                ("Actual:   " + actualValues + ".\n") +
                ("Expected: " + expectedValues + "."));
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectArraysEqual(actual, expected) {
    return expectArraysClose(actual, expected, 0);
}
exports.expectArraysEqual = expectArraysEqual;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    var actualVals;
    if (actual instanceof ndarray_1.NDArray) {
        actualVals = actual.dataSync();
    }
    else {
        actualVals = actual;
    }
    for (var i = 0; i < actualVals.length; i++) {
        if (actualVals[i] < low || actualVals[i] > high) {
            throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function randomArrayInRange(n, minValue, maxValue) {
    var v = new Float32Array(n);
    var range = maxValue - minValue;
    for (var i = 0; i < n; ++i) {
        v[i] = (Math.random() * range) + minValue;
    }
    return v;
}
exports.randomArrayInRange = randomArrayInRange;
function makeIdentity(n) {
    var i = new Float32Array(n * n);
    for (var j = 0; j < n; ++j) {
        i[(j * n) + j] = 1;
    }
    return i;
}
exports.makeIdentity = makeIdentity;
function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
    var result = new Float32Array(aRow * bCol);
    for (var r = 0; r < aRow; ++r) {
        var aOffset = (r * aCol);
        var cOffset = (r * bCol);
        for (var c = 0; c < bCol; ++c) {
            var d = 0;
            for (var k = 0; k < aCol; ++k) {
                d += a[aOffset + k] * b[(k * bCol) + c];
            }
            result[cOffset + c] = d;
        }
    }
    return result;
}
exports.cpuMultiplyMatrix = cpuMultiplyMatrix;
function cpuDotProduct(a, b) {
    if (a.length !== b.length) {
        throw new Error('cpuDotProduct: incompatible vectors.');
    }
    var d = 0;
    for (var i = 0; i < a.length; ++i) {
        d += a[i] * b[i];
    }
    return d;
}
exports.cpuDotProduct = cpuDotProduct;
function describeMathCPU(name, tests, featuresList) {
    var testNameBase = 'CPU: math.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () {
        var safeMode = true;
        return new math_1.NDArrayMath(new backend_cpu_1.MathBackendCPU(), safeMode);
    }, features); }, featuresList);
}
exports.describeMathCPU = describeMathCPU;
function describeMathGPU(name, tests, featuresList) {
    var testNameBase = 'WebGL: math.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () {
        var safeMode = true;
        return new math_1.NDArrayMath(new backend_webgl_1.MathBackendWebGL(), safeMode);
    }, features); }, featuresList);
}
exports.describeMathGPU = describeMathGPU;
function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
    describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);
}
exports.describeCustom = describeCustom;
function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
    if (featuresList != null) {
        featuresList.forEach(function (features) {
            var testName = testNameBase + ' ' + JSON.stringify(features);
            executor(testName, tests, features);
        });
    }
    else {
        executor(testNameBase, tests);
    }
}
function resolveTestFuncPromise(testFunc) {
    return function (done) {
        var result = testFunc();
        if (result instanceof Promise) {
            result.then(done, function (e) {
                fail(e);
                done();
            });
        }
        else {
            done();
        }
    };
}
var PROMISE_IT = function (name, testFunc) {
    it(name, resolveTestFuncPromise(testFunc));
};
var PROMISE_FIT = function (name, testFunc) {
    fit(name, resolveTestFuncPromise(testFunc));
};
var PROMISE_XIT = function (name, testFunc) {
    xit(name, resolveTestFuncPromise(testFunc));
};
function executeMathTests(testName, tests, mathFactory, features) {
    var math;
    var customBeforeEach = function () {
        math = mathFactory();
        environment_1.ENV.setMath(math);
        math.startScope();
    };
    var customAfterEach = function () {
        math.endScope(null);
        math.dispose();
    };
    var customIt = function (name, testFunc) {
        PROMISE_IT(name, function () { return testFunc(math); });
    };
    var customFit = function (name, testFunc) {
        PROMISE_FIT(name, function () { return testFunc(math); });
    };
    var customXit = function (name, testFunc) {
        PROMISE_XIT(name, function () { return testFunc(math); });
    };
    executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt, customFit, customXit);
}
exports.executeMathTests = executeMathTests;
function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt, customFit, customXit) {
    if (customIt === void 0) { customIt = PROMISE_IT; }
    if (customFit === void 0) { customFit = PROMISE_FIT; }
    if (customXit === void 0) { customXit = PROMISE_XIT; }
    describe(testName, function () {
        beforeEach(function () {
            if (features != null) {
                environment_1.ENV.setFeatures(features);
                environment_1.ENV.addCustomBackend('webgl', function () { return new backend_webgl_1.MathBackendWebGL(); });
                environment_1.ENV.addCustomBackend('cpu', function () { return new backend_cpu_1.MathBackendCPU(); });
            }
            if (customBeforeEach != null) {
                customBeforeEach();
            }
        });
        afterEach(function () {
            if (customAfterEach != null) {
                customAfterEach();
            }
            if (features != null) {
                environment_1.ENV.reset();
            }
        });
        tests.forEach(function (test) { return test(customIt, customFit, customXit); });
    });
}
function assertIsNan(val, dtype) {
    if (!util.isValNaN(val, dtype)) {
        throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
    }
}
exports.assertIsNan = assertIsNan;

},{"./environment":10,"./math/backends/backend_cpu":49,"./math/backends/backend_webgl":51,"./math/math":103,"./math/ndarray":105,"./util":122}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, "The dtypes of the first (" + a.dtype + ") and " +
        ("second (" + b.dtype + ") input must match"));
}
exports.assertTypesMatch = assertTypesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        setTimeout(tryFn, 0);
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size (" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
exports.NAN_INT32 = 1 << 31;
exports.NAN_BOOL = 255;
exports.NAN_FLOAT32 = NaN;
function getNaN(dtype) {
    if (dtype === 'float32') {
        return exports.NAN_FLOAT32;
    }
    else if (dtype === 'int32') {
        return exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.getNaN = getNaN;
function isValNaN(val, dtype) {
    if (isNaN(val)) {
        return true;
    }
    if (dtype === 'float32') {
        return false;
    }
    else if (dtype === 'int32') {
        return val === exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return val === exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.isValNaN = isValNaN;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axis !== undefined) {
            if (axis[j] === i && shape[i] > 1) {
                throw new Error("axis " + i + " is not 1");
            }
            if ((axis[j] === undefined || axis[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axis[j] <= i)
                j++;
        }
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function getTypedArrayFromDType(dtype, size) {
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    return values;
}
exports.getTypedArrayFromDType = getTypedArrayFromDType;
function isNDArrayInList(ndarray, ndarrayList) {
    for (var i = 0; i < ndarrayList.length; i++) {
        if (ndarrayList[i].id === ndarray.id) {
            return true;
        }
    }
    return false;
}
exports.isNDArrayInList = isNDArrayInList;
function checkForNaN(vals, dtype, name) {
    for (var i = 0; i < vals.length; i++) {
        if (isValNaN(vals[i], dtype)) {
            throw Error("The result of the last math." + name + " has NaNs.");
        }
    }
}
exports.checkForNaN = checkForNaN;
function flattenNameArrayMap(nameArrayMap, keys) {
    var xs = [];
    if (nameArrayMap instanceof ndarray_1.NDArray) {
        xs.push(nameArrayMap);
    }
    else {
        var xMap = nameArrayMap;
        for (var i = 0; i < keys.length; i++) {
            xs.push(xMap[keys[i]]);
        }
    }
    return xs;
}
exports.flattenNameArrayMap = flattenNameArrayMap;
function unflattenToNameArrayMap(keys, flatArrays) {
    if (keys.length !== flatArrays.length) {
        throw new Error("Cannot unflatten NDArray[], keys and arrays are not of same length.");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = flatArrays[i];
    }
    return result;
}
exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
function hasEncodingLoss(oldType, newType) {
    if (newType === 'float32') {
        return false;
    }
    if (newType === 'int32' && oldType !== 'float32') {
        return false;
    }
    if (newType === 'bool' && oldType === 'bool') {
        return false;
    }
    return true;
}
exports.hasEncodingLoss = hasEncodingLoss;
function nextFrame() {
    return new Promise(function (resolve) { return requestAnimationFrame(function () { return resolve(); }); });
}
exports.nextFrame = nextFrame;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        var vals = new Int32Array(array.length);
        for (var i = 0; i < vals.length; ++i) {
            var val = array[i];
            if (isValNaN(val, 'int32')) {
                vals[i] = getNaN('int32');
            }
            else {
                vals[i] = val;
            }
        }
        return vals;
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            var val = array[i];
            if (isValNaN(val, 'bool')) {
                bool[i] = getNaN('bool');
            }
            else if (Math.round(val) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
exports.copyTypedArray = copyTypedArray;

},{"./math/ndarray":105}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.4.2';
exports.version = version;

},{}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function PolymerElement(spec) {
    return Polymer.Class(spec);
}
exports.PolymerElement = PolymerElement;

},{}],125:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":126,"./lib/tychei":127,"./lib/xor128":128,"./lib/xor4096":129,"./lib/xorshift7":130,"./lib/xorwow":131,"./seedrandom":132}],126:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],127:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],128:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],129:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],130:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],131:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],132:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":4}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlbW9zL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vcy9ubi1hcnQvY3Bwbi50cyIsImRlbW9zL25uLWFydC9ubi1hcnQudHMiLCJkZW1vcy9ubi1hcnQvbm5fYXJ0X3V0aWwudHMiLCJkZW1vcy9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kYXRhL2NoZWNrcG9pbnRfbG9hZGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kYXRhL2RhdGFzZXQuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2RhdGEvaW5wdXRfcHJvdmlkZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2RhdGEveGhyLWRhdGFzZXQuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2RldmljZV91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9lbnZpcm9ubWVudC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvYWN0aXZhdGlvbl9mdW5jdGlvbnMuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL2dyYXBoLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9ncmFwaF9ydW5uZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL2dyYXBoX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wZXJhdGlvbl9lbWl0dGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvYWRkLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvYXJnbWF4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvYXJnbWF4ZXF1YWxzLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvY29uY2F0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvY29udm9sdXRpb24uanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wcy9kaXZpZGUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvbi5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9jb3N0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvZXhwLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvbGluZWFyX2NvbWJpbmF0aW9uLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvbG9nLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvbWF0bXVsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvbWF4X3Bvb2wuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wcy9tdWx0aXBseS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvb3BzL29wLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvcmVkdWNlX3N1bS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvb3BzL3Jlc2hhcGUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wcy9zb2Z0bWF4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHMvc3VidHJhY3QuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2dyYXBoL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC9wcmlvcml0eV9xdWV1ZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvc2Vzc2lvbi5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZ3JhcGgvc2Vzc2lvbl91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9ncmFwaC90ZW5zb3JfYXJyYXlfbWFwLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9pbmRleC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vaW5pdGlhbGl6ZXJzLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2FycmF5X29wcy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9heGlzX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvYmFja2VuZF9jcHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvYmFja2VuZF9lbmdpbmUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvYmFja2VuZF93ZWJnbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy9rZXJuZWxfcmVnaXN0cnkuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvdGFwZV91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3R5cGVzL21hdG11bC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9hcmdtaW5tYXhfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2F2Z19wb29sX2JhY2twcm9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2JpbmFyeW9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9jbGlwX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9jb25jYXRfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2NvbnZfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9jb3B5X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9mcm9tX3BpeGVsc19ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvZ2F0aGVyX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9ncGdwdV9jb250ZXh0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL2dwZ3B1X21hdGguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvZ3BncHVfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9sb2dpY2FsX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9scm5fZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9tdWxtYXRfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL211bHRpbm9taWFsX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9vbmVob3RfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL3BhZF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvcG9vbF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvcmVkdWNlX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL3JldmVyc2VfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL3NoYWRlcl9jb21waWxlci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYWNrZW5kcy93ZWJnbC9zbGljZV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvdGV4X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL3RpbGVfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2JhY2tlbmRzL3dlYmdsL3RyYW5zcG9zZV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvdW5hcnlvcF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmFja2VuZHMvd2ViZ2wvd2ViZ2xfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9iYXRjaG5vcm0uanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvYmluYXJ5X29wcy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9icm9hZGNhc3RfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9jb21wYXJlLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2NvbmNhdC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9jb25jYXRfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9jb252LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2NvbnZfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9jb3N0X2Z1bmN0aW9ucy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9kZWNvcmF0b3JzLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL2ltYWdlX29wcy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9sb2dpY2FsX29wcy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9sc3RtLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL21hdGguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvbWF0bXVsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL25kYXJyYXkuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvbm9ybS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9vcHMuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvb3B0aW1pemVycy9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL3Bvb2wuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvcmFuZC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9yZWR1Y2VfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9yZWR1Y3Rpb25fb3BzLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL3JldmVyc2UuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvc2xpY2UuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL21hdGgvc2xpY2VfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC9zb2Z0bWF4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9tYXRoL3RyYW5zcG9zZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC90eXBlcy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vbWF0aC91bmFyeV9vcHMuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL3Rlc3RfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vdmVyc2lvbi5qcyIsImRlbW9zL3BvbHltZXItc3BlYy50cyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL2FsZWEuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjEyOC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3I0MDk2LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcnNoaWZ0Ny5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3J3b3cuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNpQkEsZ0NBQWdDO0FBQ2hDLDZDQUE2QztBQUU3QyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFHekIsTUFBTSxxQkFBcUIsR0FHdkI7SUFDRixNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFO0lBQ3JCLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUU7SUFDbkIsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtJQUNyQixNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFO0NBQ3RCLENBQUM7QUFFRixNQUFNLHlCQUF5QixHQUFHLENBQUMsQ0FBQztBQUNwQyxNQUFNLG9CQUFvQixHQUFHLENBQUMsQ0FBQztBQUUvQjtJQWtCRSxZQUFvQixlQUFrQztRQUFsQyxvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7UUFiOUMsd0JBQW1CLEdBQWlCLEVBQUUsQ0FBQztRQUd2QyxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsY0FBUyxHQUFHLENBQUMsQ0FBQztRQU9kLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBRzFCLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUMsQ0FBQyxDQUFDLENBQUM7UUFFL0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsZ0JBQWdCLENBQzVDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUN2RCx5QkFBeUIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCxlQUFlLENBQUMsZUFBdUIsRUFBRSxZQUFvQjtRQUMzRCxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUN6RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDeEMsQ0FBQztRQUNELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLENBQUM7UUFDOUIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25DLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbEMsQ0FBQztRQUVELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUN2QyxDQUFDLHlCQUF5QixHQUFHLG9CQUFvQixFQUFFLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFDdEUsWUFBWSxDQUFDLENBQUM7UUFDbEIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQzVDLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQzVELENBQUM7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FDbEQsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUE0QixFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRUQscUJBQXFCLENBQUMsa0JBQXNDO1FBQzFELElBQUksQ0FBQyw4QkFBOEIsR0FBRyxrQkFBa0IsQ0FBQztJQUMzRCxDQUFDO0lBRUQsWUFBWSxDQUFDLFNBQWlCO1FBQzVCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdCLENBQUM7SUFFRCxVQUFVLENBQUMsT0FBZTtRQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUN6QixDQUFDO0lBRUQsVUFBVSxDQUFDLE9BQWU7UUFDeEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDekIsQ0FBQztJQUVELEtBQUs7UUFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRU8sS0FBSyxDQUFDLGdCQUFnQjtRQUM1QixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLE1BQU0sQ0FBQztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ25DLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFFbkMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDakMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNuRCxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ25ELE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBZSxDQUFDO1lBQzlDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBZSxDQUFDO1lBRTlDLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQztZQUNyQixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztZQUVuRCxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQWEsRUFBRSxFQUFFLENBQ2pDLHFCQUFxQixDQUFDLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWxFLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUNoRSxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUVuRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDeEMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUUsQ0FBQztZQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQztnQkFDaEUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUMzRCxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sY0FBYyxDQUFDLFVBQXdCLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztDQUNGO0FBaEhELG9CQWdIQztBQUdELEtBQUsseUJBQXlCLENBQWEsRUFBRSxNQUF5QjtJQUNwRSxNQUFNLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDbEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxNQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDL0MsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDeEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVoQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUl2QyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDN0IsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQzdCLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM3QixTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDOUIsQ0FBQztJQUNELEdBQUcsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDOzs7OztBQzFKRCxrREFBbUU7QUFDbkUsaUNBQWdEO0FBS2hELE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQztBQUcxQixNQUFNLFlBQVksR0FBaUMsNkJBQWMsQ0FBQztJQUNoRSxFQUFFLEVBQUUsUUFBUTtJQUNaLFVBQVUsRUFBRTtRQUNWLHVCQUF1QixFQUFFLEtBQUs7UUFDOUIsOEJBQThCLEVBQUUsTUFBTTtLQUN2QztDQUNGLENBQUMsQ0FBQztBQUVILFdBQVksU0FBUSxZQUFZO0lBYTlCLEtBQUs7UUFDSCxJQUFJLENBQUMsZUFBZTtZQUNoQixJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBc0IsQ0FBQztRQUUxRCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLENBQUM7UUFDNUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFNUUsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFdBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFPM0MsSUFBSSxDQUFDLHVCQUF1QixHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLDhCQUE4QixHQUFHLE1BQU0sQ0FBQztRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxhQUFhLENBQUMsK0JBQStCLENBQUUsQ0FBQyxnQkFBZ0IsQ0FFakUsZUFBZSxFQUFFLENBQUMsS0FBVSxFQUFFLEVBQUU7WUFDOUIsSUFBSSxDQUFDLDhCQUE4QixHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1lBQzVELElBQUksQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLDhCQUE4QixDQUFDLENBQUM7UUFDdkUsQ0FBQyxDQUFDLENBQUM7UUFFUCxNQUFNLFlBQVksR0FDZCxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFxQixDQUFDO1FBQzdELE1BQU0sa0JBQWtCLEdBQ3BCLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFtQixDQUFDO1FBQzFELFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBRWpFLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFFLEtBQWEsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3BFLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN6QyxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDbEQsa0JBQWtCLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXZDLE1BQU0sYUFBYSxHQUNmLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQXFCLENBQUM7UUFDOUQsTUFBTSxtQkFBbUIsR0FDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBbUIsQ0FBQztRQUMzRCxhQUFhLENBQUMsZ0JBQWdCLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUVsRSxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBRSxLQUFhLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNwRSxtQkFBbUIsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUMxRCxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQzNELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNuRCxtQkFBbUIsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUUxRCxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFbEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBUWxELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNwQixDQUFDO0NBQ0Y7QUFFRCx1QkFBdUIsQ0FBUztJQUM5QixNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUVELFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7Ozs7O0FDdEdwRCxnQ0FBZ0M7QUFFaEMsMEJBQ0ksVUFBa0IsRUFBRSxXQUFtQixFQUN2QyxrQkFBMEIsRUFBRSxrQkFBMEI7SUFDeEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsVUFBVSxHQUFHLFdBQVc7VUFDcEQsa0JBQWtCLENBQUMsQ0FBQztJQUN4QixJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDWixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNsRCxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGtCQUFrQixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDNUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQztZQUN6QixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQztZQUNyQyxNQUFNLEtBQUssR0FBRywyQkFBMkIsQ0FDckMsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFDdkQsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNCLENBQUM7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxHQUFHLFdBQVc7UUFDN0Msa0JBQWtCLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBbEJELDRDQWtCQztBQUlELHFDQUNJLENBQVMsRUFBRSxDQUFTLEVBQUUsVUFBa0IsRUFBRSxXQUFtQixFQUM3RCxLQUFhO0lBQ2YsTUFBTSxTQUFTLEdBQUcsVUFBVSxHQUFHLEdBQUcsQ0FBQztJQUNuQyxNQUFNLFVBQVUsR0FBRyxXQUFXLEdBQUcsR0FBRyxDQUFDO0lBQ3JDLE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUMzQyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxXQUFXLENBQUM7SUFFN0MsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztJQUVuRCxNQUFNLE1BQU0sR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFakMsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBYkQsa0VBYUM7OztBQ3RERDs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ254QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN3REEsd0JBQStCLElBQVU7SUFFdkMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBVyxDQUFpQyxDQUFDO0FBQ3BFLENBQUM7QUFIRCx3Q0FHQzs7O0FDL0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgZGwgZnJvbSAnZGVlcGxlYXJuJztcbmltcG9ydCAqIGFzIG5uX2FydF91dGlsIGZyb20gJy4vbm5fYXJ0X3V0aWwnO1xuXG5jb25zdCBNQVhfTEFZRVJTID0gMTA7XG5jb25zdCBtYXRoID0gZGwuRU5WLm1hdGg7XG5cbmV4cG9ydCB0eXBlIEFjdGl2YXRpb25GdW5jdGlvbiA9ICd0YW5oJ3wnc2luJ3wncmVsdSd8J3N0ZXAnO1xuY29uc3QgYWN0aXZhdGlvbkZ1bmN0aW9uTWFwOiB7XG4gIFthY3RpdmF0aW9uRnVuY3Rpb24gaW4gQWN0aXZhdGlvbkZ1bmN0aW9uXTogKG5kYXJyYXk6IGRsLkFycmF5MkQpID0+XG4gICAgICBkbC5BcnJheTJEXG59ID0ge1xuICAndGFuaCc6IHggPT4geC50YW5oKCksXG4gICdzaW4nOiB4ID0+IHguc2luKCksXG4gICdyZWx1JzogeCA9PiB4LnJlbHUoKSxcbiAgJ3N0ZXAnOiB4ID0+IHguc3RlcCgpXG59O1xuXG5jb25zdCBOVU1fSU1BR0VfU1BBQ0VfVkFSSUFCTEVTID0gMzsgIC8vIHgsIHksIHJcbmNvbnN0IE5VTV9MQVRFTlRfVkFSSUFCTEVTID0gMjtcblxuZXhwb3J0IGNsYXNzIENQUE4ge1xuICBwcml2YXRlIGlucHV0QXRsYXM6IGRsLkFycmF5MkQ7XG4gIHByaXZhdGUgb25lczogZGwuQXJyYXkyRDtcblxuICBwcml2YXRlIGZpcnN0TGF5ZXJXZWlnaHRzOiBkbC5BcnJheTJEO1xuICBwcml2YXRlIGludGVybWVkaWF0ZVdlaWdodHM6IGRsLkFycmF5MkRbXSA9IFtdO1xuICBwcml2YXRlIGxhc3RMYXllcldlaWdodHM6IGRsLkFycmF5MkQ7XG5cbiAgcHJpdmF0ZSB6MUNvdW50ZXIgPSAwO1xuICBwcml2YXRlIHoyQ291bnRlciA9IDA7XG4gIHByaXZhdGUgejFTY2FsZTogbnVtYmVyO1xuICBwcml2YXRlIHoyU2NhbGU6IG51bWJlcjtcbiAgcHJpdmF0ZSBudW1MYXllcnM6IG51bWJlcjtcblxuICBwcml2YXRlIHNlbGVjdGVkQWN0aXZhdGlvbkZ1bmN0aW9uTmFtZTogQWN0aXZhdGlvbkZ1bmN0aW9uO1xuXG4gIHByaXZhdGUgaXNJbmZlcnJpbmcgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGluZmVyZW5jZUNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICB0aGlzLmluZmVyZW5jZUNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQod2luZG93LmlubmVyV2lkdGgvNCk7XG4gICAgdGhpcy5pbmZlcmVuY2VDYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh3aW5kb3cuaW5uZXJIZWlnaHQvNik7XG5cbiAgICB0aGlzLmlucHV0QXRsYXMgPSBubl9hcnRfdXRpbC5jcmVhdGVJbnB1dEF0bGFzKFxuICAgICAgdGhpcy5pbmZlcmVuY2VDYW52YXMud2lkdGgsIHRoaXMuaW5mZXJlbmNlQ2FudmFzLmhlaWdodCwgXG4gICAgICBOVU1fSU1BR0VfU1BBQ0VfVkFSSUFCTEVTLCBOVU1fTEFURU5UX1ZBUklBQkxFUyk7XG4gICAgdGhpcy5vbmVzID0gZGwuQXJyYXkyRC5vbmVzKFt0aGlzLmlucHV0QXRsYXMuc2hhcGVbMF0sIDFdKTtcbiAgfVxuXG4gIGdlbmVyYXRlV2VpZ2h0cyhuZXVyb25zUGVyTGF5ZXI6IG51bWJlciwgd2VpZ2h0c1N0ZGV2OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW50ZXJtZWRpYXRlV2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnRlcm1lZGlhdGVXZWlnaHRzW2ldLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm1lZGlhdGVXZWlnaHRzID0gW107XG4gICAgaWYgKHRoaXMuZmlyc3RMYXllcldlaWdodHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maXJzdExheWVyV2VpZ2h0cy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RMYXllcldlaWdodHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0TGF5ZXJXZWlnaHRzLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0TGF5ZXJXZWlnaHRzID0gZGwudHJ1bmNhdGVkTm9ybWFsKFxuICAgICAgICBbTlVNX0lNQUdFX1NQQUNFX1ZBUklBQkxFUyArIE5VTV9MQVRFTlRfVkFSSUFCTEVTLCBuZXVyb25zUGVyTGF5ZXJdLCAwLFxuICAgICAgICB3ZWlnaHRzU3RkZXYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0xBWUVSUzsgaSsrKSB7XG4gICAgICB0aGlzLmludGVybWVkaWF0ZVdlaWdodHMucHVzaChkbC50cnVuY2F0ZWROb3JtYWwoXG4gICAgICAgICAgW25ldXJvbnNQZXJMYXllciwgbmV1cm9uc1BlckxheWVyXSwgMCwgd2VpZ2h0c1N0ZGV2KSk7XG4gICAgfVxuICAgIHRoaXMubGFzdExheWVyV2VpZ2h0cyA9IGRsLkFycmF5MkQucmFuZFRydW5jYXRlZE5vcm1hbChcbiAgICAgICAgW25ldXJvbnNQZXJMYXllciwgMSAvKiogbWF4IG91dHB1dCBjaGFubmVscyAqL10sIDAsIHdlaWdodHNTdGRldik7XG4gIH1cblxuICBzZXRBY3RpdmF0aW9uRnVuY3Rpb24oYWN0aXZhdGlvbkZ1bmN0aW9uOiBBY3RpdmF0aW9uRnVuY3Rpb24pIHtcbiAgICB0aGlzLnNlbGVjdGVkQWN0aXZhdGlvbkZ1bmN0aW9uTmFtZSA9IGFjdGl2YXRpb25GdW5jdGlvbjtcbiAgfVxuXG4gIHNldE51bUxheWVycyhudW1MYXllcnM6IG51bWJlcikge1xuICAgIHRoaXMubnVtTGF5ZXJzID0gbnVtTGF5ZXJzO1xuICB9XG5cbiAgc2V0WjFTY2FsZSh6MVNjYWxlOiBudW1iZXIpIHtcbiAgICB0aGlzLnoxU2NhbGUgPSB6MVNjYWxlO1xuICB9XG5cbiAgc2V0WjJTY2FsZSh6MlNjYWxlOiBudW1iZXIpIHtcbiAgICB0aGlzLnoyU2NhbGUgPSB6MlNjYWxlO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5pc0luZmVycmluZyA9IHRydWU7XG4gICAgdGhpcy5ydW5JbmZlcmVuY2VMb29wKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJ1bkluZmVyZW5jZUxvb3AoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy56MUNvdW50ZXIgKz0gMSAvIHRoaXMuejFTY2FsZTtcbiAgICB0aGlzLnoyQ291bnRlciArPSAxIC8gdGhpcy56MlNjYWxlO1xuXG4gICAgY29uc3QgbGFzdE91dHB1dCA9IG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgY29uc3QgejEgPSBkbC5TY2FsYXIubmV3KE1hdGguc2luKHRoaXMuejFDb3VudGVyKSk7XG4gICAgICBjb25zdCB6MiA9IGRsLlNjYWxhci5uZXcoTWF0aC5jb3ModGhpcy56MkNvdW50ZXIpKTtcbiAgICAgIGNvbnN0IHoxTWF0ID0gejEubXVsKHRoaXMub25lcykgYXMgZGwuQXJyYXkyRDtcbiAgICAgIGNvbnN0IHoyTWF0ID0gejIubXVsKHRoaXMub25lcykgYXMgZGwuQXJyYXkyRDtcblxuICAgICAgY29uc3QgY29uY2F0QXhpcyA9IDE7XG4gICAgICBjb25zdCBsYXRlbnRWYXJzID0gejFNYXQuY29uY2F0KHoyTWF0LCBjb25jYXRBeGlzKTtcblxuICAgICAgY29uc3QgYWN0aXZhdGlvbiA9ICh4OiBkbC5BcnJheTJEKSA9PlxuICAgICAgICAgIGFjdGl2YXRpb25GdW5jdGlvbk1hcFt0aGlzLnNlbGVjdGVkQWN0aXZhdGlvbkZ1bmN0aW9uTmFtZV0oeCk7XG5cbiAgICAgIGxldCBsYXN0T3V0cHV0ID0gdGhpcy5pbnB1dEF0bGFzLmNvbmNhdChsYXRlbnRWYXJzLCBjb25jYXRBeGlzKTtcbiAgICAgIGxhc3RPdXRwdXQgPSBhY3RpdmF0aW9uKGxhc3RPdXRwdXQubWF0TXVsKHRoaXMuZmlyc3RMYXllcldlaWdodHMpKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUxheWVyczsgaSsrKSB7XG4gICAgICAgIGxhc3RPdXRwdXQgPSBhY3RpdmF0aW9uKGxhc3RPdXRwdXQubWF0TXVsKHRoaXMuaW50ZXJtZWRpYXRlV2VpZ2h0c1tpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFzdE91dHB1dC5tYXRNdWwodGhpcy5sYXN0TGF5ZXJXZWlnaHRzKS5zaWdtb2lkKCkucmVzaGFwZShbXG4gICAgICAgIHRoaXMuaW5mZXJlbmNlQ2FudmFzLmhlaWdodCwgdGhpcy5pbmZlcmVuY2VDYW52YXMud2lkdGgsIDFcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgcmVuZGVyVG9DYW52YXMobGFzdE91dHB1dCBhcyBkbC5BcnJheTNELCB0aGlzLmluZmVyZW5jZUNhbnZhcyk7XG4gICAgYXdhaXQgZGwudXRpbC5uZXh0RnJhbWUoKTtcbiAgICB0aGlzLnJ1bkluZmVyZW5jZUxvb3AoKTtcbiAgfVxuXG4gIHN0b3BJbmZlcmVuY2VMb29wKCkge1xuICAgIHRoaXMuaXNJbmZlcnJpbmcgPSBmYWxzZTtcbiAgfVxufVxuXG4vLyBUT0RPKG5zdGhvcmF0KTogTW92ZSB0aGlzIHRvIGEgY29yZSBsaWJyYXJ5IHV0aWwuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJUb0NhbnZhcyhhOiBkbC5BcnJheTNELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gIGNvbnN0IFtoZWlnaHQsIHdpZHRoLCBdID0gYS5zaGFwZTtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBhLmRhdGEoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDsgKytpKSB7XG4gICAgY29uc3QgaiA9IGkgKiA0O1xuICAgIC8vY29uc3QgayA9IGkgKiAzO1xuICAgIGNvbnN0IGsgPSBpO1xuICAgIGNvbnN0IGdyYXkgPSBNYXRoLnJvdW5kKDI1NSAqIGRhdGFba10pO1xuICAgIC8vaW1hZ2VEYXRhLmRhdGFbaiArIDBdID0gTWF0aC5yb3VuZCgyNTUgKiBkYXRhW2sgKyAwXSk7XG4gICAgLy9pbWFnZURhdGEuZGF0YVtqICsgMV0gPSBNYXRoLnJvdW5kKDI1NSAqIGRhdGFbayArIDFdKTtcbiAgICAvL2ltYWdlRGF0YS5kYXRhW2ogKyAyXSA9IE1hdGgucm91bmQoMjU1ICogZGF0YVtrICsgMl0pO1xuICAgIGltYWdlRGF0YS5kYXRhW2ogKyAwXSA9IGdyYXk7XG4gICAgaW1hZ2VEYXRhLmRhdGFbaiArIDFdID0gZ3JheTtcbiAgICBpbWFnZURhdGEuZGF0YVtqICsgMl0gPSBncmF5O1xuICAgIGltYWdlRGF0YS5kYXRhW2ogKyAzXSA9IDI1NTtcbiAgfVxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7UG9seW1lckVsZW1lbnQsIFBvbHltZXJIVE1MRWxlbWVudH0gZnJvbSAnLi4vcG9seW1lci1zcGVjJztcbmltcG9ydCB7QWN0aXZhdGlvbkZ1bmN0aW9uLCBDUFBOfSBmcm9tICcuL2NwcG4nO1xuXG4vLyBjb25zdCBDQU5WQVNfVVBTQ0FMRV9GQUNUT1IgPSAxO1xuLy8gY29uc3QgTUFUX1dJRFRIID0gNDA7XG4vLyBTdGFuZGFyZCBkZXZpYXRpb25zIGZvciBnYXVzc2lhbiB3ZWlnaHQgaW5pdGlhbGl6YXRpb24uXG5jb25zdCBXRUlHSFRTX1NUREVWID0gLjc1O1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuY29uc3QgTk5BcnRQb2x5bWVyOiBuZXcgKCkgPT4gUG9seW1lckhUTUxFbGVtZW50ID0gUG9seW1lckVsZW1lbnQoe1xuICBpczogJ25uLWFydCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhY3RpdmF0aW9uRnVuY3Rpb25OYW1lczogQXJyYXksXG4gICAgc2VsZWN0ZWRBY3RpdmF0aW9uRnVuY3Rpb25OYW1lOiBTdHJpbmdcbiAgfVxufSk7XG5cbmNsYXNzIE5OQXJ0IGV4dGVuZHMgTk5BcnRQb2x5bWVyIHtcbiAgLy8gUG9seW1lciBwcm9wZXJ0aWVzLlxuICBhY3RpdmF0aW9uRnVuY3Rpb25OYW1lczogQWN0aXZhdGlvbkZ1bmN0aW9uW107XG4gIHNlbGVjdGVkQWN0aXZhdGlvbkZ1bmN0aW9uTmFtZTogQWN0aXZhdGlvbkZ1bmN0aW9uO1xuXG4gIHByaXZhdGUgY3BwbjogQ1BQTjtcblxuICBwcml2YXRlIGluZmVyZW5jZUNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgcHJpdmF0ZSB6MVNjYWxlOiBudW1iZXI7XG4gIHByaXZhdGUgejJTY2FsZTogbnVtYmVyO1xuICBwcml2YXRlIG51bUxheWVyczogbnVtYmVyO1xuXG4gIHJlYWR5KCkge1xuICAgIHRoaXMuaW5mZXJlbmNlQ2FudmFzID1cbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjaW5mZXJlbmNlJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICB0aGlzLmluZmVyZW5jZUNhbnZhcy5zdHlsZS53aWR0aCA9IGAke3dpbmRvdy5pbm5lcldpZHRofXB4YDtcbiAgICB0aGlzLmluZmVyZW5jZUNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtNYXRoLnJvdW5kKHdpbmRvdy5pbm5lckhlaWdodC8yKX1weGA7XG5cbiAgICB0aGlzLmNwcG4gPSBuZXcgQ1BQTih0aGlzLmluZmVyZW5jZUNhbnZhcyk7XG5cbiAgICAvL3RoaXMuaW5mZXJlbmNlQ2FudmFzLnN0eWxlLndpZHRoID1cbiAgICAvLyAgICBgJHt0aGlzLmluZmVyZW5jZUNhbnZhcy53aWR0aCAqIDYgKiBDQU5WQVNfVVBTQ0FMRV9GQUNUT1J9cHhgO1xuICAgIC8vdGhpcy5pbmZlcmVuY2VDYW52YXMuc3R5bGUuaGVpZ2h0ID1cbiAgICAvLyAgICBgJHt0aGlzLmluZmVyZW5jZUNhbnZhcy5oZWlnaHQgKiAyICogQ0FOVkFTX1VQU0NBTEVfRkFDVE9SfXB4YDtcblxuICAgIHRoaXMuYWN0aXZhdGlvbkZ1bmN0aW9uTmFtZXMgPSBbJ3RhbmgnLCAnc2luJywgJ3JlbHUnLCAnc3RlcCddO1xuICAgIHRoaXMuc2VsZWN0ZWRBY3RpdmF0aW9uRnVuY3Rpb25OYW1lID0gJ3RhbmgnO1xuICAgIHRoaXMuY3Bwbi5zZXRBY3RpdmF0aW9uRnVuY3Rpb24odGhpcy5zZWxlY3RlZEFjdGl2YXRpb25GdW5jdGlvbk5hbWUpO1xuICAgIHRoaXMucXVlcnlTZWxlY3RvcignI2FjdGl2YXRpb24tZnVuY3Rpb24tZHJvcGRvd24nKSEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAnaXJvbi1hY3RpdmF0ZScsIChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEFjdGl2YXRpb25GdW5jdGlvbk5hbWUgPSBldmVudC5kZXRhaWwuc2VsZWN0ZWQ7XG4gICAgICAgICAgdGhpcy5jcHBuLnNldEFjdGl2YXRpb25GdW5jdGlvbih0aGlzLnNlbGVjdGVkQWN0aXZhdGlvbkZ1bmN0aW9uTmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgbGF5ZXJzU2xpZGVyID1cbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjbGF5ZXJzLXNsaWRlcicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgbGF5ZXJzQ291bnRFbGVtZW50ID1cbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjbGF5ZXJzLWNvdW50JykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgbGF5ZXJzU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ltbWVkaWF0ZS12YWx1ZS1jaGFuZ2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICB0aGlzLm51bUxheWVycyA9IHBhcnNlSW50KChldmVudCBhcyBhbnkpLnRhcmdldC5pbW1lZGlhdGVWYWx1ZSwgMTApO1xuICAgICAgbGF5ZXJzQ291bnRFbGVtZW50LmlubmVyVGV4dCA9IHRoaXMubnVtTGF5ZXJzLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmNwcG4uc2V0TnVtTGF5ZXJzKHRoaXMubnVtTGF5ZXJzKTtcbiAgICB9KTtcbiAgICB0aGlzLm51bUxheWVycyA9IHBhcnNlSW50KGxheWVyc1NsaWRlci52YWx1ZSwgMTApO1xuICAgIGxheWVyc0NvdW50RWxlbWVudC5pbm5lclRleHQgPSB0aGlzLm51bUxheWVycy50b1N0cmluZygpO1xuICAgIHRoaXMuY3Bwbi5zZXROdW1MYXllcnModGhpcy5udW1MYXllcnMpO1xuXG4gICAgY29uc3QgbmV1cm9uc1NsaWRlciA9XG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcignI25ldXJvbnMtc2xpZGVyJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBuZXVyb25zQ291bnRFbGVtZW50ID1cbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjbmV1cm9ucy1jb3VudCcpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIG5ldXJvbnNTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignaW1tZWRpYXRlLXZhbHVlLWNoYW5nZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIHRoaXMuTUFUX1dJRFRIID0gcGFyc2VJbnQoKGV2ZW50IGFzIGFueSkudGFyZ2V0LmltbWVkaWF0ZVZhbHVlLCAxMCk7XG4gICAgICBuZXVyb25zQ291bnRFbGVtZW50LmlubmVyVGV4dCA9IHRoaXMuTUFUX1dJRFRILnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmNwcG4uZ2VuZXJhdGVXZWlnaHRzKHRoaXMuTUFUX1dJRFRILCBXRUlHSFRTX1NUREVWKTtcbiAgICB9KTtcbiAgICB0aGlzLk1BVF9XSURUSCA9IHBhcnNlSW50KG5ldXJvbnNTbGlkZXIudmFsdWUsIDEwKTtcbiAgICBuZXVyb25zQ291bnRFbGVtZW50LmlubmVyVGV4dCA9IHRoaXMuTUFUX1dJRFRILnRvU3RyaW5nKCk7XG5cbiAgICB0aGlzLnoxU2NhbGUgPSAxMDtcbiAgICB0aGlzLmNwcG4uc2V0WjFTY2FsZShjb252ZXJ0WlNjYWxlKHRoaXMuejFTY2FsZSkpO1xuXG4gICAgdGhpcy56MlNjYWxlID0gMTA7XG4gICAgdGhpcy5jcHBuLnNldFoyU2NhbGUoY29udmVydFpTY2FsZSh0aGlzLnoyU2NhbGUpKTtcblxuICAgIC8vY29uc3QgcmFuZG9taXplQnV0dG9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcjcmFuZG9tJylcbiAgICAvLyBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICAvL3JhbmRvbWl6ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIC8vdGhpcy5jcHBuLmdlbmVyYXRlV2VpZ2h0cyhNQVRfV0lEVEgsIFdFSUdIVFNfU1RERVYpO1xuICAgIC8vfSk7XG5cbiAgICB0aGlzLmNwcG4uZ2VuZXJhdGVXZWlnaHRzKHRoaXMuTUFUX1dJRFRILCBXRUlHSFRTX1NUREVWKTtcbiAgICB0aGlzLmNwcG4uc3RhcnQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0WlNjYWxlKHo6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoMTAzIC0geik7XG59XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChOTkFydC5wcm90b3R5cGUuaXMsIE5OQXJ0KTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgZGwgZnJvbSAnZGVlcGxlYXJuJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0QXRsYXMoXG4gICAgaW1hZ2VXaWR0aDogbnVtYmVyLCBpbWFnZUhlaWdodDogbnVtYmVyLCBcbiAgICBpbnB1dE51bURpbWVuc2lvbnM6IG51bWJlciwgbnVtTGF0ZW50VmFyaWFibGVzOiBudW1iZXIpIHtcbiAgY29uc3QgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShpbWFnZVdpZHRoICogaW1hZ2VIZWlnaHQgXG4gICAgKiBpbnB1dE51bURpbWVuc2lvbnMpO1xuICBsZXQgZHN0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZVdpZHRoICogaW1hZ2VIZWlnaHQ7IGkrKykge1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgaW5wdXROdW1EaW1lbnNpb25zOyBkKyspIHtcbiAgICAgIGNvbnN0IHggPSBpICUgaW1hZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGkgLyBpbWFnZVdpZHRoKTtcbiAgICAgIGNvbnN0IGNvb3JkID0gaW1hZ2VQaXhlbFRvTm9ybWFsaXplZENvb3JkKFxuICAgICAgICAgIHgsIHksIGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBudW1MYXRlbnRWYXJpYWJsZXMpO1xuICAgICAgY29vcmRzW2RzdCsrXSA9IGNvb3JkW2RdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkbC5BcnJheTJELm5ldyhbaW1hZ2VXaWR0aCAqIGltYWdlSGVpZ2h0LCBcbiAgICBpbnB1dE51bURpbWVuc2lvbnNdLCBjb29yZHMpO1xufVxuXG4vLyBOb3JtYWxpemVzIHgsIHkgdG8gLS41IDw9PiArLjUsIGFkZHMgYSByYWRpdXMgdGVybSwgYW5kIHBhZHMgemVyb3Mgd2l0aCB0aGVcbi8vIG51bWJlciBvZiB6IHBhcmFtZXRlcnMgdGhhdCB3aWxsIGdldCBhZGRlZCBieSB0aGUgYWRkIHogc2hhZGVyLlxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlUGl4ZWxUb05vcm1hbGl6ZWRDb29yZChcbiAgICB4OiBudW1iZXIsIHk6IG51bWJlciwgaW1hZ2VXaWR0aDogbnVtYmVyLCBpbWFnZUhlaWdodDogbnVtYmVyLFxuICAgIHpTaXplOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IGhhbGZXaWR0aCA9IGltYWdlV2lkdGggKiAwLjU7XG4gIGNvbnN0IGhhbGZIZWlnaHQgPSBpbWFnZUhlaWdodCAqIDAuNTtcbiAgY29uc3Qgbm9ybVggPSAoeCAtIGhhbGZXaWR0aCkgLyBpbWFnZVdpZHRoO1xuICBjb25zdCBub3JtWSA9ICh5IC0gaGFsZkhlaWdodCkgLyBpbWFnZUhlaWdodDtcblxuICBjb25zdCByID0gTWF0aC5zcXJ0KG5vcm1YICogbm9ybVggKyBub3JtWSAqIG5vcm1ZKTtcblxuICBjb25zdCByZXN1bHQgPSBbbm9ybVgsIG5vcm1ZLCByXTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBNQU5JRkVTVF9GSUxFID0gJ21hbmlmZXN0Lmpzb24nO1xudmFyIENoZWNrcG9pbnRMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoZWNrcG9pbnRMb2FkZXIodXJsUGF0aCkge1xuICAgICAgICB0aGlzLnVybFBhdGggPSB1cmxQYXRoO1xuICAgICAgICBpZiAodGhpcy51cmxQYXRoLmNoYXJBdCh0aGlzLnVybFBhdGgubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy51cmxQYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgX3RoaXMudXJsUGF0aCArIE1BTklGRVNUX0ZJTEUpO1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQU5JRkVTVF9GSUxFICsgXCIgbm90IGZvdW5kIGF0IFwiICsgX3RoaXMudXJsUGF0aCArIFwiLiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldENoZWNrcG9pbnRNYW5pZmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXNvbHZlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0QWxsVmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuZ2V0Q2hlY2twb2ludE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoY2hlY2twb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVQcm9taXNlcy5wdXNoKF90aGlzLmdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFyaWFibGVQcm9taXNlcykudGhlbihmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzW3ZhcmlhYmxlTmFtZXNbaV1dID0gdmFyaWFibGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEodmFyTmFtZSBpbiB0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgbm9uLWV4aXN0YW50IHZhcmlhYmxlICcgKyB2YXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLmZpbGVuYW1lO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIF90aGlzLnVybFBhdGggKyBmbmFtZSk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGZvdW5kIHZhcmlhYmxlIFwiICsgdmFyTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5zaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5kYXJyYXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZldGNoIHZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UodmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGVja3BvaW50TG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuQ2hlY2twb2ludExvYWRlciA9IENoZWNrcG9pbnRMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3BvaW50X2xvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBTVEFUU19TQU1QTEVfUEVSQ0VOVEFHRSA9IDAuMTtcbnZhciBJbk1lbW9yeURhdGFzZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5RGF0YXNldChkYXRhU2hhcGVzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNoYXBlcyA9IGRhdGFTaGFwZXM7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm8gPSB7fTtcbiAgICB9XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXREYXRhU2hhcGUgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTaGFwZXNbZGF0YUluZGV4XTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdldFN0YXRzRm9yRGF0YShkKTsgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldFN0YXRzRm9yRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpbnB1dE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIGlucHV0TWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgZXhhbXBsZUluZGljZXMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZXhhbXBsZSwgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgICAgIHV0aWwuc2h1ZmZsZShleGFtcGxlSW5kaWNlcyk7XG4gICAgICAgIGV4YW1wbGVJbmRpY2VzID1cbiAgICAgICAgICAgIGV4YW1wbGVJbmRpY2VzLnNsaWNlKGV4YW1wbGVJbmRpY2VzLmxlbmd0aCAqIFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGFtcGxlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZGF0YVtleGFtcGxlSW5kaWNlc1tpXV0uZGF0YVN5bmMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRWYWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1pbiA9IE1hdGgubWluKGlucHV0TWluLCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRNYXggPSBNYXRoLm1heChpbnB1dE1heCwgaW5wdXRWYWx1ZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dE1pbjogaW5wdXRNaW4sXG4gICAgICAgICAgICBpbnB1dE1heDogaW5wdXRNYXgsXG4gICAgICAgICAgICBleGFtcGxlQ291bnQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgc2hhcGU6IGRhdGFbMF0uc2hhcGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZSA9IGZ1bmN0aW9uIChleGFtcGxlcywgY3VyTG93ZXJCb3VuZHMsIGN1clVwcGVyQm91bmRzLCBuZXdMb3dlckJvdW5kcywgbmV3VXBwZXJCb3VuZHMpIHtcbiAgICAgICAgdmFyIGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID0gKGN1clVwcGVyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIHZhciBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA9IChuZXdMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJlxuICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpO1xuICAgICAgICB2YXIgaW5wdXRTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGV4YW1wbGVzWzBdLnNoYXBlKTtcbiAgICAgICAgdmFyIG5ld0V4YW1wbGVzID0gW107XG4gICAgICAgIGV4YW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKGV4YW1wbGUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlcyA9IGV4YW1wbGUuZGF0YVN5bmMoKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShpbnB1dFNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJMb3dlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJVcHBlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1clVwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJSYW5nZSA9IGN1clVwcGVyQm91bmQgLSBjdXJMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIHZhciBuZXdMb3dlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdVcHBlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IG5ld1VwcGVyQm91bmQgLSBuZXdMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXJSYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlICogKGlucHV0VmFsdWVzW2pdIC0gY3VyTG93ZXJCb3VuZCkgLyBjdXJSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdFeGFtcGxlcy5wdXNoKG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoZXhhbXBsZS5zaGFwZSwgeyB2YWx1ZXM6IG5vcm1hbGl6ZWRWYWx1ZXMgfSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3RXhhbXBsZXM7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmNvbXB1dGVCb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5kYXRhc2V0W2RhdGFJbmRleF1bMF0uc2hhcGUpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPSB7XG4gICAgICAgICAgICBpc05vcm1hbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWluVmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1tpXSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChleGFtcGxlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdID0gTWF0aC5taW4oX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1trXSA9IE1hdGgubWF4KF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5ub3JtYWxpemVXaXRoaW5Cb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFJbmRleCA+PSB0aGlzLmRhdGFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGFJbmRleCBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRzKGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICB2YXIgY3VyVXBwZXJCb3VuZHM7XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kO1xuICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcztcbiAgICAgICAgICAgIGN1clVwcGVyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSA9IHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmlzTm9ybWFsaXplZCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkluZm8gIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUucmVtb3ZlTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYWluaW5nIG9yIHRlc3QgZGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UodGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcyk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUudW5ub3JtYWxpemVFeGFtcGxlcyA9IGZ1bmN0aW9uIChleGFtcGxlcywgZGF0YUluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShleGFtcGxlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhc2V0W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0W2ldW2pdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeURhdGFzZXQ7XG59KCkpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBJbk1lbW9yeURhdGFzZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhc2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoaW5wdXRzKSB7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5lcG9jaCA9IDA7XG4gICAgICAgIHRoaXMuc2h1ZmZsZWRJbmRpY2VzID0gdXRpbC5jcmVhdGVTaHVmZmxlZEluZGljZXMoaW5wdXRzWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubnVtSW5wdXRzID0gaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG51bUV4YW1wbGVzID0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuaW5wdXRzW2ldLmxlbmd0aCA9PT0gbnVtRXhhbXBsZXMsICdOdW1iZXIgb2YgZXhhbXBsZXMgbXVzdCBtYXRjaCBhY3Jvc3MgZGlmZmVyZW50IGlucHV0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gdGhpcy5pbnB1dHNbaV1bMF0uc2hhcGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW5wdXRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChpbnB1dFNoYXBlLCB0aGlzLmlucHV0c1tpXVtqXS5zaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRDdXJyZW50RXhhbXBsZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0dXJuSWR4ID0gdGhpcy5pZHg7XG4gICAgICAgIHRoaXMuaW5wdXRDb3VudGVyKys7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Q291bnRlciA+PSB0aGlzLm51bUlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5pZHgrKztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCA+PSB0aGlzLmlucHV0c1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5JZHg7XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldE5leHRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dElkKSB7XG4gICAgICAgIHZhciBjdXJyZW50RXhhbXBsZUluZGV4ID0gdGhpcy5nZXRDdXJyZW50RXhhbXBsZUluZGV4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0c1tpbnB1dElkXVt0aGlzLnNodWZmbGVkSW5kaWNlc1tjdXJyZW50RXhhbXBsZUluZGV4XV07XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldEVwb2NoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcG9jaDtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRQcm92aWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dFByb3ZpZGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgICAgICAgIGlucHV0UHJvdmlkZXJzLnB1c2godGhpcy5nZXRJbnB1dFByb3ZpZGVyKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRQcm92aWRlcnM7XG4gICAgfTtcbiAgICByZXR1cm4gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xudmFyIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVyID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIHNodWZmbGVkSW5wdXRQcm92aWRlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROZXh0Q29weTogZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubGlrZShzaHVmZmxlZElucHV0UHJvdmlkZXIuZ2V0TmV4dElucHV0KGlucHV0SWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKG1hdGgsIGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXIgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5leHRDb3B5OiBmdW5jdGlvbiAobWF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRoLmNsb25lKHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3Bvc2VDb3B5OiBmdW5jdGlvbiAobWF0aCwgY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbn0oSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKSk7XG5leHBvcnRzLkluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0X3Byb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YXNldFwiKTtcbnZhciBQQVJTSU5HX0lNQUdFX0NBTlZBU19IRUlHSFRfUFggPSAxMDAwO1xuZnVuY3Rpb24gZ2V0WGhyRGF0YXNldENvbmZpZyhqc29uQ29uZmlnUGF0aCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGpzb25Db25maWdQYXRoKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRYaHJEYXRhc2V0Q29uZmlnID0gZ2V0WGhyRGF0YXNldENvbmZpZztcbnZhciBYaHJEYXRhc2V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWGhyRGF0YXNldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYaHJEYXRhc2V0KHhockRhdGFzZXRDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeGhyRGF0YXNldENvbmZpZy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhockRhdGFzZXRDb25maWcgPSB4aHJEYXRhc2V0Q29uZmlnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhockRhdGFzZXQucHJvdG90eXBlLmdldE5EQXJyYXkgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICB2YXIgZGF0YVByb21pc2UgPSBpbmZvLmRhdGFUeXBlID09PSAncG5nJyA/XG4gICAgICAgICAgICBwYXJzZVR5cGVkQXJyYXlGcm9tUG5nKGluZm8sIGluZm8uc2hhcGUpIDpcbiAgICAgICAgICAgIHBhcnNlVHlwZWRBcnJheUZyb21CaW5hcnkoaW5mbyk7XG4gICAgICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5mby5zaGFwZSk7XG4gICAgICAgIHJldHVybiBkYXRhUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbmRhcnJheXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLyBpbnB1dFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLnN1YmFycmF5KGkgKiBpbnB1dFNpemUsIChpICsgMSkgKiBpbnB1dFNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5ID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZShpbmZvLnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMpIH0sICdmbG9hdDMyJyk7XG4gICAgICAgICAgICAgICAgbmRhcnJheXMucHVzaChuZGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBYaHJEYXRhc2V0LnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfdGhpcy54aHJEYXRhc2V0Q29uZmlnLmRhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5nZXROREFycmF5KHgpOyB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YXNldCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFhockRhdGFzZXQ7XG59KGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQpKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IFhockRhdGFzZXQ7XG5mdW5jdGlvbiBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBpbmZvLnBhdGgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAoaW5mby5kYXRhVHlwZSA9PT0gJ2Zsb2F0MzInKSA/XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpIDpcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgcmVzdWx0T2Zmc2V0KSB7XG4gICAgdmFyIGlkeCA9IHJlc3VsdE9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0W2lkeCsrXSA9IGRhdGFbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCByZXN1bHRPZmZzZXQpIHtcbiAgICB2YXIgaWR4ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGRhdGFbaV07XG4gICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGRhdGFbaSArIDFdO1xuICAgICAgICByZXN1bHRbaWR4ICsgMl0gPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWR4ICs9IDM7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbWFnZShpbWcsIHNoYXBlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgTiA9IGltZy5oZWlnaHQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE4gKiBpbnB1dFNpemUpO1xuICAgIGlmIChpbWcud2lkdGggIT09IHNoYXBlWzBdICogc2hhcGVbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugd2lkdGggKFwiICsgaW1nLndpZHRoICsgXCIpIG11c3QgYmUgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwicm93cypjb2x1bW5zIChcIiArIHNoYXBlWzBdICsgXCIqXCIgKyBzaGFwZVsxXSArIFwiKSBvZiB0aGUgbmRhcnJheVwiKSk7XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gUEFSU0lOR19JTUFHRV9DQU5WQVNfSEVJR0hUX1BYO1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdmFyIGR4ID0gMDtcbiAgICB2YXIgZHkgPSAwO1xuICAgIHZhciBkV2lkdGggPSBzV2lkdGg7XG4gICAgdmFyIGRIZWlnaHQgPSBzSGVpZ2h0O1xuICAgIHZhciBkZXB0aCA9IHNoYXBlWzJdO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBudW1QYXNzZXMgPSBNYXRoLmNlaWwoTiAvIGNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAodmFyIHBhc3MgPSAwOyBwYXNzIDwgbnVtUGFzc2VzOyArK3Bhc3MpIHtcbiAgICAgICAgdmFyIHN5ID0gcGFzcyAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmICgocGFzcyA9PT0gbnVtUGFzc2VzIC0gMSkgJiYgKE4gJSBjYW52YXMuaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBOICUgY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCBkeCwgZHksIGRXaWR0aCwgZEhlaWdodCk7XG4gICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgICAgIChkZXB0aCA9PT0gMSkgPyBwYXJzZUdyYXlzY2FsZUltYWdlRGF0YShkYXRhLCByZXN1bHQsIG9mZnNldCkgOlxuICAgICAgICAgICAgcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2FudmFzLmhlaWdodCAqIGlucHV0U2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVHlwZWRBcnJheUZyb21QbmcoaW5mbywgc2hhcGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2Nyb3NzT3JpZ2luJywgJycpO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW1hZ2UoaW1nLCBzaGFwZSk7XG4gICAgICAgICAgICBpbWcuc3JjID0gJyc7XG4gICAgICAgICAgICBpbWcgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gaW5mby5wYXRoO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLWRhdGFzZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgICB2YXIgYSA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gICAgcmV0dXJuIC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaVxuICAgICAgICAudGVzdChhKSB8fFxuICAgICAgICAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaVxuICAgICAgICAgICAgLnRlc3QoYS5zdWJzdHIoMCwgNCkpO1xufVxuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2aWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGV2aWNlX3V0aWwgPSByZXF1aXJlKFwiLi9kZXZpY2VfdXRpbFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk5VTUJFUlwiXSA9IDBdID0gXCJOVU1CRVJcIjtcbiAgICBUeXBlW1R5cGVbXCJCT09MRUFOXCJdID0gMV0gPSBcIkJPT0xFQU5cIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5leHBvcnRzLlVSTF9QUk9QRVJUSUVTID0gW1xuICAgIHsgbmFtZTogJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sIHtcbiAgICAgICAgbmFtZTogJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnLFxuICAgICAgICB0eXBlOiBUeXBlLkJPT0xFQU5cbiAgICB9XG5dO1xuZnVuY3Rpb24gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gICAgdmFyIHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiAodGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XG4gICAgICAgICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG59XG5mdW5jdGlvbiBsb3NlQ29udGV4dChnbCkge1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb3NlQ29udGV4dEV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIGlmIChsb3NlQ29udGV4dEV4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBXRUJHTF9sb3NlX2NvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dlYkdMVmVyc2lvbkVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNXZWJHTERpc2pvaW50UXVlcnlUaW1lckVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgdmFyIGV4dGVuc2lvbk5hbWUgPSB3ZWJHTFZlcnNpb24gPT09IDEgPyAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyA6XG4gICAgICAgICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJztcbiAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICAgIHZhciBpc0V4dEVuYWJsZWQgPSBleHQgIT0gbnVsbDtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgfVxuICAgIHJldHVybiBpc0V4dEVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGlmIChnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gd2ViR0xWZXJzaW9uID09PSAyID8gZ2wuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdmFyIGZyYW1lQnVmZmVyQ29tcGxldGUgPSAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIGdsLlJHQkEsIGdsLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbiAgICB2YXIgcmVhZFBpeGVsc05vRXJyb3IgPSBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGZyYW1lQnVmZmVyQ29tcGxldGUgJiYgcmVhZFBpeGVsc05vRXJyb3I7XG59XG5mdW5jdGlvbiBpc1dlYkdMR2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgIHZhciBpc0VuYWJsZWQgPSBleHQgIT0gbnVsbDtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGlzRW5hYmxlZDtcbn1cbnZhciBFbnZpcm9ubWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW52aXJvbm1lbnQoZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmdsb2JhbE1hdGggPSBudWxsO1xuICAgICAgICB0aGlzLkJBQ0tFTkRfUkVHSVNUUlkgPSB7fTtcbiAgICAgICAgdGhpcy5iYWNrZW5kcyA9IHRoaXMuQkFDS0VORF9SRUdJU1RSWTtcbiAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgaW4gdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWF0dXJlc1tmZWF0dXJlXSA9IHRoaXMuZXZhbHVhdGVGZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5nZXRCZXN0QmFja2VuZFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmRlcmVkQmFja2VuZHMgPSBbJ3dlYmdsJywgJ2NwdSddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRCYWNrZW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJhY2tlbmRJZCA9IG9yZGVyZWRCYWNrZW5kc1tpXTtcbiAgICAgICAgICAgIGlmIChiYWNrZW5kSWQgaW4gdGhpcy5iYWNrZW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYWNrZW5kSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBiYWNrZW5kIGZvdW5kIGluIHJlZ2lzdHJ5LicpO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmV2YWx1YXRlRmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICB2YXIgd2ViR0xWZXJzaW9uID0gdGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICAgICAgICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNXZWJHTERpc2pvaW50UXVlcnlUaW1lckVuYWJsZWQod2ViR0xWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcpICYmXG4gICAgICAgICAgICAgICAgIWRldmljZV91dGlsLmlzTW9iaWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX1ZFUlNJT04nKSB7XG4gICAgICAgICAgICBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZCh0aGlzLmdldCgnV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1dlYkdMR2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uRW5hYmxlZCh0aGlzLmdldCgnV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZlYXR1cmUgXCIgKyBmZWF0dXJlICsgXCIuXCIpO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnNldEZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICB0aGlzLmJhY2tlbmRzID0ge307XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBnZXRGZWF0dXJlc0Zyb21VUkwoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsTWF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbE1hdGguZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxNYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWNrZW5kcyAhPT0gdGhpcy5CQUNLRU5EX1JFR0lTVFJZKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdGhpcy5iYWNrZW5kcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja2VuZHNbbmFtZV8xXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmRzID0gdGhpcy5CQUNLRU5EX1JFR0lTVFJZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuc2V0TWF0aCA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsTWF0aCA9IG1hdGg7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0QmFja2VuZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmRzW25hbWVdO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmFkZEN1c3RvbUJhY2tlbmQgPSBmdW5jdGlvbiAobmFtZSwgZmFjdG9yeSkge1xuICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmJhY2tlbmRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIGJhY2tlbmQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJhY2tlbmQgPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmRzW25hbWVdID0gYmFja2VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnJlZ2lzdGVyQmFja2VuZCA9IGZ1bmN0aW9uIChuYW1lLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChuYW1lIGluIHRoaXMuQkFDS0VORF9SRUdJU1RSWSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgZ2xvYmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmFja2VuZCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgIHRoaXMuQkFDS0VORF9SRUdJU1RSWVtuYW1lXSA9IGJhY2tlbmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwibWF0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsTWF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RCYWNrZW5kID0gdGhpcy5nZXRCZXN0QmFja2VuZFR5cGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2FmZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1hdGgobmV3IG1hdGhfMS5OREFycmF5TWF0aChiZXN0QmFja2VuZCwgc2FmZU1vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE1hdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwiZW5naW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxNYXRoLmVuZ2luZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEVudmlyb25tZW50O1xufSgpKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBFbnZpcm9ubWVudDtcbnZhciBERUVQTEVBUk5KU19GTEFHU19QUkVGSVggPSAnZGxqc2ZsYWdzJztcbmZ1bmN0aW9uIGdldEZlYXR1cmVzRnJvbVVSTCgpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0gdXRpbC5nZXRRdWVyeVBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBpZiAoREVFUExFQVJOSlNfRkxBR1NfUFJFRklYIGluIHVybFBhcmFtcykge1xuICAgICAgICB2YXIgdXJsRmxhZ3NfMSA9IHt9O1xuICAgICAgICB2YXIga2V5VmFsdWVzID0gdXJsUGFyYW1zW0RFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWF0uc3BsaXQoJywnKTtcbiAgICAgICAga2V5VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBrZXlWYWx1ZS5zcGxpdCgnOicpLCBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHVybEZsYWdzXzFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXhwb3J0cy5VUkxfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5Lm5hbWUgaW4gdXJsRmxhZ3NfMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSkpO1xuICAgICAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9ICt1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIFVSTCBwYXJhbTogXCIgKyB1cmxQcm9wZXJ0eS5uYW1lICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE5hbWVzcGFjZSgpIHtcbiAgICB2YXIgbnM7XG4gICAgaWYgKHR5cGVvZiAod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbnMgPSB3aW5kb3c7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZ2xvYmFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbnMgPSBnbG9iYWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnM7XG59XG5mdW5jdGlvbiBnZXRPck1ha2VFbnZpcm9ubWVudCgpIHtcbiAgICB2YXIgbnMgPSBnZXRHbG9iYWxOYW1lc3BhY2UoKTtcbiAgICBucy5FTlYgPSBucy5FTlYgfHwgbmV3IEVudmlyb25tZW50KGdldEZlYXR1cmVzRnJvbVVSTCgpKTtcbiAgICByZXR1cm4gbnMuRU5WO1xufVxuZXhwb3J0cy5FTlYgPSBnZXRPck1ha2VFbnZpcm9ubWVudCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52aXJvbm1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBUYW5IRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFuSEZ1bmMoKSB7XG4gICAgICAgIHRoaXMub25lID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSk7XG4gICAgfVxuICAgIFRhbkhGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC50YW5oKHgpO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5U3F1YXJlZCA9IG1hdGgubXVsdGlwbHlTdHJpY3QoeSwgeSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIHlTcXVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYW5IRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhbkhGdW5jO1xufSgpKTtcbmV4cG9ydHMuVGFuSEZ1bmMgPSBUYW5IRnVuYztcbnZhciBSZUxVRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVMVUZ1bmMoKSB7XG4gICAgfVxuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5yZWx1KHgpO1xuICAgIH07XG4gICAgUmVMVUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnN0ZXAoeCk7XG4gICAgfTtcbiAgICBSZUxVRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gUmVMVUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5SZUxVRnVuYyA9IFJlTFVGdW5jO1xudmFyIExlYWt5UmVsdUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlYWt5UmVsdUZ1bmMoYWxwaGEpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgICBMZWFreVJlbHVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5sZWFreVJlbHUoeCwgdGhpcy5hbHBoYSk7XG4gICAgfTtcbiAgICBMZWFreVJlbHVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zdGVwKHgsIHRoaXMuYWxwaGEpO1xuICAgIH07XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gTGVha3lSZWx1RnVuYztcbn0oKSk7XG5leHBvcnRzLkxlYWt5UmVsdUZ1bmMgPSBMZWFreVJlbHVGdW5jO1xudmFyIFNpZ21vaWRGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaWdtb2lkRnVuYygpIHtcbiAgICB9XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNpZ21vaWQoeCk7XG4gICAgfTtcbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHlTcXVhcmVkID0gbWF0aC5tdWx0aXBseVN0cmljdCh5LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh5LCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFNpZ21vaWRGdW5jO1xufSgpKTtcbmV4cG9ydHMuU2lnbW9pZEZ1bmMgPSBTaWdtb2lkRnVuYztcbnZhciBTcXVhcmVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVGdW5jKCkge1xuICAgICAgICB0aGlzLnR3byA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDIpO1xuICAgIH1cbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5tdWx0aXBseVN0cmljdCh4LCB4KTtcbiAgICB9O1xuICAgIFNxdWFyZUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLm11bHRpcGx5KHRoaXMudHdvLCB4KTtcbiAgICB9O1xuICAgIFNxdWFyZUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHdvLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBTcXVhcmVGdW5jO1xufSgpKTtcbmV4cG9ydHMuU3F1YXJlRnVuYyA9IFNxdWFyZUZ1bmM7XG52YXIgRWx1RnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWx1RnVuYygpIHtcbiAgICB9XG4gICAgRWx1RnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguZWx1KHgpO1xuICAgIH07XG4gICAgRWx1RnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIEVsdUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEVsdUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5FbHVGdW5jID0gRWx1RnVuYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2YXRpb25fZnVuY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEdyYXBoTGF5ZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaExheWVycyhnKSB7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgfVxuICAgIEdyYXBoTGF5ZXJzLnByb3RvdHlwZS5kZW5zZSA9IGZ1bmN0aW9uIChuYW1lLCB4LCB1bml0cywgYWN0aXZhdGlvbiwgdXNlQmlhcywga2VybmVsSW5pdGlhbGl6ZXIsIGJpYXNJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSBudWxsOyB9XG4gICAgICAgIGlmICh1c2VCaWFzID09PSB2b2lkIDApIHsgdXNlQmlhcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGtlcm5lbEluaXRpYWxpemVyID09PSB2b2lkIDApIHsga2VybmVsSW5pdGlhbGl6ZXIgPSBuZXcgaW5pdGlhbGl6ZXJzXzEuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICBpZiAoYmlhc0luaXRpYWxpemVyID09PSB2b2lkIDApIHsgYmlhc0luaXRpYWxpemVyID0gbmV3IGluaXRpYWxpemVyc18xLlplcm9zSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICB2YXIgd2VpZ2h0cyA9IHRoaXMuZy52YXJpYWJsZShuYW1lICsgJy13ZWlnaHRzJywga2VybmVsSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbeC5zaGFwZVswXSwgdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5nLm1hdG11bCh4LCB3ZWlnaHRzKTtcbiAgICAgICAgaWYgKHVzZUJpYXMpIHtcbiAgICAgICAgICAgIHZhciBiaWFzID0gdGhpcy5nLnZhcmlhYmxlKG5hbWUgKyAnLWJpYXMnLCBiaWFzSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICAgICAgb3V0ID0gdGhpcy5nLmFkZChvdXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dCA9IGFjdGl2YXRpb24ob3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoTGF5ZXJzO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhMYXllcnMgPSBHcmFwaExheWVycztcbnZhciBHcmFwaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGgoKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhMYXllcnModGhpcyk7XG4gICAgfVxuICAgIEdyYXBoLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFZhcmlhYmxlTm9kZSh0aGlzLCBuYW1lLCBkYXRhKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAobmFtZSwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUGxhY2Vob2xkZXJOb2RlKHRoaXMsIG5hbWUsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uc3RhbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpbmFsVmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLlNjYWxhci5uZXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgZmxhdFZhbHVlcyA9IHV0aWwuZmxhdHRlbih2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdFZhbHVlcyk7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh1dGlsLmluZmVyU2hhcGUodmFsdWUpLCB7IHZhbHVlczogdmFscyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBjb25zdGFudCB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbnN0YW50Tm9kZSh0aGlzLCBmaW5hbFZhbHVlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uICh4LCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZXNoYXBlTm9kZSh0aGlzLCAnUmVzaGFwZScsIHgsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZnVzZWRMaW5lYXJDb21iaW5hdGlvbiA9IGZ1bmN0aW9uICh4MSwgeDIsIGMxLCBjMikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSh0aGlzLCB4MSwgeDIsIGMxLCBjMikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQWRkTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3VidHJhY3ROb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNdWx0aXBseU5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBEaXZpZGVOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlZHVjZVN1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlZHVjZVN1bU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbmNhdDFkID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQxRE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uY2F0MmQgPSBmdW5jdGlvbiAoeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbmNhdDJETm9kZSh0aGlzLCB4MSwgeDIsIGF4aXMpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5jb25jYXQzZCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uY2F0M0ROb2RlKHRoaXMsIHgxLCB4MiwgYXhpcykpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbmNhdDRkID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQ0RE5vZGUodGhpcywgeDEsIHgyLCBheGlzKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF0bXVsID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXRNdWxOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29udm9sdXRpb24yRE5vZGUodGhpcywgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXhQb29sTm9kZSh0aGlzLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEV4cE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExvZ05vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZUxVTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubGVha3lSZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExlYWt5UmVMVU5vZGUodGhpcywgeCwgYWxwaGEpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5wcmVsdSA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBQUmVMVU5vZGUodGhpcywgeCwgYWxwaGEpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5lbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBFbHVOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgVGFuSE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTaWdtb2lkTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3F1YXJlTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc29mdG1heCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNvZnRtYXhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCA9IGZ1bmN0aW9uICh4LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKHRoaXMsIHgsIHRhcmdldCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm1lYW5TcXVhcmVkQ29zdCA9IGZ1bmN0aW9uIChsYWJlbCwgcHJlZGljdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNZWFuU3F1YXJlZENvc3ROb2RlKHRoaXMsIGxhYmVsLCBwcmVkaWN0aW9uKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYXJnbWF4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4Tm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYXJnbWF4RXF1YWxzID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhFcXVhbHNOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUudmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUub3V0cHV0O1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaDtcbn0oKSk7XG5leHBvcnRzLkdyYXBoID0gR3JhcGg7XG52YXIgVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3Ioc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLmlkID0gVGVuc29yLm5leHRJRCsrO1xuICAgIH1cbiAgICBUZW5zb3IubmV4dElEID0gMDtcbiAgICByZXR1cm4gVGVuc29yO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yID0gVGVuc29yO1xudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUoZ3JhcGgsIG5hbWUsIGlucHV0cywgb3V0cHV0KSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICB0aGlzLmlkID0gTm9kZS5uZXh0SUQrKztcbiAgICAgICAgb3V0cHV0Lm5vZGUgPSB0aGlzO1xuICAgIH1cbiAgICBOb2RlLm5leHRJRCA9IDA7XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBWYXJpYWJsZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYXJpYWJsZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVOb2RlKGdyYXBoLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7fSwgbmV3IFRlbnNvcihkYXRhLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFyaWFibGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5kYXRhICE9IG51bGwsICdFcnJvciBhZGRpbmcgdmFyaWFibGUgb3A6IERhdGEgZm9yIHZhcmlhYmxlIFxcJycgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgJ1xcJyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFZhcmlhYmxlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGU7XG52YXIgUGxhY2Vob2xkZXJOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGxhY2Vob2xkZXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyTm9kZShncmFwaCwgbmFtZSwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7fSwgbmV3IFRlbnNvcihzaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBsYWNlaG9sZGVyTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5QbGFjZWhvbGRlck5vZGUgPSBQbGFjZWhvbGRlck5vZGU7XG52YXIgQ29uc3RhbnROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uc3RhbnROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnN0YW50Tm9kZShncmFwaCwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbnN0YW50Jywge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnN0YW50Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuZGF0YSAhPSBudWxsLCAnRXJyb3IgYWRkaW5nIGNvbnN0YW50OiBkYXRhIGZvciBwbGFjZWhvbGRlciBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uc3RhbnROb2RlID0gQ29uc3RhbnROb2RlO1xudmFyIFJlc2hhcGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZU5vZGUoZ3JhcGgsIG5hbWUsIHgsIHNoYXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7IHg6IHggfSwgbmV3IFRlbnNvcihzaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXNoYXBlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnguc2hhcGUpO1xuICAgICAgICB2YXIgc2hhcGVTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMuc2hhcGUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2l6ZSA9PT0gc2hhcGVTaXplLCBcIkVycm9yIG1ha2luZyByZXNoYXBlIG9wZXJhdGlvbjogaW5wdXQgdG8gcmVzaGFwZSAnXCIgKyB0aGlzLm5hbWUgKyBcIidcIiArXG4gICAgICAgICAgICAoXCIgb2Ygc2hhcGUgKFwiICsgdGhpcy54LnNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIHNpemUgb2YgXCIpICtcbiAgICAgICAgICAgIChcInJlcXVlc3RlZCBzaGFwZSBcIiArIHRoaXMuc2hhcGUgKyBcIi5cIikpO1xuICAgIH07XG4gICAgUmVzaGFwZU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gUmVzaGFwZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUmVzaGFwZU5vZGUgPSBSZXNoYXBlTm9kZTtcbnZhciBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKGdyYXBoLCB0MSwgdDIsIGMxLCBjMikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0xpbmVhciBDb21iaW5hdGlvbicsIHsgdDE6IHQxLCB0MjogdDIsIGMxOiBjMSwgYzI6IGMyIH0sIG5ldyBUZW5zb3IodDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICBfdGhpcy5jMSA9IGMxO1xuICAgICAgICBfdGhpcy5jMiA9IGMyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKTtcbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMS5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMxIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICAgICAgIChcInNoYXBlOiBcIiArIHRoaXMuYzEuc2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLmMyLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgZnVzZWRMaW5lYXJDb21iaW5hdGlvbjogYzIgaXMgbm90IGEgc2NhbGFyLCBnb3QgJyArXG4gICAgICAgICAgICAgICAgKFwic2hhcGU6IFwiICsgdGhpcy5jMi5zaGFwZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMSA9ICd0MSc7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDIgPSAndDInO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMxID0gJ2MxJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMiA9ICdjMic7XG4gICAgcmV0dXJuIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlID0gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGU7XG52YXIgQWRkTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkZE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRkTm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQWRkJywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDFcbiAgICAgICAgICAgID8gdDIuc2hhcGVcbiAgICAgICAgICAgIDogKHQxLnNoYXBlLmxlbmd0aCA8IHQyLnNoYXBlLmxlbmd0aCA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSkgfHxcbiAgICAgICAgICAgICh0aGlzLnQxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLnQyLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudDEuc2hhcGVbMV0gPT09IHRoaXMudDIuc2hhcGVbMF0pIHx8XG4gICAgICAgICAgICAodGhpcy50MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy50Mi5zaGFwZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnQxLnNoYXBlWzBdID09PSB0aGlzLnQyLnNoYXBlWzFdKSwgJ0Vycm9yIGFkZGluZyBhZGQgb3BlcmF0aW9uIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyLCAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaCxcIikgK1xuICAgICAgICAgICAgJ29yIG9uZSBvZiB0aGVtIGNhbiBiZSBicm9hZGNhc3RlZCAoMkQgYW5kIDFEKS4nKTtcbiAgICB9O1xuICAgIEFkZE5vZGUuVDEgPSAndDEnO1xuICAgIEFkZE5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBBZGROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFkZE5vZGUgPSBBZGROb2RlO1xudmFyIFN1YnRyYWN0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnRyYWN0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdE5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1N1YnRyYWN0JywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJ0cmFjdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBzdWJ0cmFjdCBvcDogb25lIG9mIGlucHV0cyBtdXN0IGJlIHNjYWxhciBvciB0aGUgJyArXG4gICAgICAgICAgICAoXCJzaGFwZXMgXCIgKyB0aGlzLnQxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy50Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICB9O1xuICAgIFN1YnRyYWN0Tm9kZS5UMSA9ICd0MSc7XG4gICAgU3VidHJhY3ROb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gU3VidHJhY3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlN1YnRyYWN0Tm9kZSA9IFN1YnRyYWN0Tm9kZTtcbnZhciBNdWx0aXBseU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlwbHlOb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNdWx0aXBseScsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHlOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgbXVsdGlwbHkgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIFwiICsgdGhpcy50MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMudDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBNdWx0aXBseU5vZGUuVDEgPSAndDEnO1xuICAgIE11bHRpcGx5Tm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIE11bHRpcGx5Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NdWx0aXBseU5vZGUgPSBNdWx0aXBseU5vZGU7XG52YXIgRGl2aWRlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGl2aWRlTm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnRGl2aWRlJywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXZpZGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgZGl2aWRlIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgRGl2aWRlTm9kZS5UMSA9ICd0MSc7XG4gICAgRGl2aWRlTm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIERpdmlkZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGl2aWRlTm9kZSA9IERpdmlkZU5vZGU7XG52YXIgUmVkdWNlU3VtTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1bU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdSZWR1Y2VTdW0nLCB7IHg6IHggfSwgbmV3IFRlbnNvcihbXSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlZHVjZVN1bU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlZHVjZVN1bU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gUmVkdWNlU3VtTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5SZWR1Y2VTdW1Ob2RlID0gUmVkdWNlU3VtTm9kZTtcbnZhciBDb25jYXQxRE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQxRE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0MUROb2RlKGdyYXBoLCB4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uY2F0MUQnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlMUQoeDEuc2hhcGUsIHgyLnNoYXBlKSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIENvbmNhdDFETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQ29uY2F0MUROb2RlLlgxID0gJ3gxJztcbiAgICBDb25jYXQxRE5vZGUuWDIgPSAneDInO1xuICAgIHJldHVybiBDb25jYXQxRE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uY2F0MUROb2RlID0gQ29uY2F0MUROb2RlO1xudmFyIENvbmNhdDJETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDJETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQyRE5vZGUoZ3JhcGgsIHgxLCB4MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbmNhdDJEJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgVGVuc29yKGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0MkROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUsIHRoaXMuYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXQyRE5vZGUuWDEgPSAneDEnO1xuICAgIENvbmNhdDJETm9kZS5YMiA9ICd4Mic7XG4gICAgQ29uY2F0MkROb2RlLkFYSVMgPSAnYXhpcyc7XG4gICAgcmV0dXJuIENvbmNhdDJETm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db25jYXQyRE5vZGUgPSBDb25jYXQyRE5vZGU7XG52YXIgQ29uY2F0M0ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNETm9kZShncmFwaCwgeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uY2F0M0QnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcykpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQzRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXModGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSwgdGhpcy5heGlzKTtcbiAgICB9O1xuICAgIENvbmNhdDNETm9kZS5YMSA9ICd4MSc7XG4gICAgQ29uY2F0M0ROb2RlLlgyID0gJ3gyJztcbiAgICBDb25jYXQzRE5vZGUuQVhJUyA9ICdheGlzJztcbiAgICByZXR1cm4gQ29uY2F0M0ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbmNhdDNETm9kZSA9IENvbmNhdDNETm9kZTtcbnZhciBDb25jYXQ0RE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQ0RE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0NEROb2RlKGdyYXBoLCB4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25jYXQ0RCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDRETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh0aGlzLngxLnNoYXBlLCB0aGlzLngyLnNoYXBlLCB0aGlzLmF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0NEROb2RlLlgxID0gJ3gxJztcbiAgICBDb25jYXQ0RE5vZGUuWDIgPSAneDInO1xuICAgIENvbmNhdDRETm9kZS5BWElTID0gJ2F4aXMnO1xuICAgIHJldHVybiBDb25jYXQ0RE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uY2F0NEROb2RlID0gQ29uY2F0NEROb2RlO1xuZnVuY3Rpb24gZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDFTaGFwZSwgeDJTaGFwZSkge1xuICAgIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gW3gyU2hhcGVbMV1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW3gxU2hhcGVbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gW3gxU2hhcGVbMF0sIHgyU2hhcGVbMV1dO1xufVxudmFyIE1hdE11bE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXRNdWxOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdE11bE5vZGUoZ3JhcGgsIHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01hdE11bCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRNdWxOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLCAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5uZXIgc2hhcGVzIG9mIG1hdHJpY2VzIHdpdGggc2hhcGVzICcgK1xuICAgICAgICAgICAgICAgICh0aGlzLngxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVsxXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNlY29uZCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggc2hhcGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy54MS5zaGFwZS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAoXCIgbXVzdCBtYXRjaCBzaXplIG9mIHZlY3RvciB3aXRoIHNoYXBlIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMF0gPT09IHRoaXMueDIuc2hhcGVbMF0sIFwiRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSBcIiArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgICAgIFwiIG11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZSBcIiArIHRoaXMueDIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBpbnB1dHMgbXVzdCBiZSB2ZWN0b3JzIG9yIG1hdHJpY2VzLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRNdWxOb2RlLlgxID0gJ3gxJztcbiAgICBNYXRNdWxOb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gTWF0TXVsTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NYXRNdWxOb2RlID0gTWF0TXVsTm9kZTtcbnZhciBDb252b2x1dGlvbjJETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnZvbHV0aW9uMkROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnZvbHV0aW9uMkROb2RlKGdyYXBoLCB4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb252b2x1dGlvbiAyRCcsIHsgeDogeCwgdzogdywgYjogYiB9LCBuZXcgVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLncgPSB3O1xuICAgICAgICBfdGhpcy5iID0gYjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5vdXRwdXREZXB0aCA9IG91dHB1dERlcHRoO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnZvbHV0aW9uMkROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMywgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLnguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLncuc2hhcGUubGVuZ3RoID09PSA0LCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogd2VpZ2h0cyBtdXN0IGJlIG9mIHJhbmsgNCwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy53LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5iLnNoYXBlLmxlbmd0aCA9PT0gMSwgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGJpYXNlcyBtdXN0IGJlIG9mIHJhbmsgMSwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy5iLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlWzJdID09PSB0aGlzLncuc2hhcGVbMl0sIFwiRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogZGVwdGggb2YgaW5wdXQgKFwiICsgdGhpcy54LnNoYXBlWzJdICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIHdlaWdodHMgKFwiICsgdGhpcy53LnNoYXBlWzJdICsgXCIpLlwiKSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJETm9kZS5YID0gJ3gnO1xuICAgIENvbnZvbHV0aW9uMkROb2RlLlcgPSAndyc7XG4gICAgQ29udm9sdXRpb24yRE5vZGUuQiA9ICdiJztcbiAgICByZXR1cm4gQ29udm9sdXRpb24yRE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29udm9sdXRpb24yRE5vZGUgPSBDb252b2x1dGlvbjJETm9kZTtcbnZhciBNYXhQb29sTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heFBvb2xOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2xOb2RlKGdyYXBoLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01heCBwb29sJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZpZWxkU2l6ZSwgeC5zaGFwZVsyXSwgc3RyaWRlLCB6ZXJvUGFkKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLCAnRXJyb3IgYWRkaW5nIG1heFBvb2wgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLnguc2hhcGUgKyBcIi5cIikpO1xuICAgIH07XG4gICAgTWF4UG9vbE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTWF4UG9vbE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWF4UG9vbE5vZGUgPSBNYXhQb29sTm9kZTtcbnZhciBSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlTFVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlTFVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1JlTFUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlTFVOb2RlID0gUmVMVU5vZGU7XG52YXIgTGVha3lSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVha3lSZUxVTm9kZShncmFwaCwgeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMZWFreVJlTFUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMZWFreVJlTFVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBMZWFreVJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIExlYWt5UmVMVU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTGVha3lSZUxVTm9kZSA9IExlYWt5UmVMVU5vZGU7XG52YXIgUFJlTFVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUFJlTFVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBSZUxVTm9kZShncmFwaCwgeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdQUmVMVScsIHsgeDogeCwgYWxwaGE6IGFscGhhIH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBSZUxVTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy54LnNoYXBlLCB0aGlzLmFscGhhLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBwUmVsdSBvcDogdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIHg6IFwiICsgdGhpcy54LnNoYXBlICsgXCIgYW5kIGFscGhhOiBcIiArIHRoaXMuYWxwaGEuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBQUmVMVU5vZGUuWCA9ICd4JztcbiAgICBQUmVMVU5vZGUuQUxQSEEgPSAnYWxwaGEnO1xuICAgIHJldHVybiBQUmVMVU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUFJlTFVOb2RlID0gUFJlTFVOb2RlO1xudmFyIEVsdU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbHVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsdU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnRWx1JywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVsdU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEVsdU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gRWx1Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5FbHVOb2RlID0gRWx1Tm9kZTtcbnZhciBFeHBOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHBOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0V4cCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFeHBOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBFeHBOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIEV4cE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRXhwTm9kZSA9IEV4cE5vZGU7XG52YXIgTG9nTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZ05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9nTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMb2cnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgTG9nTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTG9nTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBMb2dOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkxvZ05vZGUgPSBMb2dOb2RlO1xudmFyIFRhbkhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFuSE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuSE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnVGFuSCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYW5ITm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVGFuSE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gVGFuSE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuVGFuSE5vZGUgPSBUYW5ITm9kZTtcbnZhciBTaWdtb2lkTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ21vaWROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWROb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NpZ21vaWQnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU2lnbW9pZE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNpZ21vaWROb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFNpZ21vaWROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNpZ21vaWROb2RlID0gU2lnbW9pZE5vZGU7XG52YXIgU3F1YXJlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNxdWFyZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3F1YXJlTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTcXVhcmUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU3F1YXJlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgU3F1YXJlTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTcXVhcmVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNxdWFyZU5vZGUgPSBTcXVhcmVOb2RlO1xudmFyIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUoZ3JhcGgsIHgsIHRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NvZnRtYXhDcm9zc0VudHJvcHlDb3N0JywgeyB4OiB4LCB0YXJnZXQ6IHRhcmdldCB9LCBuZXcgVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueC5zaGFwZSwgdGhpcy50YXJnZXQuc2hhcGUpLCBcIkVycm9yIGFkZGluZyBzb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCBvcDogeCBzaGFwZSAoXCIgKyB0aGlzLnguc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCB0YXJnZXQgc2hhcGUgKFwiICsgdGhpcy50YXJnZXQuc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5YID0gJ3gnO1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVQgPSAndGFyZ2V0JztcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSA9IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZTtcbnZhciBTb2Z0bWF4Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU29mdG1heCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDEsICdUaGUgaW5wdXQgdG8gYSBzb2Z0bWF4IG11c3QgYmUgYSAxLUQgdGVuc29yJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZVswXSA+PSAyLCAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMnKTtcbiAgICB9O1xuICAgIFNvZnRtYXhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFNvZnRtYXhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNvZnRtYXhOb2RlID0gU29mdG1heE5vZGU7XG52YXIgTWVhblNxdWFyZWRDb3N0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lYW5TcXVhcmVkQ29zdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVhblNxdWFyZWRDb3N0Tm9kZShncmFwaCwgbGFiZWwsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNZWFuIFNxdWFyZWQgQ29zdCcsIHsgbGFiZWw6IGxhYmVsLCBwcmVkaWN0aW9uOiBwcmVkaWN0aW9uIH0sIG5ldyBUZW5zb3IoW10pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICBfdGhpcy5wcmVkaWN0aW9uID0gcHJlZGljdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZWFuU3F1YXJlZENvc3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLmxhYmVsLnNoYXBlLCB0aGlzLnByZWRpY3Rpb24uc2hhcGUpLCBcIkVycm9yIGFkZGluZyBtZWFuU3F1YXJlZENvc3Qgb3A6IGxhYmVsIHNoYXBlIChcIiArIHRoaXMubGFiZWwuc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBwcmVkaWN0aW9uIHNoYXBlIChcIiArIHRoaXMucHJlZGljdGlvbi5zaGFwZSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTCA9ICdsYWJlbCc7XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5QUkVESUNUSU9OID0gJ3ByZWRpY3Rpb24nO1xuICAgIHJldHVybiBNZWFuU3F1YXJlZENvc3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk1lYW5TcXVhcmVkQ29zdE5vZGUgPSBNZWFuU3F1YXJlZENvc3ROb2RlO1xudmFyIEFyZ01heE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdBcmdNYXgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcihbMV0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSkgPiAwLCAnRXJyb3IgYWRkaW5nIGFyZ21heCBvcDogaW5wdXQgdGVuc29yIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gICAgfTtcbiAgICBBcmdNYXhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIEFyZ01heE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQXJnTWF4Tm9kZSA9IEFyZ01heE5vZGU7XG52YXIgQXJnTWF4RXF1YWxzTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heEVxdWFsc05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzTm9kZShncmFwaCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4RXF1YWxzJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgVGVuc29yKFsxXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSksIFwiRXJyb3IgYWRkaW5nIEFyZ01heEVxdWFscyBvcDogeDEgc2hhcGUgKFwiICsgdGhpcy54MS5zaGFwZSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIHgyIHNoYXBlIChcIiArIHRoaXMueDIuc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIEFyZ01heEVxdWFsc05vZGUuWDEgPSAneDEnO1xuICAgIEFyZ01heEVxdWFsc05vZGUuWDIgPSAneDInO1xuICAgIHJldHVybiBBcmdNYXhFcXVhbHNOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFyZ01heEVxdWFsc05vZGUgPSBBcmdNYXhFcXVhbHNOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9zZXNzaW9uXCIpO1xudmFyIERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUyA9IDE1MDA7XG52YXIgREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TID0gNTAwO1xudmFyIERFRkFVTFRfSU5GRVJFTkNFX0VYQU1QTEVfSU5URVJWQUxfTVMgPSAzMDAwO1xudmFyIE1ldHJpY1JlZHVjdGlvbjtcbihmdW5jdGlvbiAoTWV0cmljUmVkdWN0aW9uKSB7XG4gICAgTWV0cmljUmVkdWN0aW9uW01ldHJpY1JlZHVjdGlvbltcIlNVTVwiXSA9IDBdID0gXCJTVU1cIjtcbiAgICBNZXRyaWNSZWR1Y3Rpb25bTWV0cmljUmVkdWN0aW9uW1wiTUVBTlwiXSA9IDFdID0gXCJNRUFOXCI7XG59KShNZXRyaWNSZWR1Y3Rpb24gPSBleHBvcnRzLk1ldHJpY1JlZHVjdGlvbiB8fCAoZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gPSB7fSkpO1xudmFyIEdyYXBoUnVubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaFJ1bm5lcihtYXRoLCBzZXNzaW9uLCBldmVudE9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlciA9IGV2ZW50T2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLmxhc3RFdmFsVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRpc3RpY3MoKTtcbiAgICAgICAgdGhpcy56ZXJvU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMCk7XG4gICAgfVxuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXNldFN0YXRpc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZCA9IDA7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiAoY29zdFRlbnNvciwgdHJhaW5GZWVkRW50cmllcywgYmF0Y2hTaXplLCBvcHRpbWl6ZXIsIG51bUJhdGNoZXMsIG1ldHJpY1RlbnNvciwgbWV0cmljRmVlZEVudHJpZXMsIG1ldHJpY0JhdGNoU2l6ZSwgbWV0cmljUmVkdWN0aW9uLCBldmFsSW50ZXJ2YWxNcywgY29zdEludGVydmFsTXMpIHtcbiAgICAgICAgaWYgKG1ldHJpY1JlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IG1ldHJpY1JlZHVjdGlvbiA9IE1ldHJpY1JlZHVjdGlvbi5NRUFOOyB9XG4gICAgICAgIGlmIChldmFsSW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGV2YWxJbnRlcnZhbE1zID0gREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChjb3N0SW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGNvc3RJbnRlcnZhbE1zID0gREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIHRoaXMuY29zdFRlbnNvciA9IGNvc3RUZW5zb3I7XG4gICAgICAgIHRoaXMudHJhaW5GZWVkRW50cmllcyA9IHRyYWluRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMubWV0cmljVGVuc29yID0gbWV0cmljVGVuc29yO1xuICAgICAgICB0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID0gbWV0cmljRmVlZEVudHJpZXM7XG4gICAgICAgIGlmIChtZXRyaWNCYXRjaFNpemUgIT0gbnVsbCAmJiB0aGlzLm1ldHJpY0JhdGNoU2l6ZSAhPT0gbWV0cmljQmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcobWV0cmljQmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZSA9IG1ldHJpY0JhdGNoU2l6ZTtcbiAgICAgICAgdGhpcy5tZXRyaWNSZWR1Y3Rpb24gPSBtZXRyaWNSZWR1Y3Rpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICB0aGlzLm9wdGltaXplciA9IG9wdGltaXplcjtcbiAgICAgICAgdGhpcy5tZXRyaWNJbnRlcnZhbE1zID0gZXZhbEludGVydmFsTXM7XG4gICAgICAgIHRoaXMuY29zdEludGVydmFsTXMgPSBjb3N0SW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcyA9IG51bUJhdGNoZXM7XG4gICAgICAgIHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuID0gMDtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFpblN0YXJ0VGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudHJhaW5OZXR3b3JrKCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc3RvcFRyYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXN1bWVUcmFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS50cmFpbk5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5zdG9wVHJhaW5pbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNUcmFpbmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciBzaG91bGRDb21wdXRlQ29zdCA9IHRoaXMuZXZlbnRPYnNlcnZlci5hdmdDb3N0Q2FsbGJhY2sgIT0gbnVsbCAmJlxuICAgICAgICAgICAgKHN0YXJ0IC0gdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA+IHRoaXMuY29zdEludGVydmFsTXMpO1xuICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNvc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29zdFJlZHVjdGlvbiA9IHNob3VsZENvbXB1dGVDb3N0ID8gc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb24uTUVBTiA6IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uLk5PTkU7XG4gICAgICAgIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGF2Z0Nvc3QgPSBfdGhpcy5zZXNzaW9uLnRyYWluKF90aGlzLmNvc3RUZW5zb3IsIF90aGlzLnRyYWluRmVlZEVudHJpZXMsIF90aGlzLmJhdGNoU2l6ZSwgX3RoaXMub3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrKGF2Z0Nvc3QpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLnRyYWluRXhhbXBsZXNQZXJTZWNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGFtcGxlc1BlclNlYyA9IChfdGhpcy5iYXRjaFNpemUgKiAxMDAwIC8gdHJhaW5UaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXRyaWNGZWVkRW50cmllcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc3RhcnQgLSBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA+IF90aGlzLm1ldHJpY0ludGVydmFsTXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgPSBfdGhpcy5jb21wdXRlTWV0cmljKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayhfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2soKHN0YXJ0IC0gX3RoaXMudHJhaW5TdGFydFRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1bisrO1xuICAgICAgICAgICAgX3RoaXMudG90YWxCYXRjaGVzVHJhaW5lZCsrO1xuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5iYXRjaGVzVHJhaW5lZENhbGxiYWNrKF90aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRyYWluTmV0d29yaygpOyB9KTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pbmZlciA9IGZ1bmN0aW9uIChpbmZlcmVuY2VUZW5zb3IsIGluZmVyZW5jZUZlZWRFbnRyaWVzLCBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcywgaW5mZXJlbmNlRXhhbXBsZUNvdW50LCBudW1QYXNzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID09PSB2b2lkIDApIHsgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPSBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChpbmZlcmVuY2VFeGFtcGxlQ291bnQgPT09IHZvaWQgMCkgeyBpbmZlcmVuY2VFeGFtcGxlQ291bnQgPSA1OyB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayA9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2UgbG9vcCwgbm8gaW5mZXJlbmNlIGV4YW1wbGUgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2V4YW1wbGVzL3NlYyBvYnNlcnZlciBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVlZEVudHJ5ID0gaW5mZXJlbmNlRmVlZEVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0YXJ0IGluZmVyZW5jZSBvbiB0aGUgbW9kZWwgcnVubmVyIHdpdGggZmVlZCBlbnRyaWVzIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAndHlwZSBOREFycmF5LiBQbGVhc2UgdXNlIElucHV0UHJvdmlkZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPSBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VUZW5zb3IgPSBpbmZlcmVuY2VUZW5zb3I7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXMgPSBpbmZlcmVuY2VGZWVkRW50cmllcztcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ7XG4gICAgICAgIHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMgPSBudW1QYXNzZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luZmVycmluZykge1xuICAgICAgICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuID0gMDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pbmZlck5ldHdvcmsoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0luZmVycmluZyA9IHRydWU7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaW5mZXJOZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcgfHxcbiAgICAgICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50SW5mZXJlbmNlTG9vcE51bVBhc3Nlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGZlZWRzID0gW107XG4gICAgICAgICAgICB2YXIgaW5mZXJlbmNlVmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmRhcnJheUZlZWRFbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVlZEVudHJ5ID0gX3RoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q29weSA9IGZlZWRFbnRyeS5kYXRhLmdldE5leHRDb3B5KF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZGFycmF5RmVlZEVudHJpZXMucHVzaCh7IHRlbnNvcjogZmVlZEVudHJ5LnRlbnNvciwgZGF0YTogbmV4dENvcHkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlZWRzLnB1c2gobmRhcnJheUZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VWYWx1ZXMucHVzaChfdGhpcy5zZXNzaW9uLmV2YWwoX3RoaXMuaW5mZXJlbmNlVGVuc29yLCBuZGFycmF5RmVlZEVudHJpZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZVZhbHVlc1tpbmZlcmVuY2VWYWx1ZXMubGVuZ3RoIC0gMV0uZGF0YVN5bmMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZXNQZXJTZWMgPSAoX3RoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ICogMTAwMCAvIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrKGV4YW1wbGVzUGVyU2VjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayhmZWVkcywgaW5mZXJlbmNlVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGFzdEluZmVyVGltZW91dElEID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW5mZXJOZXR3b3JrKCk7IH0sIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnN0b3BJbmZlcnJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNJbmZlcnJpbmcgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmxhc3RJbmZlclRpbWVvdXRJRCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaXNJbmZlcmVuY2VSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luZmVycmluZztcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5jb21wdXRlTWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5tZXRyaWNGZWVkRW50cmllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIG1ldHJpYywgbm8gbWV0cmljIEZlZWRFbnRyaWVzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRyaWMgPSB0aGlzLnplcm9TY2FsYXI7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubWV0cmljQmF0Y2hTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0cmljVmFsdWUgPSBfdGhpcy5zZXNzaW9uLmV2YWwoX3RoaXMubWV0cmljVGVuc29yLCBfdGhpcy5tZXRyaWNGZWVkRW50cmllcyk7XG4gICAgICAgICAgICAgICAgbWV0cmljID0gX3RoaXMubWF0aC5hZGQobWV0cmljLCBtZXRyaWNWYWx1ZS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLm1ldHJpY1JlZHVjdGlvbiA9PT0gTWV0cmljUmVkdWN0aW9uLk1FQU4pIHtcbiAgICAgICAgICAgICAgICBtZXRyaWMgPSBfdGhpcy5tYXRoLmRpdmlkZShtZXRyaWMsIF90aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0cmljO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5nZXRUb3RhbEJhdGNoZXNUcmFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmdldExhc3RDb21wdXRlZE1ldHJpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbXB1dGVkTWV0cmljO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldE1hdGggPSBmdW5jdGlvbiAobWF0aCkge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldEluZmVyZW5jZVRlbnNvciA9IGZ1bmN0aW9uIChpbmZlcmVuY2VUZW5zb3IpIHtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VUZW5zb3IgPSBpbmZlcmVuY2VUZW5zb3I7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0SW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gZnVuY3Rpb24gKGluZmVyZW5jZUV4YW1wbGVDb3VudCkge1xuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGluZmVyZW5jZUV4YW1wbGVDb3VudDtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaFJ1bm5lcjtcbn0oKSk7XG5leHBvcnRzLkdyYXBoUnVubmVyID0gR3JhcGhSdW5uZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaF9ydW5uZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIHByaW9yaXR5X3F1ZXVlID0gcmVxdWlyZShcIi4vcHJpb3JpdHlfcXVldWVcIik7XG52YXIgcHJpb3JpdHlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5X3F1ZXVlXCIpO1xuZnVuY3Rpb24gZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChub2RlcywgdGVybWluYXRpbmdOb2Rlcykge1xuICAgIHZhciB0ZXJtaW5hdGluZ05vZGVNYXAgPSB7fTtcbiAgICB2YXIgc2VlbiA9IHt9O1xuICAgIHZhciBzZXQgPSBbXTtcbiAgICB2YXIgdmlzaXQgPSBub2Rlcy5zbGljZSgpO1xuICAgIHRlcm1pbmF0aW5nTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGVybWluYXRpbmdOb2RlTWFwW25vZGUuaWRdID0gbm9kZTsgfSk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXIgPSB2aXNpdC5wb3AoKTtcbiAgICAgICAgaWYgKHNlZW5bY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGVybWluYXRpbmdOb2RlTWFwW2N1ci5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1ci5pbnB1dHMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlucHV0TmFtZSkgeyByZXR1cm4gY3VyLmlucHV0c1tpbnB1dE5hbWVdOyB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIHZpc2l0LnB1c2goaW5wdXQubm9kZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0LnB1c2goY3VyKTtcbiAgICAgICAgICAgIHNlZW5bY3VyLmlkXSA9IGN1cjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKHZpc2l0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBfbG9vcF8xKCk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG5leHBvcnRzLmdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQgPSBnZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCkge1xuICAgIHZhciBzZXQgPSBbXTtcbiAgICB2YXIgbm9kZUluZGljZXMgPSB7fTtcbiAgICB2YXIgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHt9O1xuICAgIHZhciBub2RlUXVldWUgPSBuZXcgcHJpb3JpdHlfcXVldWVfMS5Qcmlvcml0eVF1ZXVlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBwcmlvcml0eV9xdWV1ZS5kZWZhdWx0Q29tcGFyZShwZW5kaW5nRGVwZW5kZW5jaWVzW2EuaWRdLCBwZW5kaW5nRGVwZW5kZW5jaWVzW2IuaWRdKTsgfSwgZnVuY3Rpb24gKG5vZGUsIG5ld0luZGV4KSB7IHJldHVybiBub2RlSW5kaWNlc1tub2RlLmlkXSA9IG5ld0luZGV4OyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHBlbmRpbmdEZXBlbmRlbmNpZXNbbm9kZS5pZF0gPSAwOyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG5vZGUuaW5wdXRzW2tleV07IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodW5vcmRlcmVkRXZhbHVhdGlvblNldC5pbmRleE9mKGlucHV0Lm5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1tpbnB1dC5ub2RlLmlkXSsrO1xuICAgICAgICB9XG4gICAgfSk7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZVF1ZXVlLmVucXVldWUobm9kZSk7IH0pO1xuICAgIHdoaWxlICghbm9kZVF1ZXVlLmVtcHR5KCkpIHtcbiAgICAgICAgc2V0LnVuc2hpZnQobm9kZVF1ZXVlLmRlcXVldWUoKSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHNldFswXS5pbnB1dHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXRbMF0uaW5wdXRzW2tleV07IH0pLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodW5vcmRlcmVkRXZhbHVhdGlvblNldC5pbmRleE9mKGlucHV0Lm5vZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0tLTtcbiAgICAgICAgICAgIG5vZGVRdWV1ZS51cGRhdGUoaW5wdXQubm9kZSwgbm9kZUluZGljZXNbaW5wdXQubm9kZS5pZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbmV4cG9ydHMuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQgPSBnZXRPcmRlcmVkRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIGlzSW5wdXROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNJbnB1dE5vZGUgPSBpc0lucHV0Tm9kZTtcbmZ1bmN0aW9uIHNob3VsZEJhY2tQcm9wKHQpIHtcbiAgICByZXR1cm4gISh0Lm5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbnN0YW50Tm9kZSk7XG59XG5leHBvcnRzLnNob3VsZEJhY2tQcm9wID0gc2hvdWxkQmFja1Byb3A7XG5mdW5jdGlvbiBpc1Bhc3N0aHJvdWdoTm9kZShub2RlLCBtYXApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNba2V5c1tpXV07XG4gICAgICAgIGlmIChtYXAuZ2V0KGlucHV0LCB0cnVlKSA9PT0gbWFwLmdldChub2RlLm91dHB1dCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNQYXNzdGhyb3VnaE5vZGUgPSBpc1Bhc3N0aHJvdWdoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi9ncmFwaF91dGlsXCIpO1xudmFyIGFkZF8xID0gcmVxdWlyZShcIi4vb3BzL2FkZFwiKTtcbnZhciBhcmdtYXhfMSA9IHJlcXVpcmUoXCIuL29wcy9hcmdtYXhcIik7XG52YXIgYXJnbWF4ZXF1YWxzXzEgPSByZXF1aXJlKFwiLi9vcHMvYXJnbWF4ZXF1YWxzXCIpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZShcIi4vb3BzL2NvbmNhdFwiKTtcbnZhciBjb252b2x1dGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2NvbnZvbHV0aW9uXCIpO1xudmFyIGRpdmlkZV8xID0gcmVxdWlyZShcIi4vb3BzL2RpdmlkZVwiKTtcbnZhciBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXCIpO1xudmFyIGVsZW1lbnRfd2lzZV9jb3N0XzEgPSByZXF1aXJlKFwiLi9vcHMvZWxlbWVudF93aXNlX2Nvc3RcIik7XG52YXIgZXhwXzEgPSByZXF1aXJlKFwiLi9vcHMvZXhwXCIpO1xudmFyIGxpbmVhcl9jb21iaW5hdGlvbl8xID0gcmVxdWlyZShcIi4vb3BzL2xpbmVhcl9jb21iaW5hdGlvblwiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuL29wcy9sb2dcIik7XG52YXIgbWF0bXVsXzEgPSByZXF1aXJlKFwiLi9vcHMvbWF0bXVsXCIpO1xudmFyIG1heF9wb29sXzEgPSByZXF1aXJlKFwiLi9vcHMvbWF4X3Bvb2xcIik7XG52YXIgbXVsdGlwbHlfMSA9IHJlcXVpcmUoXCIuL29wcy9tdWx0aXBseVwiKTtcbnZhciByZWR1Y2Vfc3VtXzEgPSByZXF1aXJlKFwiLi9vcHMvcmVkdWNlX3N1bVwiKTtcbnZhciByZXNoYXBlXzEgPSByZXF1aXJlKFwiLi9vcHMvcmVzaGFwZVwiKTtcbnZhciBzb2Z0bWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvc29mdG1heFwiKTtcbnZhciBzdWJ0cmFjdF8xID0gcmVxdWlyZShcIi4vb3BzL3N1YnRyYWN0XCIpO1xuZnVuY3Rpb24gZW1pdEZyb21HcmFwaE5vZGVzKG5vZGVzKSB7XG4gICAgdmFyIG9wcyA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG9wcywgZW1pdE9wRnJvbU5vZGUobm9kZSkpOyB9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuZXhwb3J0cy5lbWl0RnJvbUdyYXBoTm9kZXMgPSBlbWl0RnJvbUdyYXBoTm9kZXM7XG5mdW5jdGlvbiBlbWl0T3BGcm9tTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlJlc2hhcGVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHJlc2hhcGVfMS5SZXNoYXBlKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVzaGFwZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk1hdE11bE5vZGUpIHtcbiAgICAgICAgdmFyIHgxID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXRNdWxOb2RlLlgxXTtcbiAgICAgICAgdmFyIHgyID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXRNdWxOb2RlLlgyXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbWF0bXVsXzEuTWF0TXVsKHgxLCB4Miwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUpIHtcbiAgICAgICAgdmFyIHcgPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLlddO1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuWF07XG4gICAgICAgIHZhciBiID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5CXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgY29udm9sdXRpb25fMS5Db252b2x1dGlvbjJEKHcsIHgsIGIsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5vdXRwdXREZXB0aCwgbm9kZS5zdHJpZGUsIG5vZGUuemVyb1BhZCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NYXhQb29sTm9kZSkge1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF4UG9vbE5vZGUuWF07XG4gICAgICAgIHJldHVybiBbbmV3IG1heF9wb29sXzEuTWF4UG9vbCh4LCBub2RlLm91dHB1dCwgbm9kZS5maWVsZFNpemUsIG5vZGUuc3RyaWRlLCBub2RlLnplcm9QYWQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRXhwTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBleHBfMS5FeHAobm9kZS5pbnB1dHNbZ3JhcGhfMS5FeHBOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Mb2dOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGxvZ18xLkxvZyhub2RlLmlucHV0c1tncmFwaF8xLkxvZ05vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlJlTFVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuUmVMVShub2RlLmlucHV0c1tncmFwaF8xLlJlTFVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5MZWFreVJlTFVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuTGVha3lSZUxVKG5vZGUuaW5wdXRzW2dyYXBoXzEuTGVha3lSZUxVTm9kZS5YXSwgbm9kZS5vdXRwdXQsIG5vZGUuYWxwaGEpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUFJlTFVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuUFJlTFUobm9kZS5pbnB1dHNbZ3JhcGhfMS5QUmVMVU5vZGUuWF0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuUFJlTFVOb2RlLkFMUEhBXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRWx1Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLkVsdShub2RlLmlucHV0c1tncmFwaF8xLkVsdU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlRhbkhOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuVGFuSChub2RlLmlucHV0c1tncmFwaF8xLlRhbkhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TaWdtb2lkTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNpZ21vaWQobm9kZS5pbnB1dHNbZ3JhcGhfMS5TaWdtb2lkTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKSB7XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWF07XG4gICAgICAgIHZhciB0YXJnZXQgPSBub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVRdO1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heENyb3NzRW50cm9weUNvc3QoeCwgdGFyZ2V0LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Tb2Z0bWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heChub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTF07XG4gICAgICAgIHZhciBwcmVkaWN0aW9uID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlLlBSRURJQ1RJT05dO1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfY29zdF8xLk1lYW5TcXVhcmVkQ29zdChsYWJlbCwgcHJlZGljdGlvbiwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhlcXVhbHNfMS5BcmdNYXhFcXVhbHMobm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhfMS5BcmdNYXgobm9kZS54LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBsaW5lYXJfY29tYmluYXRpb25fMS5MaW5lYXJDb21iaW5hdGlvbihub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMl0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzFdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uY2F0MUROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGNvbmNhdF8xLkNvbmNhdDFEKG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0MUROb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQxRE5vZGUuWDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25jYXQyRE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgY29uY2F0XzEuQ29uY2F0MkQobm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQyRE5vZGUuWDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDJETm9kZS5YMl0sIG5vZGUuYXhpcywgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uY2F0M0ROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGNvbmNhdF8xLkNvbmNhdDNEKG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0M0ROb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQzRE5vZGUuWDJdLCBub2RlLmF4aXMsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbmNhdDRETm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBjb25jYXRfMS5Db25jYXQ0RChub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDRETm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0NEROb2RlLlgyXSwgbm9kZS5heGlzLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TcXVhcmVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuU3F1YXJlKG5vZGUuaW5wdXRzW2dyYXBoXzEuU3F1YXJlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQWRkTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhZGRfMS5BZGQobm9kZS5pbnB1dHNbZ3JhcGhfMS5BZGROb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5BZGROb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU3VidHJhY3ROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHN1YnRyYWN0XzEuU3VidHJhY3Qobm9kZS5pbnB1dHNbZ3JhcGhfMS5TdWJ0cmFjdE5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLlN1YnRyYWN0Tm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk11bHRpcGx5Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBtdWx0aXBseV8xLk11bHRpcGx5KG5vZGUuaW5wdXRzW2dyYXBoXzEuTXVsdGlwbHlOb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5NdWx0aXBseU5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5EaXZpZGVOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGRpdmlkZV8xLkRpdmlkZShub2RlLmlucHV0c1tncmFwaF8xLkRpdmlkZU5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkRpdmlkZU5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZWR1Y2VTdW1Ob2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IHJlZHVjZV9zdW1fMS5SZWR1Y2VTdW0obm9kZS5pbnB1dHNbZ3JhcGhfMS5SZWR1Y2VTdW1Ob2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiBcIiArIG5vZGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0aW9uX2VtaXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBZGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRkKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpIHx8XG4gICAgICAgICAgICAoeDFUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAyICYmIHgyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHgxVGVuc29yLnNoYXBlWzFdID09PSB4MlRlbnNvci5zaGFwZVswXSkgfHxcbiAgICAgICAgICAgICh4MVRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgJiYgeDJUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgeDFUZW5zb3Iuc2hhcGVbMF0gPT09IHgyVGVuc29yLnNoYXBlWzFdKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlLCAnICtcbiAgICAgICAgICAgICdvciBvbmUgb2YgdGhlbSBjYW4gYmUgYnJvYWRjYXN0ZWQgKDJEIGFuZCAxRCkuJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRkLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MiwgeDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hZGQoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLngxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy54MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMueDFUZW5zb3Iuc2hhcGVbMF0gPT09IF90aGlzLngyVGVuc29yLnNoYXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgc3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngxVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIHN1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMueDFUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLngyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy54MVRlbnNvci5zaGFwZVsxXSA9PT0gX3RoaXMueDJUZW5zb3Iuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBzdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgc3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZGQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFkZCA9IEFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBcmdNYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4KHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXgoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcmdNYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXggYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyZ01heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQXJnTWF4ID0gQXJnTWF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEFyZ01heEVxdWFscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heEVxdWFscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhFcXVhbHMoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heEVxdWFscy5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmFyZ01heEVxdWFscyh4MSwgeDIpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJnTWF4RXF1YWxzLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJnTWF4RXF1YWxzIGJhY2twcm9wIHVuaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBBcmdNYXhFcXVhbHM7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFyZ01heEVxdWFscyA9IEFyZ01heEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21heGVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29uY2F0X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb25jYXQxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDFEKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQxRC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlY2VuQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZWNlbkFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZWNlbkFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBjb25jYXRSZXN1bHQgPSBtYXRoLmNvbmNhdDFEKHgxLCB4Mik7XG4gICAgICAgICAgICBpbmZlcmVjZW5BcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY29uY2F0UmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29uY2F0MUQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25jYXRCYWNrUHJvcChtYXRoLCBfdGhpcy54MVRlbnNvciwgX3RoaXMueDJUZW5zb3IsIF90aGlzLnlUZW5zb3IsIDAsIGdyYWRpZW50QXJyYXlzLCBpbmZlcmVuY2VBcnJheXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQxRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0MUQgPSBDb25jYXQxRDtcbnZhciBDb25jYXQyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDJEKHgxVGVuc29yLCB4MlRlbnNvciwgYXhpcywgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDJELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVjZW5BcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlY2VuQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlY2VuQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGNvbmNhdFJlc3VsdCA9IG1hdGguY29uY2F0MkQoeDEsIHgyLCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIGluZmVyZWNlbkFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChjb25jYXRSZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXQyRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbmNhdEJhY2tQcm9wKG1hdGgsIF90aGlzLngxVGVuc29yLCBfdGhpcy54MlRlbnNvciwgX3RoaXMueVRlbnNvciwgX3RoaXMuYXhpcywgZ3JhZGllbnRBcnJheXMsIGluZmVyZW5jZUFycmF5cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhdDJEO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Db25jYXQyRCA9IENvbmNhdDJEO1xudmFyIENvbmNhdDNEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0M0QoeDFUZW5zb3IsIHgyVGVuc29yLCBheGlzLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0M0QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgY29uY2F0UmVzdWx0ID0gbWF0aC5jb25jYXQzRCh4MSwgeDIsIF90aGlzLmF4aXMpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKGNvbmNhdFJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbmNhdDNELnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uY2F0QmFja1Byb3AobWF0aCwgX3RoaXMueDFUZW5zb3IsIF90aGlzLngyVGVuc29yLCBfdGhpcy55VGVuc29yLCBfdGhpcy5heGlzLCBncmFkaWVudEFycmF5cywgaW5mZXJlbmNlQXJyYXlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uY2F0M0Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbmNhdDNEID0gQ29uY2F0M0Q7XG52YXIgQ29uY2F0NEQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQ0RCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQ0RCh4MVRlbnNvciwgeDJUZW5zb3IsIGF4aXMsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQ0RC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlY2VuQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZWNlbkFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZWNlbkFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBjb25jYXRSZXN1bHQgPSBtYXRoLmNvbmNhdDREKHgxLCB4MiwgX3RoaXMuYXhpcyk7XG4gICAgICAgICAgICBpbmZlcmVjZW5BcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY29uY2F0UmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29uY2F0NEQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25jYXRCYWNrUHJvcChtYXRoLCBfdGhpcy54MVRlbnNvciwgX3RoaXMueDJUZW5zb3IsIF90aGlzLnlUZW5zb3IsIF90aGlzLmF4aXMsIGdyYWRpZW50QXJyYXlzLCBpbmZlcmVuY2VBcnJheXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQ0RDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0NEQgPSBDb25jYXQ0RDtcbmZ1bmN0aW9uIGNvbmNhdEJhY2tQcm9wKG1hdGgsIGFUZW5zb3IsIGJUZW5zb3IsIHlUZW5zb3IsIGF4aXMsIGdyYWRBcnJheXMsIGluZkFycmF5cykge1xuICAgIHZhciBkeSA9IGdyYWRBcnJheXMuZ2V0KHlUZW5zb3IpO1xuICAgIHZhciBhID0gaW5mQXJyYXlzLmdldChhVGVuc29yKTtcbiAgICB2YXIgYiA9IGluZkFycmF5cy5nZXQoYlRlbnNvcik7XG4gICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgdXRpbC5zaXplRnJvbVNoYXBlKGEuc2hhcGUuc2xpY2UoYXhpcykpKTtcbiAgICB2YXIgYjJEID0gYi5hczJEKC0xLCB1dGlsLnNpemVGcm9tU2hhcGUoYi5zaGFwZS5zbGljZShheGlzKSkpO1xuICAgIHZhciBfYSA9IGNvbmNhdF91dGlsLmNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzKGEyRC5zaGFwZSwgYjJELnNoYXBlKSwgYUJlZ2luID0gX2EuYUJlZ2luLCBhU2l6ZSA9IF9hLmFTaXplLCBiQmVnaW4gPSBfYS5iQmVnaW4sIGJTaXplID0gX2EuYlNpemU7XG4gICAgdmFyIGR5MkQgPSBkeS5hczJEKC0xLCBhMkQuc2hhcGVbMV0gKyBiMkQuc2hhcGVbMV0pO1xuICAgIHZhciBzbGljZTFSZXN1bHQgPSBtYXRoLnNsaWNlMkQoZHkyRCwgYUJlZ2luLCBhU2l6ZSkucmVzaGFwZUFzKGEpO1xuICAgIHZhciBzbGljZTJSZXN1bHQgPSBtYXRoLnNsaWNlMkQoZHkyRCwgYkJlZ2luLCBiU2l6ZSkucmVzaGFwZUFzKGIpO1xuICAgIGdyYWRBcnJheXMuYWRkKGFUZW5zb3IsIHNsaWNlMVJlc3VsdCk7XG4gICAgZ3JhZEFycmF5cy5hZGQoYlRlbnNvciwgc2xpY2UyUmVzdWx0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2NvbnZfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIENvbnZvbHV0aW9uMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252b2x1dGlvbjJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnZvbHV0aW9uMkQod1RlbnNvciwgeFRlbnNvciwgYlRlbnNvciwgeVRlbnNvciwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndUZW5zb3IgPSB3VGVuc29yO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMuYlRlbnNvciA9IGJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLm91dHB1dERlcHRoID0gb3V0cHV0RGVwdGg7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuYXNzZXJ0V2VpZ2h0c1NoYXBlKHdUZW5zb3Iuc2hhcGUpO1xuICAgICAgICBfdGhpcy56ZXJvUGFkID0gemVyb1BhZCAhPSBudWxsID9cbiAgICAgICAgICAgIHplcm9QYWQgOlxuICAgICAgICAgICAgY29udl91dGlsLmNvbXB1dGVEZWZhdWx0UGFkKF90aGlzLnhUZW5zb3Iuc2hhcGUsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChfdGhpcy56ZXJvUGFkKSwgXCJUaGUgemVybyBwYWRkaW5nIChcIiArIF90aGlzLnplcm9QYWQgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnZvbHV0aW9uMkQucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKTtcbiAgICAgICAgdmFyIGJpYXNlcyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5iVGVuc29yKTtcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmNvbnYyZCh4LCB3ZWlnaHRzLCBiaWFzZXMsIF90aGlzLnN0cmlkZSwgX3RoaXMuemVyb1BhZCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcik7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHcgPSBtYXRoLmNvbnYyZERlckZpbHRlcih4LCBkeSwgZmlsdGVyLnNoYXBlLCBfdGhpcy5zdHJpZGUsIF90aGlzLnplcm9QYWQpO1xuICAgICAgICAgICAgdmFyIGRiID0gbWF0aC5jb252MmREZXJCaWFzKGR5KTtcbiAgICAgICAgICAgIHZhciBkeCA9IG1hdGguY29udjJkRGVySW5wdXQoeC5zaGFwZSwgZHksIGZpbHRlciwgX3RoaXMuc3RyaWRlLCBfdGhpcy56ZXJvUGFkKTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy53VGVuc29yLCBkdyk7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMuYlRlbnNvciwgZGIpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIGR4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5hc3NlcnRXZWlnaHRzU2hhcGUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHdlaWdodHNTaGFwZVswXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsxXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsyXSA9PT0gdGhpcy54VGVuc29yLnNoYXBlWzJdICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbM10gPT09IHRoaXMub3V0cHV0RGVwdGgsIFwid2VpZ2h0cyBtdXN0IGJlIG9mIHNoYXBlIFtcIiArIHRoaXMuZmllbGRTaXplICsgXCIsXCIgKyB0aGlzLmZpZWxkU2l6ZSArIFwiLFwiICtcbiAgICAgICAgICAgICh0aGlzLnhUZW5zb3Iuc2hhcGVbMl0gKyBcIixcIiArIHRoaXMub3V0cHV0RGVwdGggKyBcIl0gYnV0IHRoZXkgYXJlIG9mXCIpICtcbiAgICAgICAgICAgIChcInNoYXBlIFtcIiArIHdlaWdodHNTaGFwZSArIFwiXVwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udm9sdXRpb24yRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29udm9sdXRpb24yRCA9IENvbnZvbHV0aW9uMkQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252b2x1dGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIERpdmlkZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGUoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpdmlkZS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmRpdmlkZSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpdmlkZS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIHgxSXNTY2FsYXIgPSB1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpO1xuICAgICAgICB2YXIgeDJJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IG1hdGguZGl2aWRlKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0oZGl2KSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKGR5LCB4MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDJTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgeDIpO1xuICAgICAgICAgICAgICAgIHZhciB4MU92ZXJYMlNxdWFyZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5kaXZpZGUoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm5lZyh4MU92ZXJYMlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzRGVyaXZhdGl2ZSA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR4Mik7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShkeVRpbWVzRGVyaXZhdGl2ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBkeVRpbWVzRGVyaXZhdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXZpZGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkRpdmlkZSA9IERpdmlkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpdmlkZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFjdGl2YXRpb25fZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vYWN0aXZhdGlvbl9mdW5jdGlvbnNcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRXaXNlQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50V2lzZUFjdGl2YXRpb24oeFRlbnNvciwgeVRlbnNvciwgZnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoX3RoaXMuZnVuYy5vdXRwdXQobWF0aCwgeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHlkeCA9IF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgsIHkpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR5ZHgpKTtcbiAgICAgICAgICAgIGR5ZHguZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50V2lzZUFjdGl2YXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IEVsZW1lbnRXaXNlQWN0aXZhdGlvbjtcbnZhciBSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUxVKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlJlTFVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZUxVO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuUmVMVSA9IFJlTFU7XG52YXIgTGVha3lSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVha3lSZUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlYWt5UmVMVSh4VGVuc29yLCB5VGVuc29yLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuTGVha3lSZWx1RnVuYyhhbHBoYSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBMZWFreVJlTFU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5MZWFreVJlTFUgPSBMZWFreVJlTFU7XG52YXIgVGFuSCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuSCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5UYW5IRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFuSDtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlRhbkggPSBUYW5IO1xudmFyIFNpZ21vaWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWdtb2lkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWQoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuU2lnbW9pZEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ21vaWQ7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TaWdtb2lkID0gU2lnbW9pZDtcbnZhciBTcXVhcmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcXVhcmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3F1YXJlKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlNxdWFyZUZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNxdWFyZTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNxdWFyZSA9IFNxdWFyZTtcbnZhciBFbHUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbHUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWx1KHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLkVsdUZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEVsdTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLkVsdSA9IEVsdTtcbnZhciBQUmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBSZUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBSZUxVKHhUZW5zb3IsIGFscGhhVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy5hbHBoYVRlbnNvciA9IGFscGhhVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQUmVMVS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYWxwaGFUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5wcmVsdSh4LCBhbHBoYSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQUmVMVS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFBSZUxVO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5QUmVMVSA9IFBSZUxVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF93aXNlX2FjdGl2YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIGNvc3RfZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb3N0X2Z1bmN0aW9uc1wiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEVsZW1lbnRXaXNlQ29zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRXaXNlQ29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50V2lzZUNvc3QoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yLCBmdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgX3RoaXMub25lT3Zlck5TY2FsYXIgPVxuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYubWF0aC5rZWVwKG5kYXJyYXlfMS5TY2FsYXIubmV3KDEgLyB1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFdpc2VDb3N0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRXaXNlQ29zdCA9IF90aGlzLmZ1bmMuY29zdChtYXRoLCB4MSwgeDIpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGVsZW1lbnRXaXNlQ29zdCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KF90aGlzLm9uZU92ZXJOU2NhbGFyLCBzdW0pO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgX3RoaXMuZnVuYy5kZXIobWF0aCwgeDEsIHgyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgyLCB4MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVPdmVyTlNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFdpc2VDb3N0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FbGVtZW50V2lzZUNvc3QgPSBFbGVtZW50V2lzZUNvc3Q7XG52YXIgTWVhblNxdWFyZWRDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhblNxdWFyZWRDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYW5TcXVhcmVkQ29zdCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgbmV3IGNvc3RfZnVuY3Rpb25zXzEuU3F1YXJlQ29zdEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lYW5TcXVhcmVkQ29zdDtcbn0oRWxlbWVudFdpc2VDb3N0KSk7XG5leHBvcnRzLk1lYW5TcXVhcmVkQ29zdCA9IE1lYW5TcXVhcmVkQ29zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfd2lzZV9jb3N0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFeHAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5leHAoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFeHAucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHkgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnhUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeSwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FeHAgPSBFeHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIExpbmVhckNvbWJpbmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZWFyQ29tYmluYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29tYmluYXRpb24oeDFUZW5zb3IsIHgyVGVuc29yLCBjMVRlbnNvciwgYzJUZW5zb3IsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5jMVRlbnNvciA9IGMxVGVuc29yO1xuICAgICAgICBfdGhpcy5jMlRlbnNvciA9IGMyVGVuc29yO1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGluZWFyQ29tYmluYXRpb24ucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgYzEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzFUZW5zb3IpLmFzU2NhbGFyKCk7XG4gICAgICAgIHZhciBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcikuYXNTY2FsYXIoKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAobWF0aC5zY2FsZWRBcnJheUFkZChjMSwgeDEsIGMyLCB4MikpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW5lYXJDb21iaW5hdGlvbi5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgYzEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzFUZW5zb3IpO1xuICAgICAgICB2YXIgYzIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KGMxLCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzIsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy5jMVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZHVjdDEgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmMxVGVuc29yLCBtYXRoLnN1bShkb3RQcm9kdWN0MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMuYzJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvdFByb2R1Y3QyID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5jMlRlbnNvciwgbWF0aC5zdW0oZG90UHJvZHVjdDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFyQ29tYmluYXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkxpbmVhckNvbWJpbmF0aW9uID0gTGluZWFyQ29tYmluYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lYXJfY29tYmluYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2coeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9nLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmxvZyh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueFRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5kaXZpZGUoZHksIHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Mb2cgPSBMb2c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2JhY2tlbmRzL3R5cGVzL21hdG11bFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE1hdE11bCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdE11bCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWwoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hdE11bC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF0TXVsKHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5tYXRyaXhUaW1lc1ZlY3Rvcih4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgudmVjdG9yVGltZXNNYXRyaXgoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdE11bC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgeDEgPSB4MS5yZXNoYXBlKFsxLCB4MS5zaXplXSk7XG4gICAgICAgICAgICBkeSA9IGR5LnJlc2hhcGUoWzEsIGR5LnNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB4MiA9IHgyLnJlc2hhcGUoW3gyLnNpemUsIDFdKTtcbiAgICAgICAgICAgIGR5ID0gZHkucmVzaGFwZShbZHkuc2l6ZSwgMV0pO1xuICAgICAgICB9XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4MSA9IG1hdGgubWF0TXVsKGR5LCB4MiwgbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUiwgbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBfdGhpcy54MVRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDEuYXMxRCgpIDogZHgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm1hdE11bCh4MSwgZHksIG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQsIG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgX3RoaXMueDJUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAxID8gZHgyLmFzMUQoKSA6IGR4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdE11bDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTWF0TXVsID0gTWF0TXVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0bXVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTWF4UG9vbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heFBvb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4UG9vbCh4VGVuc29yLCB5VGVuc29yLCBmaWVsZFNpemUsIHN0cmlkZSwgcGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIGlmIChwYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMucGFkID0gcGFkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMucGFkID0gY29udl91dGlsLmNvbXB1dGVEZWZhdWx0UGFkKHhUZW5zb3Iuc2hhcGUsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KF90aGlzLnBhZCksIFwiVGhlIHplcm8gcGFkZGluZyAoXCIgKyBfdGhpcy5wYWQgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1heFBvb2wucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF4UG9vbCh4LCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSwgX3RoaXMucGFkKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1heFBvb2wucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLm1heFBvb2xCYWNrcHJvcChkeSwgeCwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUsIF90aGlzLnBhZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXhQb29sO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NYXhQb29sID0gTWF4UG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heF9wb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTXVsdGlwbHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseSh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDIsIHQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguZWxlbWVudFdpc2VNdWwodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNdWx0aXBseS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngxVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gbWF0aC5lbGVtZW50V2lzZU11bChkeSwgeDIpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguc3VtKG11bCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KHgyLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4MSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5zdW0obXVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDEsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeDEsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aXBseTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTXVsdGlwbHkgPSBNdWx0aXBseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGx5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9wZXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uKCkge1xuICAgIH1cbiAgICBPcGVyYXRpb24ucHJvdG90eXBlLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMgPSBmdW5jdGlvbiAoaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykgeyB9O1xuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gT3BlcmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gT3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgUmVkdWNlU3VtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVkdWNlU3VtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZHVjZVN1bSh4LCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLm91dFRlbnNvciA9IG91dFRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChvdXRUZW5zb3Iuc2hhcGUsIFtdKTtcbiAgICAgICAgX3RoaXMub25lcyA9IGVudmlyb25tZW50XzEuRU5WLm1hdGgua2VlcChuZGFycmF5XzEuTkRBcnJheS5vbmVzKHguc2hhcGUpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54KTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAobWF0aC5zdW0oeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldChfdGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngsIG1hdGguc2NhbGFyVGltZXNBcnJheShkeSwgX3RoaXMub25lcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbmVzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWR1Y2VTdW07XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlJlZHVjZVN1bSA9IFJlZHVjZVN1bTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV9zdW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFJlc2hhcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNoYXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2hhcGUoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHZhciB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh4VGVuc29yLnNoYXBlKTtcbiAgICAgICAgdmFyIHlTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHlUZW5zb3Iuc2hhcGUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2l6ZSA9PT0geVNpemUsIFwiVGhlIGlucHV0IHNpemUgKFwiICsgeFNpemUgKyBcIikgYW5kIG91dHB1dCBzaXplIChcIiArIHlTaXplICsgXCIpIG11c3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzaGFwZS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgY2xvbmUgPSBtYXRoLmNsb25lKHgpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY2xvbmUucmVzaGFwZShfdGhpcy55VGVuc29yLnNoYXBlKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBjbG9uZSA9IG1hdGguY2xvbmUoZHkpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBjbG9uZS5yZXNoYXBlKF90aGlzLnhUZW5zb3Iuc2hhcGUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzaGFwZTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuUmVzaGFwZSA9IFJlc2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNoYXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU29mdG1heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heChsb2dpdHNUZW5zb3IsIG91dHB1dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dpdHNUZW5zb3IgPSBsb2dpdHNUZW5zb3I7XG4gICAgICAgIF90aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpO1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRwdXQsIGtlZXAobWF0aC5zb2Z0bWF4KGxvZ2l0cykpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLm91dHB1dCk7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dHB1dCk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMubG9naXRzVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkbG9naXRzID0gbWF0aC5lbGVtZW50V2lzZU11bChtYXRoLnN1YnRyYWN0KGR5LCBtYXRoLnN1bShtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB5KSkpLCB5KTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMubG9naXRzVGVuc29yLCBkbG9naXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU29mdG1heCA9IFNvZnRtYXg7XG52YXIgU29mdG1heENyb3NzRW50cm9weUNvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdChsb2dpdHNUZW5zb3IsIGxhYmVsVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvZ2l0c1RlbnNvciA9IGxvZ2l0c1RlbnNvcjtcbiAgICAgICAgX3RoaXMubGFiZWxUZW5zb3IgPSBsYWJlbFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLnNvZnRtYXhUZW5zb3IgPSBuZXcgZ3JhcGhfMS5UZW5zb3IobG9naXRzVGVuc29yLnNoYXBlKTtcbiAgICAgICAgX3RoaXMuZXBzaWxvbiA9IGVudmlyb25tZW50XzEuRU5WLm1hdGgua2VlcChuZGFycmF5XzEuU2NhbGFyLm5ldygxZS01KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9naXRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxvZ2l0c1RlbnNvcik7XG4gICAgICAgIHZhciBsYWJlbCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sYWJlbFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBzb2Z0bWF4UmVzdWx0ID0gbWF0aC5zb2Z0bWF4KGxvZ2l0cyk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnNvZnRtYXhUZW5zb3IsIGtlZXAoc29mdG1heFJlc3VsdCkpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKGNyb3NzRW50cm9weUNvc3QobWF0aCwgc29mdG1heFJlc3VsdCwgbGFiZWwsIF90aGlzLmVwc2lsb24pKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvZnRtYXggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuc29mdG1heFRlbnNvcik7XG4gICAgICAgIHZhciBsYWJlbCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sYWJlbFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmxvZ2l0c1RlbnNvciwgbWF0aC5zdWJ0cmFjdChzb2Z0bWF4LCBsYWJlbCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5kaXNwb3NlVHJhbnNpZW50QXJyYXlzID0gZnVuY3Rpb24gKGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgaW5mZXJlbmNlQXJyYXlzLmRpc3Bvc2VBcnJheSh0aGlzLnNvZnRtYXhUZW5zb3IpO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG5mdW5jdGlvbiBjcm9zc0VudHJvcHlDb3N0KG1hdGgsIHksIHRhcmdldCwgZXBzaWxvbikge1xuICAgIHV0aWwuYXNzZXJ0KHkuc2l6ZSA9PT0gdGFyZ2V0LnNpemUsICdUaGUgb3V0cHV0IGFuZCB0YXJnZXQgbXVzdCBiZSB0aGUgc2FtZSBzaXplJyk7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeVBsdXNFcHMgPSBtYXRoLnNjYWxhclBsdXNBcnJheShlcHNpbG9uLCB5KTtcbiAgICAgICAgdmFyIGxvZ091dHB1dCA9IG1hdGgubG9nKHlQbHVzRXBzKTtcbiAgICAgICAgdmFyIHRhckxvZ091dHB1dCA9IG1hdGguZWxlbWVudFdpc2VNdWwodGFyZ2V0LCBsb2dPdXRwdXQpO1xuICAgICAgICB2YXIgY29zdFZlY3RvciA9IG1hdGgubmVnKHRhckxvZ091dHB1dCk7XG4gICAgICAgIHJldHVybiBtYXRoLnN1bShjb3N0VmVjdG9yKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3Jvc3NFbnRyb3B5Q29zdCA9IGNyb3NzRW50cm9weUNvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2Z0bWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU3VidHJhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJ0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdCh0MSwgdDIsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodDEuc2hhcGUsIHQyLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDEpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDIpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhck1pbnVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5TWludXNTY2FsYXIodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc3VidHJhY3QodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRyYWN0LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMudDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy50MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQxLCBzdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQxLCBtYXRoLmNsb25lKGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMudDIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy50Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ1N1bSA9IG1hdGgubmVnKHN1bSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbmVnU3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbWF0aC5uZWcoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJ0cmFjdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU3VidHJhY3QgPSBTdWJ0cmFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnRyYWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL29wdGltaXplcnMvb3B0aW1pemVyXCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIEFkYWRlbHRhT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZGVsdGFPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhZGVsdGFPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBnYW1tYSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmdhbW1hID0gZ2FtbWE7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS02KTtcbiAgICAgICAgX3RoaXMuZyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmdhbW1hKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWRhZGVsdGEgb3B0aW1pemVyIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIGVhZ2VyIG1vZGUuXCIpO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFVwZGF0ZXMgPSBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRDYWNoZSwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmcpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXMgPSBtYXRoLm11bHRpcGx5KG1hdGguZGl2aWRlKG1hdGguc3FydChtYXRoLmFkZChvbGRVcGRhdGVzLCBfdGhpcy5lcHMpKSwgbWF0aC5zcXJ0KG1hdGguYWRkKG9sZENhY2hlLCBfdGhpcy5lcHMpKSksIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmNHcmFwaCwgdXBkYXRlcywgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVNxdWFyZSA9IG1hdGgubXVsdGlwbHkodXBkYXRlcywgdXBkYXRlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VwZGF0ZXMgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmcsIG9sZFVwZGF0ZXMsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5nKSwgdXBkYXRlU3F1YXJlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLnNldChub2RlLm91dHB1dCwga2VlcChuZXdVcGRhdGVzKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVXBkYXRlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYWRlbHRhT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBBZGFkZWx0YU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWRlbHRhX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9vcHRpbWl6ZXJzL29wdGltaXplclwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBBZGFncmFkT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZ3JhZE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWRhZ3JhZCBvcHRpbWl6ZXIgbm90IHlldCBpbXBsZW1lbnRlZCBmb3IgZWFnZXIgbW9kZS5cIik7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLmFkZChvbGRDYWNoZSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuY0dyYXBoLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhZ3JhZE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBBZGFncmFkT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhZ3JhZF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvb3B0aW1pemVycy9vcHRpbWl6ZXJcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgQWRhbU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhbU9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTgpO1xuICAgICAgICBfdGhpcy5iMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIF90aGlzLmFjY0IxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICBfdGhpcy5hY2NCMiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGEyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGFtIG9wdGltaXplciBub3QgeWV0IGltcGxlbWVudGVkIGZvciBlYWdlciBtb2RlLlwiKTtcbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0TW9tZW50LnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWNvbmRNb21lbnQuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlY29uZE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRGaXJzdE1vbWVudCA9IF90aGlzLmZpcnN0TW9tZW50LmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNlY29uZE1vbWVudCA9IF90aGlzLnNlY29uZE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYjEsIG9sZEZpcnN0TW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYjEpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdTZWNvbmRNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIyLCBvbGRTZWNvbmRNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5iMiksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50ID0gbWF0aC5kaXZpZGUobmV3Rmlyc3RNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5hY2NCMSkpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50ID0gbWF0aC5kaXZpZGUobmV3U2Vjb25kTW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYWNjQjIpKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmNHcmFwaCwgbWF0aC5kaXZpZGUoYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCksIF90aGlzLmVwcykpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld0ZpcnN0TW9tZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdTZWNvbmRNb21lbnQpKTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZEZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRTZWNvbmRNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb2xkQWNjQjEgPSBfdGhpcy5hY2NCMTtcbiAgICAgICAgICAgIHZhciBvbGRBY2NCMiA9IF90aGlzLmFjY0IyO1xuICAgICAgICAgICAgX3RoaXMuYWNjQjEgPSBrZWVwKG1hdGgubXVsdGlwbHkoX3RoaXMuYWNjQjEsIF90aGlzLmIxKSk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMiA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMiwgX3RoaXMuYjIpKTtcbiAgICAgICAgICAgIG9sZEFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIG9sZEFjY0IyLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZmlyc3RNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnNlY29uZE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCMi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhbU9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1PcHRpbWl6ZXIgPSBBZGFtT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhbV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvb3B0aW1pemVycy9vcHRpbWl6ZXJcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgQWRhbWF4T3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhbWF4T3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYW1heE9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy53ZWlnaHRlZEluZk5vcm0gPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTgpO1xuICAgICAgICBfdGhpcy5iMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIF90aGlzLmFjY0IxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWRhbWF4IG9wdGltaXplciBub3QgeWV0IGltcGxlbWVudGVkIGZvciBlYWdlciBtb2RlLlwiKTtcbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RNb21lbnQuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlaWdodGVkSW5mTm9ybS5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2VpZ2h0ZWRJbmZOb3JtLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRXZWlnaHRlZEluZk5vcm0gPSBfdGhpcy53ZWlnaHRlZEluZk5vcm0uZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIxLCBvbGRGaXJzdE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmIxKSwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciB1dDAgPSBtYXRoLm11bHRpcGx5KF90aGlzLmIyLCBvbGRXZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciB1dDEgPSBtYXRoLmFicyhncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1dlaWdodGVkSW5mTm9ybSA9IG1hdGguYWRkKG1hdGgucmVsdShtYXRoLnN1YnRyYWN0KHV0MCwgdXQxKSksIHV0MSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5vbmUsIG9sZFZhcmlhYmxlLCBtYXRoLmRpdmlkZVN0cmljdChfdGhpcy5jR3JhcGgsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5hY2NCMSkpLCBtYXRoLmRpdmlkZShuZXdGaXJzdE1vbWVudCwgbWF0aC5hZGQoX3RoaXMuZXBzLCBuZXdXZWlnaHRlZEluZk5vcm0pKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdGaXJzdE1vbWVudCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybS5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3V2VpZ2h0ZWRJbmZOb3JtKSk7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRGaXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkV2VpZ2h0ZWRJbmZOb3JtLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG9sZEFjY0IxID0gX3RoaXMuYWNjQjE7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMSA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMSwgX3RoaXMuYjEpKTtcbiAgICAgICAgICAgIG9sZEFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMud2VpZ2h0ZWRJbmZOb3JtLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYW1heE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IEFkYW1heE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYW1heF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL29wdGltaXplcnMvc2dkX29wdGltaXplclwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBNb21lbnR1bU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbWVudHVtT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbWVudHVtT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgbW9tZW50dW0sIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgICAgICBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLm0gPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5tb21lbnR1bSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vbWVudHVtIG9wdGltaXplciBub3QgeWV0IGltcGxlbWVudGVkIGZvciBlYWdlciBtb2RlLlwiKTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmVsb2NpdHkgPSBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLm0sIG9sZFZlbG9jaXR5LCBfdGhpcy5vbmUsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmNHcmFwaCwgdmVsb2NpdHksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmVsb2NpdHkpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFZlbG9jaXR5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVWZWxvY2l0aWVzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5zZXRNb21lbnR1bSA9IGZ1bmN0aW9uIChtb21lbnR1bSkge1xuICAgICAgICB0aGlzLm1vbWVudHVtID0gbW9tZW50dW07XG4gICAgfTtcbiAgICByZXR1cm4gTW9tZW50dW1PcHRpbWl6ZXI7XG59KHNnZF9vcHRpbWl6ZXJfMS5TR0RPcHRpbWl6ZXIpKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBNb21lbnR1bU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbWVudHVtX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9vcHRpbWl6ZXJzL29wdGltaXplclwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBSTVNQcm9wT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUk1TUHJvcE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSTVNQcm9wT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgZ2FtbWEsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5nYW1tYSA9IGdhbW1hO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTYpO1xuICAgICAgICBfdGhpcy5nID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuZ2FtbWEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJNU1Byb3Agb3B0aW1pemVyIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIGVhZ2VyIG1vZGUuXCIpO1xuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRDYWNoZSwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmcpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jR3JhcGgsIG1hdGguZGl2aWRlKGdyYWRpZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoY2FjaGUpLCBfdGhpcy5lcHMpKSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChjYWNoZSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkQ2FjaGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBSTVNQcm9wT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuUk1TUHJvcE9wdGltaXplciA9IFJNU1Byb3BPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybXNwcm9wX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0Q29tcGFyZSA9IGRlZmF1bHRDb21wYXJlO1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoY29tcGFyYXRvciwgaW5kZXhPYnNlcnZlcikge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmluZGV4T2JzZXJ2ZXIgPSBpbmRleE9ic2VydmVyO1xuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICB9XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaGVhcC5wdXNoKHQpO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHQsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5zaWZ0VXAodGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXF1ZXVlIGNhbGxlZCBvbiBlbXB0eSBwcmlvcml0eSBxdWV1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgdGhpcy5zd2FwKDAsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5oZWFwLnBvcCgpO1xuICAgICAgICB0aGlzLnNpZnREb3duKDApO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdULCBpbmRleCkge1xuICAgICAgICB2YXIgbGFzdCA9IChpbmRleCA9PT0gdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWZ0VXBJbmRleChpbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWZ0VXAoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZnREb3duKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVucXVldWUobmV3VCk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5vbkluZGV4Q2hhbmdlZCA9IGZ1bmN0aW9uICh0LCBuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4T2JzZXJ2ZXIodCwgbmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRQYXJlbnRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0TGVmdENoaWxkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDE7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRSaWdodENoaWxkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDI7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0VXBJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmUocGFyZW50SW5kZXgsIGluZGV4KSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0VXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNpZnRJbmRleCA9IHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpO1xuICAgICAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICAgICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd25JbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXJnZXN0Q2hpbGRJbmRleCA9IGluZGV4O1xuICAgICAgICB2YXIgbGVmdENoaWxkSW5kZXggPSB0aGlzLmdldExlZnRDaGlsZEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKChsZWZ0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICAgICAodGhpcy5jb21wYXJlKGxlZnRDaGlsZEluZGV4LCBsYXJnZXN0Q2hpbGRJbmRleCkgPCAwKSkge1xuICAgICAgICAgICAgbGFyZ2VzdENoaWxkSW5kZXggPSBsZWZ0Q2hpbGRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmlnaHRDaGlsZEluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoKHJpZ2h0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICAgICAodGhpcy5jb21wYXJlKHJpZ2h0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgICAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gcmlnaHRDaGlsZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGFyZ2VzdENoaWxkSW5kZXggPT09IGluZGV4KSA/IC0xIDogbGFyZ2VzdENoaWxkSW5kZXg7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0RG93biA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICAgICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhSW5kZXgsIGJJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFthSW5kZXhdLCB0aGlzLmhlYXBbYkluZGV4XSk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmhlYXBbYV07XG4gICAgICAgIHRoaXMuaGVhcFthXSA9IHRoaXMuaGVhcFtiXTtcbiAgICAgICAgdGhpcy5oZWFwW2JdID0gdGVtcDtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0aGlzLmhlYXBbYV0sIGEpO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHRoaXMuaGVhcFtiXSwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZTtcbn0oKSk7XG5leHBvcnRzLlByaW9yaXR5UXVldWUgPSBQcmlvcml0eVF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpb3JpdHlfcXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uX2VtaXR0ZXIgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25fZW1pdHRlclwiKTtcbnZhciBzZXNzaW9uX3V0aWwgPSByZXF1aXJlKFwiLi9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBGZWVkRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgICAgIGlmIChmZWVkRW50cmllcykge1xuICAgICAgICAgICAgZmVlZEVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF90aGlzLmRpY3RbZW50cnkudGVuc29yLmlkXSA9IGVudHJ5OyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRmVlZERpY3Rpb25hcnk7XG59KCkpO1xuZXhwb3J0cy5GZWVkRGljdGlvbmFyeSA9IEZlZWREaWN0aW9uYXJ5O1xudmFyIENvc3RSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKENvc3RSZWR1Y3Rpb24pIHtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJTVU1cIl0gPSAxXSA9IFwiU1VNXCI7XG4gICAgQ29zdFJlZHVjdGlvbltDb3N0UmVkdWN0aW9uW1wiTUVBTlwiXSA9IDJdID0gXCJNRUFOXCI7XG59KShDb3N0UmVkdWN0aW9uID0gZXhwb3J0cy5Db3N0UmVkdWN0aW9uIHx8IChleHBvcnRzLkNvc3RSZWR1Y3Rpb24gPSB7fSkpO1xudmFyIFNlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlc3Npb24oZ3JhcGgsIG1hdGgpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIHRoaXMucnVudGltZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMub25lU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRBcnJheU1hcCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuU3VtbWVkVGVuc29yQXJyYXlNYXAodGhpcy5tYXRoKTtcbiAgICB9XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAuZGlzcG9zZSgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJ1bnRpbWVDYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IF90aGlzLnJ1bnRpbWVDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKHJ1bnRpbWUub3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVudGltZUNhY2hlID0ge307XG4gICAgICAgIGlmICh0aGlzLmJhdGNoU2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmVTY2FsYXIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZXZhbEFsbCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkRW50cmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmZWVkID0gbmV3IEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gX3RoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICAgICAgdmFyIGFjdGl2YXRpb25zID0gX3RoaXMuYWN0aXZhdGlvbkFycmF5TWFwO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhydW50aW1lLm9wZXJhdGlvbnMsIF90aGlzLmFjdGl2YXRpb25BcnJheU1hcCwgX3RoaXMuZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZmVlZEZvcndhcmQoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjdGl2YXRpb25zLmdldCh4KTsgfSk7XG4gICAgICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjdGl2YXRpb25zLmRlbGV0ZSh4KTsgfSk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAodGVuc29yLCBmZWVkRW50cmllcykge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsQWxsKFt0ZW5zb3JdLCBmZWVkRW50cmllcylbMF07XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS50cmFpbiA9IGZ1bmN0aW9uIChjb3N0VGVuc29yLCBmZWVkRW50cmllcywgYmF0Y2hTaXplLCBvcHRpbWl6ZXIsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyBjb3N0UmVkdWN0aW9uID0gQ29zdFJlZHVjdGlvbi5OT05FOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNTY2FsYXJTaGFwZShjb3N0VGVuc29yLnNoYXBlKSwgJ0Nvc3QgdGVuc29yIGZvciB0cmFpbmluZyBtdXN0IGJlIGEgc2NhbGFyIHZhbHVlLicpO1xuICAgICAgICBpZiAodGhpcy5wcmV2QmF0Y2hTaXplICE9PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoU2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIgPSB0aGlzLm1hdGgua2VlcChuZGFycmF5XzEuU2NhbGFyLm5ldyhiYXRjaFNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICAgIHNlc3Npb25fdXRpbC50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzKGZlZWQpO1xuICAgICAgICB2YXIgcnVudGltZSA9IHRoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKFtjb3N0VGVuc29yXSwgZmVlZCk7XG4gICAgICAgIHZhciBpbmZlcmVuY2VPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zO1xuICAgICAgICB2YXIgYmFja1Byb3BPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgYWN0aXZhdGlvbnMgPSB0aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHRoaXMuZ3JhZGllbnRBcnJheU1hcDtcbiAgICAgICAgZ3JhZGllbnRzLm51bGxpZnkoY29zdFRlbnNvcik7XG4gICAgICAgIGdyYWRpZW50cy5hZGQoY29zdFRlbnNvciwgdGhpcy5vbmVTY2FsYXIpO1xuICAgICAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICBvcHRpbWl6ZXIuYmVmb3JlQmF0Y2godGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb3N0ID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoU2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMocnVudGltZS5ub2RlcywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhydW50aW1lLm9wZXJhdGlvbnMsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlT3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZmVlZEZvcndhcmQoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMpOyB9KTtcbiAgICAgICAgICAgICAgICBiYWNrUHJvcE9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmJhY2tQcm9wKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpOyB9KTtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZXIuYWZ0ZXJFeGFtcGxlKF90aGlzLm1hdGgsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgIGNvc3QgPSBfdGhpcy51cGRhdGVDb3N0Rm9yRXhhbXBsZShjb3N0LCBhY3RpdmF0aW9ucy5nZXQoY29zdFRlbnNvciksIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW1pemVyLmFmdGVyQmF0Y2goX3RoaXMubWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVDb3N0Rm9yQmF0Y2goY29zdCwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlQ29zdEZvckV4YW1wbGUgPSBmdW5jdGlvbiAodG90YWxDb3N0LCBjdXJyQ29zdCwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOIHx8XG4gICAgICAgICAgICBjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLlNVTSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5hZGQodG90YWxDb3N0LCBjdXJyQ29zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUNvc3RGb3JCYXRjaCA9IGZ1bmN0aW9uICh0b3RhbENvc3QsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5kaXZpZGUodG90YWxDb3N0LCB0aGlzLmJhdGNoU2l6ZVNjYWxhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmdldE9yQ3JlYXRlUnVudGltZSA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLm1ha2VSdW50aW1lQ2FjaGVLZXkodGVuc29ycywgZmVlZCk7XG4gICAgICAgIHZhciBydW50aW1lID0gdGhpcy5ydW50aW1lQ2FjaGVba2V5XTtcbiAgICAgICAgaWYgKHJ1bnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gc2Vzc2lvbl91dGlsLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IodGVuc29ycywgZmVlZCk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGZlZWQsIG5vZGVzKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC50aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gb3BlcmF0aW9uX2VtaXR0ZXIuZW1pdEZyb21HcmFwaE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgIHJ1bnRpbWUgPSB7IG5vZGVzOiBub2Rlcywgb3BlcmF0aW9uczogb3BlcmF0aW9ucyB9O1xuICAgICAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGVba2V5XSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bnRpbWU7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5tYWtlUnVudGltZUNhY2hlS2V5ID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KS5zb3J0KCkuam9pbignXycpICsgJ19fJyArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmZWVkLmRpY3QpLnNvcnQoKS5qb2luKCdfJyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oKSk7XG5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuL2dyYXBoX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5KGZlZWREaWN0aW9uYXJ5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRlbnNvcklEKSB7IHJldHVybiBmZWVkRGljdGlvbmFyeS5kaWN0Wyt0ZW5zb3JJRF0udGVuc29yLm5vZGU7IH0pO1xufVxuZXhwb3J0cy5nZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5ID0gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeTtcbmZ1bmN0aW9uIGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IoZXZhbFRlbnNvcnMsIGZlZWREaWN0aW9uYXJ5KSB7XG4gICAgdmFyIHRlcm1pbmF0aW5nTm9kZXMgPSBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5KGZlZWREaWN0aW9uYXJ5KTtcbiAgICB2YXIgZXZhbE5vZGVzID0gZXZhbFRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5vZGU7IH0pO1xuICAgIHZhciB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ3JhcGhfdXRpbC5nZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KGV2YWxOb2RlcywgdGVybWluYXRpbmdOb2Rlcyk7XG4gICAgdmFyIG9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ3JhcGhfdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0KTtcbiAgICByZXR1cm4gb3JkZXJlZEV2YWx1YXRpb25TZXQ7XG59XG5leHBvcnRzLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IgPSBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yO1xuZnVuY3Rpb24gYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAoZXZhbHVhdGlvblNldCwgdGVuc29yQXJyYXlNYXApIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlZhcmlhYmxlTm9kZSB8fCBub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25zdGFudE5vZGUpIHtcbiAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbm9kZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcCA9IGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwO1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMuZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0ID0gZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gdGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyhmZWVkRGljdGlvbmFyeSkge1xuICAgIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0Wyt0ZW5zb3JJRF0uZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWluaW5nIHJlcXVpcmVzIEZlZWREaWN0aW9uYXJ5IGVudHJpZXMgdG8gYmUgSW5wdXRQcm92aWRlcnMnICtcbiAgICAgICAgICAgICAgICAnYW5kIG5vdCBOREFycmF5cy4nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzID0gdGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cztcbmZ1bmN0aW9uIGxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGJhdGNoRmVlZCwgYWN0aXZhdGlvbnMsIG1hdGgpIHtcbiAgICBPYmplY3Qua2V5cyhiYXRjaEZlZWQuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGJhdGNoRmVlZC5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgICAgICBkYXRhID0gcHJvdmlkZXIuZ2V0TmV4dENvcHkobWF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbChmZWVkRW50cnkudGVuc29yLnNoYXBlLCBkYXRhLnNoYXBlKSwgXCJFcnJvciBsb2FkaW5nIEZlZWRFbnRyeTogZmVlZGluZyBOREFycmF5IG9mIHNoYXBlIFwiICsgZGF0YS5zaGFwZSArIFwiIFwiICtcbiAgICAgICAgICAgIChcImRvZXMgbm90IG1hdGNoIFRlbnNvciAoaWQ6IFwiICsgZmVlZEVudHJ5LnRlbnNvci5pZCArIFwiKSBzaGFwZTogXCIpICtcbiAgICAgICAgICAgIChmZWVkRW50cnkudGVuc29yLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgYWN0aXZhdGlvbnMuc2V0KGZlZWRFbnRyeS50ZW5zb3IsIGRhdGEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcCA9IGxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwO1xuZnVuY3Rpb24gcmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGJhdGNoRmVlZCwgYWN0aXZhdGlvbnMsIG1hdGgpIHtcbiAgICBPYmplY3Qua2V5cyhiYXRjaEZlZWQuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGJhdGNoRmVlZC5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgIGlmICghKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgICAgIHZhciBmZWVkRW50cnlBcnJheSA9IGFjdGl2YXRpb25zLmdldChmZWVkRW50cnkudGVuc29yKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc3Bvc2VDb3B5KG1hdGgsIGZlZWRFbnRyeUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmF0aW9ucy5kZWxldGUoZmVlZEVudHJ5LnRlbnNvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcCA9IHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIHJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldChmZWVkRGljdGlvbmFyeSwgZXZhbHVhdGlvblNldCkge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGV2YWx1YXRpb25TZXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZhbHVhdGlvblNldFtpXTtcbiAgICAgICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3Rbbm9kZS5vdXRwdXQuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV2YWx1YXRpb25TZXQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQgPSByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoZXZhbHVhdGlvblNldCwgdGVuc29yQXJyYXlNYXApIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIWdyYXBoX3V0aWwuaXNQYXNzdGhyb3VnaE5vZGUobm9kZSwgdGVuc29yQXJyYXlNYXApKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQXJyYXlNYXAuZGlzcG9zZUFycmF5KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzID0gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzO1xuZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhldmFsdWF0aW9uU2V0LCBncmFkaWVudHMpIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGlucHV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmIChncmFkaWVudHMuZ2V0KGlucHV0LCB0cnVlKSAhPT0gZ3JhZGllbnRzLmdldChub2RlLm91dHB1dCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudHMuZGlzcG9zZUFycmF5KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRpZW50cy5udWxsaWZ5KGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMgPSBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzO1xuZnVuY3Rpb24gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhvcGVyYXRpb25zLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKSB7XG4gICAgb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGlzcG9zZVRyYW5zaWVudEFycmF5cyhhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTsgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMgPSBkaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzO1xuZnVuY3Rpb24gdGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyhldmFsdWF0aW9uU2V0KSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5QbGFjZWhvbGRlck5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9ICdbJyArIG5vZGUub3V0cHV0LnNoYXBlLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYWNlaG9sZGVyIG5vZGUgXCInICsgbm9kZS5uYW1lICsgJ1wiICcgKyBzaGFwZSArXG4gICAgICAgICAgICAgICAgJyBub3QgcHJlc2VudCBpbiBmZWVkIGRpY3Rpb25hcnkuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyA9IHRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZW5zb3JBcnJheU1hcEJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvckFycmF5TWFwQmFzZSgpIHtcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgfVxuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRlbnNvciwgc2tpcENoZWNrcykge1xuICAgICAgICBpZiAoc2tpcENoZWNrcyA9PT0gdm9pZCAwKSB7IHNraXBDaGVja3MgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIXNraXBDaGVja3MgJiYgdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yIFwiICsgdGVuc29yLmlkICsgXCIgbm90IGluIGFycmF5IG1hcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5kYSA9IHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgICAgICBpZiAoIXNraXBDaGVja3MgJiYgbmRhID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBoYXMgbnVsbCBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBkZWxldGUgdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLm51bGxpZnkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGlzcG9zZUFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICAgICAgaWYgKG5kYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGljdCkubGVuZ3RoO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgICAgICB2YXIgbmRhID0gX3RoaXMuZGljdFsrdGVuc29ySURdO1xuICAgICAgICAgICAgaWYgKG5kYSkge1xuICAgICAgICAgICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuaGFzTnVsbEFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yIFwiICsgdGVuc29yLmlkICsgXCIgbm90IGluIGFycmF5IG1hcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckFycmF5TWFwQmFzZTtcbn0oKSk7XG5leHBvcnRzLlRlbnNvckFycmF5TWFwQmFzZSA9IFRlbnNvckFycmF5TWFwQmFzZTtcbnZhciBUZW5zb3JBcnJheU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbnNvckFycmF5TWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbnNvckFycmF5TWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRlbnNvckFycmF5TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGVuc29yLCBhcnJheSkge1xuICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IGFycmF5O1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckFycmF5TWFwO1xufShUZW5zb3JBcnJheU1hcEJhc2UpKTtcbmV4cG9ydHMuVGVuc29yQXJyYXlNYXAgPSBUZW5zb3JBcnJheU1hcDtcbnZhciBTdW1tZWRUZW5zb3JBcnJheU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1bW1lZFRlbnNvckFycmF5TWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1bW1lZFRlbnNvckFycmF5TWFwKG1hdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VtbWVkVGVuc29yQXJyYXlNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGFycmF5KSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IHRoaXMubWF0aC5rZWVwKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0KHRlbnNvcik7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hdGgua2VlcCh0aGlzLm1hdGguYWRkU3RyaWN0KG9sZFZhbHVlLCBhcnJheSkpO1xuICAgICAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIG9sZFZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1bW1lZFRlbnNvckFycmF5TWFwO1xufShUZW5zb3JBcnJheU1hcEJhc2UpKTtcbmV4cG9ydHMuU3VtbWVkVGVuc29yQXJyYXlNYXAgPSBTdW1tZWRUZW5zb3JBcnJheU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvcl9hcnJheV9tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhocl9kYXRhc2V0ID0gcmVxdWlyZShcIi4vZGF0YS94aHItZGF0YXNldFwiKTtcbmV4cG9ydHMueGhyX2RhdGFzZXQgPSB4aHJfZGF0YXNldDtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL2JhY2tlbmRzL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG5leHBvcnRzLmdwZ3B1X3V0aWwgPSBncGdwdV91dGlsO1xudmFyIHJlbmRlcl9uZGFycmF5X2dwdV91dGlsID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbFwiKTtcbmV4cG9ydHMucmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwgPSByZW5kZXJfbmRhcnJheV9ncHVfdXRpbDtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy93ZWJnbC93ZWJnbF91dGlsXCIpO1xuZXhwb3J0cy53ZWJnbF91dGlsID0gd2ViZ2xfdXRpbDtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL2NvbnZfdXRpbFwiKTtcbmV4cG9ydHMuY29udl91dGlsID0gY29udl91dGlsO1xudmFyIHRlc3RfdXRpbCA9IHJlcXVpcmUoXCIuL3Rlc3RfdXRpbFwiKTtcbmV4cG9ydHMudGVzdF91dGlsID0gdGVzdF91dGlsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbl8xLnZlcnNpb247XG52YXIgY2hlY2twb2ludF9sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGEvY2hlY2twb2ludF9sb2FkZXJcIik7XG5leHBvcnRzLkNoZWNrcG9pbnRMb2FkZXIgPSBjaGVja3BvaW50X2xvYWRlcl8xLkNoZWNrcG9pbnRMb2FkZXI7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS9kYXRhc2V0XCIpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBkYXRhc2V0XzEuSW5NZW1vcnlEYXRhc2V0O1xudmFyIGlucHV0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9kYXRhL2lucHV0X3Byb3ZpZGVyXCIpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBpbnB1dF9wcm92aWRlcl8xLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbmV4cG9ydHMuSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gaW5wdXRfcHJvdmlkZXJfMS5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgeGhyX2RhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGEveGhyLWRhdGFzZXRcIik7XG5leHBvcnRzLlhockRhdGFzZXQgPSB4aHJfZGF0YXNldF8xLlhockRhdGFzZXQ7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5FTlYgPSBlbnZpcm9ubWVudF8xLkVOVjtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50O1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9ncmFwaFwiKTtcbmV4cG9ydHMuR3JhcGggPSBncmFwaF8xLkdyYXBoO1xuZXhwb3J0cy5UZW5zb3IgPSBncmFwaF8xLlRlbnNvcjtcbnZhciBncmFwaF9ydW5uZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL2dyYXBoX3J1bm5lclwiKTtcbmV4cG9ydHMuR3JhcGhSdW5uZXIgPSBncmFwaF9ydW5uZXJfMS5HcmFwaFJ1bm5lcjtcbmV4cG9ydHMuTWV0cmljUmVkdWN0aW9uID0gZ3JhcGhfcnVubmVyXzEuTWV0cmljUmVkdWN0aW9uO1xudmFyIGFkYWRlbHRhX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWRlbHRhT3B0aW1pemVyID0gYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXI7XG52YXIgYWRhZ3JhZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBhZGFncmFkX29wdGltaXplcl8xLkFkYWdyYWRPcHRpbWl6ZXI7XG52YXIgYWRhbV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYW1PcHRpbWl6ZXIgPSBhZGFtX29wdGltaXplcl8xLkFkYW1PcHRpbWl6ZXI7XG52YXIgYWRhbWF4X29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFtYXhfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFtYXhPcHRpbWl6ZXIgPSBhZGFtYXhfb3B0aW1pemVyXzEuQWRhbWF4T3B0aW1pemVyO1xudmFyIG1vbWVudHVtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLk1vbWVudHVtT3B0aW1pemVyID0gbW9tZW50dW1fb3B0aW1pemVyXzEuTW9tZW50dW1PcHRpbWl6ZXI7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXI7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvc2Vzc2lvblwiKTtcbmV4cG9ydHMuQ29zdFJlZHVjdGlvbiA9IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uO1xuZXhwb3J0cy5TZXNzaW9uID0gc2Vzc2lvbl8xLlNlc3Npb247XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi9pbml0aWFsaXplcnNcIik7XG5leHBvcnRzLkNvbnN0YW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5Db25zdGFudEluaXRpYWxpemVyO1xuZXhwb3J0cy5OREFycmF5SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5OREFycmF5SW5pdGlhbGl6ZXI7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLk9uZXNJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xuZXhwb3J0cy5aZXJvc0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuWmVyb3NJbml0aWFsaXplcjtcbnZhciBiYWNrZW5kX2NwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy9iYWNrZW5kX2NwdVwiKTtcbmV4cG9ydHMuTWF0aEJhY2tlbmRDUFUgPSBiYWNrZW5kX2NwdV8xLk1hdGhCYWNrZW5kQ1BVO1xuZXhwb3J0cy5OREFycmF5TWF0aENQVSA9IGJhY2tlbmRfY3B1XzEuTkRBcnJheU1hdGhDUFU7XG52YXIgYmFja2VuZF93ZWJnbF8xID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy9iYWNrZW5kX3dlYmdsXCIpO1xuZXhwb3J0cy5NYXRoQmFja2VuZFdlYkdMID0gYmFja2VuZF93ZWJnbF8xLk1hdGhCYWNrZW5kV2ViR0w7XG5leHBvcnRzLk5EQXJyYXlNYXRoR1BVID0gYmFja2VuZF93ZWJnbF8xLk5EQXJyYXlNYXRoR1BVO1xudmFyIG1hdG11bF8xID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy90eXBlcy9tYXRtdWxcIik7XG5leHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb247XG52YXIgZ3BncHVfY29udGV4dF8xID0gcmVxdWlyZShcIi4vbWF0aC9iYWNrZW5kcy93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0O1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aFwiKTtcbmV4cG9ydHMuTkRBcnJheU1hdGggPSBtYXRoXzEuTkRBcnJheU1hdGg7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xuZXhwb3J0cy5BcnJheTFEID0gbmRhcnJheV8xLkFycmF5MUQ7XG5leHBvcnRzLkFycmF5MkQgPSBuZGFycmF5XzEuQXJyYXkyRDtcbmV4cG9ydHMuQXJyYXkzRCA9IG5kYXJyYXlfMS5BcnJheTNEO1xuZXhwb3J0cy5BcnJheTREID0gbmRhcnJheV8xLkFycmF5NEQ7XG5leHBvcnRzLk5EQXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheTtcbmV4cG9ydHMuU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhcjtcbmV4cG9ydHMudmFyaWFibGUgPSBuZGFycmF5XzEudmFyaWFibGU7XG5leHBvcnRzLlZhcmlhYmxlID0gbmRhcnJheV8xLlZhcmlhYmxlO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vbWF0aC9vcHRpbWl6ZXJzL29wdGltaXplclwiKTtcbmV4cG9ydHMuT3B0aW1pemVyID0gb3B0aW1pemVyXzEuT3B0aW1pemVyO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL21hdGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi9tYXRoL3R5cGVzXCIpO1xuZXhwb3J0cy5SYW5rID0gdHlwZXNfMS5SYW5rO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWF0aC9vcHNcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcihzY2FsZSwgbW9kZSwgZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMS4wOyB9XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9ICdmYW5faW4nOyB9XG4gICAgICAgIGlmIChkaXN0cmlidXRpb24gPT09IHZvaWQgMCkgeyBkaXN0cmlidXRpb24gPSAnbm9ybWFsJzsgfVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgICBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9pbicpIHtcbiAgICAgICAgICAgIG4gPSBpbnB1dFVuaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9vdXQnKSB7XG4gICAgICAgICAgICBuID0gb3V0cHV0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuX2F2ZycpIHtcbiAgICAgICAgICAgIG4gPSAoaW5wdXRVbml0cyArIG91dHB1dFVuaXRzKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1vZGUgZm9yIHZhcmlhbmNlIHNjYWxpbmcgaW5pdGlhbGl6ZXI6IFwiICsgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KHRoaXMuc2NhbGUgLyBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRVbmlmb3JtKHdlaWdodHNTaGFwZSwgMC4wLCBNYXRoLnNxcnQoMyAqIHRoaXMuc2NhbGUgLyBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRpc3RyaWJ1dGlvbiBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogXCIgK1xuICAgICAgICAgICAgICAgIChcIlwiICsgdGhpcy5kaXN0cmlidXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIgPSBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcjtcbnZhciBaZXJvc0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaZXJvc0luaXRpYWxpemVyKCkge1xuICAgIH1cbiAgICBaZXJvc0luaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmVyb3NJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlplcm9zSW5pdGlhbGl6ZXIgPSBaZXJvc0luaXRpYWxpemVyO1xudmFyIE9uZXNJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT25lc0luaXRpYWxpemVyKCkge1xuICAgIH1cbiAgICBPbmVzSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICAgICAgdmFsdWVzLmZpbGwoMSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gT25lc0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuT25lc0luaXRpYWxpemVyID0gT25lc0luaXRpYWxpemVyO1xudmFyIENvbnN0YW50SW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0YW50SW5pdGlhbGl6ZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAwOyB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ29uc3RhbnRJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YWx1ZXMuZmlsbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuQ29uc3RhbnRJbml0aWFsaXplciA9IENvbnN0YW50SW5pdGlhbGl6ZXI7XG52YXIgTkRBcnJheUluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOREFycmF5SW5pdGlhbGl6ZXIobmRhcnJheSkge1xuICAgICAgICB0aGlzLm5kYXJyYXkgPSBuZGFycmF5O1xuICAgIH1cbiAgICBOREFycmF5SW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5O1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLk5EQXJyYXlJbml0aWFsaXplciA9IE5EQXJyYXlJbml0aWFsaXplcjtcbnZhciBSYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIobWVhbiwgc3RkZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkZXYgPT09IHZvaWQgMCkgeyBzdGRldiA9IC4wNTsgfVxuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZGV2ID0gc3RkZXY7XG4gICAgfVxuICAgIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmROb3JtYWwod2VpZ2h0c1NoYXBlLCB0aGlzLm1lYW4sIHRoaXMuc3RkZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBSYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbnZhciBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIobWVhbiwgc3RkZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkZXYgPT09IHZvaWQgMCkgeyBzdGRldiA9IC4wNTsgfVxuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZGV2ID0gc3RkZXY7XG4gICAgfVxuICAgIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCB0aGlzLm1lYW4sIHRoaXMuc3RkZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbnZhciBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcihtaW52YWwsIG1heHZhbCkge1xuICAgICAgICBpZiAobWludmFsID09PSB2b2lkIDApIHsgbWludmFsID0gLS4wNTsgfVxuICAgICAgICBpZiAobWF4dmFsID09PSB2b2lkIDApIHsgbWF4dmFsID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWludmFsID0gbWludmFsO1xuICAgICAgICB0aGlzLm1heHZhbCA9IG1heHZhbDtcbiAgICB9XG4gICAgUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRVbmlmb3JtKHdlaWdodHNTaGFwZSwgdGhpcy5taW52YWwsIHRoaXMubWF4dmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgPSBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0aWFsaXplcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIHJhbmRfMSA9IHJlcXVpcmUoXCIuL3JhbmRcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5vbmVzID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZU9uZXNUeXBlZEFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksIGR0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZVplcm9zVHlwZWRBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIE9wcy5vbmVzTGlrZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPcHMub25lcyh4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICB9O1xuICAgIE9wcy56ZXJvc0xpa2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT3BzLnplcm9zKHguc2hhcGUsIHguZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLmNsb25lID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHV0aWwuY29weVR5cGVkQXJyYXkoeC5kYXRhU3luYygpLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9LCB4LmR0eXBlKTtcbiAgICB9O1xuICAgIE9wcy5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlICE9IG51bGwgJiYgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5kR2F1c3MgPSBuZXcgcmFuZF8xLk1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgZHR5cGUsIGZhbHNlLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRHYXVzcy5uZXh0VmFsdWUoKTsgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLnRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSAhPSBudWxsICYmIGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZEdhdXNzID0gbmV3IHJhbmRfMS5NUFJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIGR0eXBlLCB0cnVlLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRHYXVzcy5uZXh0VmFsdWUoKTsgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLnJhbmQgPSBmdW5jdGlvbiAoc2hhcGUsIHJhbmRGdW5jdGlvbiwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gcmFuZEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgT3BzLm11bHRpbm9taWFsID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIG51bU91dGNvbWVzID0gcHJvYmFiaWxpdGllcy5zaXplO1xuICAgICAgICBpZiAobnVtT3V0Y29tZXMgPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAgICAgKG51bU91dGNvbWVzICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvYmFiaWxpdGllcy5yYW5rID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIgKyBwcm9iYWJpbGl0aWVzLnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHZhciBvcmlnUmFuayA9IHByb2JhYmlsaXRpZXMucmFuaztcbiAgICAgICAgaWYgKHByb2JhYmlsaXRpZXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcHJvYmFiaWxpdGllcyA9IHByb2JhYmlsaXRpZXMuYXMyRCgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdNdWx0aW5vbWlhbCcsIHtcbiAgICAgICAgICAgIGlucHV0czogeyBwcm9iczogcHJvYmFiaWxpdGllcyB9LFxuICAgICAgICAgICAgYXJnczogeyBudW1TYW1wbGVzOiBudW1TYW1wbGVzLCBzZWVkOiBzZWVkIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnUmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczFEKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5vbmVIb3QgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIGlmIChvblZhbHVlID09PSB2b2lkIDApIHsgb25WYWx1ZSA9IDE7IH1cbiAgICAgICAgaWYgKG9mZlZhbHVlID09PSB2b2lkIDApIHsgb2ZmVmFsdWUgPSAwOyB9XG4gICAgICAgIGlmIChkZXB0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG9uZUhvdDogZGVwdGggbXVzdCBiZSA+PTIsIGJ1dCBpdCBpcyBcIiArIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ09uZUhvdCcsIHsgaW5wdXRzOiB7IGluZGljZXM6IGluZGljZXMgfSwgYXJnczogeyBkZXB0aDogZGVwdGgsIG9uVmFsdWU6IG9uVmFsdWUsIG9mZlZhbHVlOiBvZmZWYWx1ZSB9IH0pO1xuICAgIH07XG4gICAgT3BzLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IHZvaWQgMCkgeyBudW1DaGFubmVscyA9IDM7IH1cbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IE5EQXJyYXkgd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYubWF0aC5mcm9tUGl4ZWxzKHBpeGVscywgbnVtQ2hhbm5lbHMpO1xuICAgIH07XG4gICAgT3BzLnJlc2hhcGUgPSBmdW5jdGlvbiAoeCwgbmV3U2hhcGUpIHtcbiAgICAgICAgbmV3U2hhcGUgPSB1dGlsLmluZmVyRnJvbUltcGxpY2l0U2hhcGUobmV3U2hhcGUsIHguc2l6ZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguc2l6ZSA9PT0gdXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSwgJ25ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5yZXNoYXBlKHguc2hhcGUpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnUmVzaGFwZScsIHsgaW5wdXRzOiB7IHg6IHggfSwgYXJnczogeyBuZXdTaGFwZTogbmV3U2hhcGUgfSB9LCBncmFkKTtcbiAgICB9O1xuICAgIE9wcy5jYXN0ID0gZnVuY3Rpb24gKHgsIG5ld0RUeXBlKSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5yZXNoYXBlKGR5LnNoYXBlKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0Nhc3QnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgbmV3RFR5cGU6IG5ld0RUeXBlIH0gfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBPcHMudGlsZSA9IGZ1bmN0aW9uICh4LCByZXBzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gcmVwcy5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgeC5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIiArIHJlcHMgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1RpbGUnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgcmVwczogcmVwcyB9IH0pO1xuICAgIH07XG4gICAgT3BzLmdhdGhlciA9IGZ1bmN0aW9uICh4LCBpbmRpY2VzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdHYXRoZXInLCB7IGlucHV0czogeyB4OiB4LCBpbmRpY2VzOiBpbmRpY2VzIH0sIGFyZ3M6IHsgYXhpczogYXhpcyB9IH0pO1xuICAgIH07XG4gICAgT3BzLnBhZDFEID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQocGFkZGluZ3MubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIuJyk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnUGFkMUQnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgcGFkZGluZ3M6IHBhZGRpbmdzLCBjb25zdGFudFZhbHVlOiBjb25zdGFudFZhbHVlIH0gfSk7XG4gICAgfTtcbiAgICBPcHMucGFkMkQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydChwYWRkaW5ncy5sZW5ndGggPT09IDIgJiYgcGFkZGluZ3NbMF0ubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBwYWRkaW5nc1sxXS5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLicpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1BhZDJEJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IHBhZGRpbmdzOiBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZTogY29uc3RhbnRWYWx1ZSB9IH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwib25lc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJ6ZXJvc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJvbmVzTGlrZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJ6ZXJvc0xpa2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY2xvbmVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmFuZE5vcm1hbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJ0cnVuY2F0ZWROb3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmFuZFVuaWZvcm1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmFuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtdWx0aW5vbWlhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJvbmVIb3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiZnJvbVBpeGVsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJyZXNoYXBlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNhc3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwidGlsZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJnYXRoZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicGFkMURcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicGFkMkRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbmZ1bmN0aW9uIG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZU9uZXNUeXBlZEFycmF5KHNpemUsIGR0eXBlKSB7XG4gICAgdmFyIGFycmF5ID0gbWFrZVplcm9zVHlwZWRBcnJheShzaXplLCBkdHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5X29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXhlc0FyZUlubmVyTW9zdERpbXMgPSBheGVzQXJlSW5uZXJNb3N0RGltcztcbmZ1bmN0aW9uIGNvbWJpbmVMb2NhdGlvbnMob3V0cHV0TG9jLCByZWR1Y2VMb2MsIGF4ZXMpIHtcbiAgICB2YXIgcmFuayA9IG91dHB1dExvYy5sZW5ndGggKyByZWR1Y2VMb2MubGVuZ3RoO1xuICAgIHZhciBsb2MgPSBbXTtcbiAgICB2YXIgb3V0SWR4ID0gMDtcbiAgICB2YXIgcmVkdWNlSWR4ID0gMDtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBsb2MucHVzaChvdXRwdXRMb2Nbb3V0SWR4KytdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5wdXNoKHJlZHVjZUxvY1tyZWR1Y2VJZHgrK10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2M7XG59XG5leHBvcnRzLmNvbWJpbmVMb2NhdGlvbnMgPSBjb21iaW5lTG9jYXRpb25zO1xuZnVuY3Rpb24gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhU2hhcGUsIGF4ZXMpIHtcbiAgICB2YXIgb3V0U2hhcGUgPSBbXTtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgICAgb3V0U2hhcGUucHVzaChhU2hhcGVbZGltXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlZHVjZVNoYXBlID0gYXhlcy5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gYVNoYXBlW2RpbV07IH0pO1xuICAgIHJldHVybiBbb3V0U2hhcGUsIHJlZHVjZVNoYXBlXTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXM7XG5mdW5jdGlvbiBleHBhbmRTaGFwZVRvS2VlcERpbShzaGFwZSwgYXhlcykge1xuICAgIHZhciByZWR1Y2VTdWJTaGFwZSA9IGF4ZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9KTtcbiAgICByZXR1cm4gY29tYmluZUxvY2F0aW9ucyhzaGFwZSwgcmVkdWNlU3ViU2hhcGUsIGF4ZXMpO1xufVxuZXhwb3J0cy5leHBhbmRTaGFwZVRvS2VlcERpbSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltO1xuZnVuY3Rpb24gcGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBheGlzID0gYXhpcyA9PSBudWxsID8gc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KSA6IFtdLmNvbmNhdChheGlzKTtcbiAgICB1dGlsLmFzc2VydChheGlzLmV2ZXJ5KGZ1bmN0aW9uIChheCkgeyByZXR1cm4gYXggPj0gLXJhbmsgJiYgYXggPCByYW5rOyB9KSwgXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiICsgcmFuayArIFwiLCBcIiArIHJhbmsgKyBcIikgYnV0IFwiICtcbiAgICAgICAgKFwiZ290IGF4aXMgXCIgKyBheGlzKSk7XG4gICAgdXRpbC5hc3NlcnQoYXhpcy5ldmVyeShmdW5jdGlvbiAoYXgpIHsgcmV0dXJuIHV0aWwuaXNJbnQoYXgpOyB9KSwgXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgXCIgK1xuICAgICAgICAoXCJnb3QgYXhpcyBcIiArIGF4aXMpKTtcbiAgICByZXR1cm4gYXhpcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPCAwID8gcmFuayArIGEgOiBhOyB9KTtcbn1cbmV4cG9ydHMucGFyc2VBeGlzUGFyYW0gPSBwYXJzZUF4aXNQYXJhbTtcbmZ1bmN0aW9uIGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKG1zZywgYXhlcywgcmFuaykge1xuICAgIHV0aWwuYXNzZXJ0KGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspLCBtc2cgKyBcIiBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBcIiArXG4gICAgICAgIChcIkdvdCBheGVzIFwiICsgYXhlcyArIFwiIGFuZCByYW5rLVwiICsgcmFuayArIFwiIGlucHV0LlwiKSk7XG59XG5leHBvcnRzLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zID0gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXM7XG5mdW5jdGlvbiBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgcmFuaykge1xuICAgIGlmIChheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBheGVzLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGF4aXMpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRBeGVzUGVybXV0YXRpb24gPSBnZXRBeGVzUGVybXV0YXRpb247XG5mdW5jdGlvbiBnZXRVbmRvQXhlc1Blcm11dGF0aW9uKGF4ZXMpIHtcbiAgICByZXR1cm4gYXhlcy5tYXAoZnVuY3Rpb24gKGF4aXMsIGkpIHsgcmV0dXJuIFtpLCBheGlzXTsgfSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4WzBdOyB9KTtcbn1cbmV4cG9ydHMuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbiA9IGdldFVuZG9BeGVzUGVybXV0YXRpb247XG5mdW5jdGlvbiBnZXRJbm5lck1vc3RBeGVzKG51bUF4ZXMsIHJhbmspIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHJhbmsgLSBudW1BeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5nZXRJbm5lck1vc3RBeGVzID0gZ2V0SW5uZXJNb3N0QXhlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF4aXNfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoXCJzZWVkcmFuZG9tXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL2NvbmNhdF91dGlsXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuLi9tYXRoXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9uZGFycmF5XCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuLi9vcHNcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vLi4vYXhpc191dGlsXCIpO1xudmFyIG1hdG11bF8xID0gcmVxdWlyZShcIi4vdHlwZXMvbWF0bXVsXCIpO1xudmFyIE1hdGhCYWNrZW5kQ1BVID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoQmFja2VuZENQVSgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkYXRhSWQsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IG51bGw7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kQ1BVLndyaXRlKCk6IHZhbHVlcyBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgdGhpcy5kYXRhW2RhdGFJZF0gPSB2YWx1ZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChwaXhlbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRoQmFja2VuZENQVS53cml0ZVBpeGVscygpOiBwaXhlbHMgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHM7XG4gICAgICAgIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgICAgICAgIHZhbHMgPSBwaXhlbHMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgdmFscyA9IHBpeGVscy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgcGl4ZWxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgZnJvbSBIVE1MSW1hZ2VFbGVtZW50IG91dHNpZGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGUgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHBpeGVscywgMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhbHMgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgaXMgb2YgdW5rbm93biB0eXBlOiBcIiArIHBpeGVscy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVzO1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG51bVBpeGVscyA9IHBpeGVscy53aWR0aCAqIHBpeGVscy5oZWlnaHQ7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShudW1QaXhlbHMgKiBudW1DaGFubmVscyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBpeGVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1DaGFubmVsczsgKytjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpICogbnVtQ2hhbm5lbHMgKyBjaGFubmVsXSA9IHZhbHNbaSAqIDQgKyBjaGFubmVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dFNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aCwgbnVtQ2hhbm5lbHNdO1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5M0QubmV3KG91dFNoYXBlLCB2YWx1ZXMsICdpbnQzMicpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZGF0YVtkYXRhSWRdXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5kaXNwb3NlRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgcXVlcnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRocm93SWZOb0RhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICghKGRhdGFJZCBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIGZvdW5kIGZvciBOREFycmF5IHdpdGggZGF0YSBpZCBcIiArIGRhdGFJZCArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgXCJVc2UgZGwuRU5WLm1hdGggaW5zdGVhZCBvZiBjb25zdHJ1Y3RpbmcgeW91ciBvd24gTkRBcnJheU1hdGguIFwiICtcbiAgICAgICAgICAgICAgICBcIklmIHlvdSBuZWVkIHRvIGNvbnN0cnVjdCB5b3VyIG93biBtYXRoLCBtYWtlIHN1cmUgdGhpcyBhcnJheSBpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJhbGxvY2F0ZWQgYWZ0ZXIgdGhlIG1hdGggY29uc3RydWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheSh4LmRhdGFTeW5jKCkpIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNsaWNlMUQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHMgPSB4LmRhdGFTeW5jKCkuc2xpY2UoYmVnaW4sIGJlZ2luICsgc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkxRC5uZXcobmV3VmFscywgeC5kdHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2xpY2UyRCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKHNpemUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0geC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0Sik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWwsIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2xpY2UzRCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKHNpemUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdLCBzdGFydEsgPSBiZWdpblsyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHguZ2V0KGkgKyBzdGFydEksIGogKyBzdGFydEosIGsgKyBzdGFydEspO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2xpY2U0RCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKHNpemUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdLCBzdGFydEsgPSBiZWdpblsyXSwgc3RhcnRMID0gYmVnaW5bM107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc2l6ZVszXTsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0geC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0SiwgayArIHN0YXJ0SywgbCArIHN0YXJ0TCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgaywgbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXZlcnNlNEQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLmNsb25lKHgpO1xuICAgICAgICB2YXIgcmV2QXhpcyA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiBheGlzLmluZGV4T2YoaSkgIT09IC0xICYmIHguc2hhcGVbaV0gIT09IDE7IH07XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgeC5zaGFwZVswXTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHguc2hhcGVbMV07ICsrcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgeC5zaGFwZVsyXTsgKytjKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgeC5zaGFwZVszXTsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYjAgPSByZXZBeGlzKDApID8geC5zaGFwZVswXSAtIGIgLSAxIDogYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByMCA9IHJldkF4aXMoMSkgPyB4LnNoYXBlWzFdIC0gciAtIDEgOiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMwID0gcmV2QXhpcygyKSA/IHguc2hhcGVbMl0gLSBjIC0gMSA6IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZDAgPSByZXZBeGlzKDMpID8geC5zaGFwZVszXSAtIGQgLSAxIDogZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB4LmdldChiMCwgcjAsIGMwLCBkMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgMSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICBpZiAoYS5zaGFwZVswXSA9PT0gMSAmJiBiLnNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBiLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhLnNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGEuZ2V0KGksIGopLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5zaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChiLmdldChpLCBqKSwgaSwgaiArIGEuc2hhcGVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkobmRhcnJheV8xLlNjYWxhci5uZXcoLTEpLCB4KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSksIGZ1bmN0aW9uIChhVmFsdWUsIGJWYWx1ZSkgeyByZXR1cm4gYVZhbHVlICsgYlZhbHVlOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgLSBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBNYXRoLnBvdyhhVmFsdWUsIGJWYWx1ZSk7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1hdE11bCA9IGZ1bmN0aW9uIChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikge1xuICAgICAgICBpZiAoYU9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYU9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYk9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB2YXIgc2hhcmVkRGltID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGxlZnREaW0gPSAoYU9yaWVudGF0aW9uID09PSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMF0gOiBhLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcmlnaHREaW0gPSAoYk9yaWVudGF0aW9uID09PSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMV0gOiBiLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbm9ybWFsR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc3Bvc2VkR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaiwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhR2V0dGVyID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgICAgIHRyYW5zcG9zZWRHZXR0ZXI7XG4gICAgICAgIHZhciBiR2V0dGVyID0gKGJPcmllbnRhdGlvbiA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgICAgIHRyYW5zcG9zZWRHZXR0ZXI7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGxlZnREaW0gKiByaWdodERpbSk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdERpbTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpZ2h0RGltOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXJlZERpbTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBhR2V0dGVyKGEsIGksIGspICogYkdldHRlcihiLCBrLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4KytdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoW2xlZnREaW0sIHJpZ2h0RGltXSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgKiBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Zsb2F0MzInLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSAvIGJWYWx1ZTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdER0eXBlID0gdHlwZXMudXBjYXN0VHlwZSh4LmR0eXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgcmVzdWx0RHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWF4JywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWF4ID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtYXhJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFWYWwgPT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFWYWwgIT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVZhbCA8IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3NFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsIDw9IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVZhbCA+IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsID49IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhVmFsICYmIGJWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwgfHwgYlZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gY29uZGl0aW9uLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhhLnNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGNvbmRpdGlvbi5yYW5rID4gMSB8fCBhLnJhbmsgPT09IDEgPyAxIDogYS5zaGFwZVsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2Zmc2V0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpbmRleCsrXSA9IGFWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaW5kZXgrK10gPSBiVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRvcEtWYWx1ZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BLKHgsIGspLnZhbHVlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50b3BLSW5kaWNlcyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcEsoeCwgaykuaW5kaWNlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50b3BLID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhbHVlc0FuZEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc0FuZEluZGljZXMucHVzaCh7IHZhbHVlOiB2YWx1ZXNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc0FuZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvcGtWYWx1ZXMgPSB1dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoeC5kdHlwZSwgayk7XG4gICAgICAgIHZhciB0b3BrSW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KGspO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAgICAgdG9wa1ZhbHVlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0udmFsdWU7XG4gICAgICAgICAgICB0b3BrSW5kaWNlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogbmRhcnJheV8xLkFycmF5MUQubmV3KHRvcGtWYWx1ZXMsIHguZHR5cGUpLFxuICAgICAgICAgICAgaW5kaWNlczogbmRhcnJheV8xLkFycmF5MUQubmV3KHRvcGtJbmRpY2VzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHsgcmV0dXJuIE1hdGgubWluKGFWYWwsIGJWYWwpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHsgcmV0dXJuIE1hdGgubWF4KGFWYWwsIGJWYWwpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmNlaWwodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmZsb29yKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZXhwKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguc3FydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IHZhbHVlICogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlcyA9IG9wcy56ZXJvcyh4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGluVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpblZhbHNbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWwsIHguZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tpXSA9IHV0aWwuZ2V0TmFOKHJlcy5kdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNWYWxzW2ldID0gTWF0aC5tYXgoMCwgaW5WYWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gKE1hdGguZXhwKHYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5lbHVEZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguZXhwKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2VsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBzY2FsZUFscGhhID0gMS43NTgwOTkzNDA4NDczNzY4NTk5NDAyMTc1MjA4MTIzO1xuICAgICAgICB2YXIgc2NhbGUgPSAxLjA1MDcwMDk4NzM1NTQ4MDQ5MzQxOTMzNDk4NTI5NDY7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBzY2FsZSAqIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBzY2FsZUFscGhhICogKE1hdGguZXhwKHYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBhbHBoYSAqIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wcmVsdSA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYWxwaGFzID0gYWxwaGEuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBhbHBoYXNbaV0gKiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucHJlbHVEZXIgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFscGhhcyA9IGFscGhhLmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IGFscGhhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hYnModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmludCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgSW50MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSwgJ2ludDMyJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5zaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmNvcyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgudGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXNpbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFjb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hdGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmNvc2godmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC50YW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMDsgfVxuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4odmFsdWUsIHguZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC5nZXROYU4oeC5kdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZSA+IDAgPyAxIDogYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb252MmQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBiaWFzLCBjb252SW5mbykge1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHkgPSBvcHMuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgY29udkluZm8ub3V0Q2hhbm5lbHM7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkhlaWdodCwgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaWFzVmFsID0gKGJpYXMgIT0gbnVsbCkgPyBiaWFzLmdldChkMikgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCArIGJpYXNWYWwsIGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkeCA9IG9wcy56ZXJvcyhjb252SW5mby5pblNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeFJDb3JuZXIgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0SGVpZ2h0LCAoZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSAwOyB4QyA8IGNvbnZJbmZvLmluV2lkdGg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHhDIC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhDQ29ybmVyIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dFdpZHRoLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHhDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldChmaWx0ZXJIZWlnaHQgLSAxIC0gd1IsIGZpbHRlcldpZHRoIC0gMSAtIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kLCBiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHg7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBkVyA9IG9wcy56ZXJvcyhjb252SW5mby5maWx0ZXJTaGFwZSk7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChjb252SW5mby5pbkhlaWdodCArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dFdpZHRoLCAoY29udkluZm8uaW5XaWR0aCArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB3UiArIHlSICogc3RyaWRlSGVpZ2h0IC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB3QyArIHlDICogc3RyaWRlV2lkdGggLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4LmdldChiLCB4UiwgeEMsIGQxKSAqIGR5LmdldChiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRXLnNldChkb3RQcm9kLCB3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRXO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbnYyZERlckJpYXMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgdmFyIF9hID0gZHkuc2hhcGUsIGJhdGNoU2l6ZSA9IF9hWzBdLCBudW1Sb3dzID0gX2FbMV0sIG51bUNvbHMgPSBfYVsyXSwgb3V0RGVwdGggPSBfYVszXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkob3V0RGVwdGgpO1xuICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbnVtUm93czsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ29sczsgKytjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZHkuZ2V0KGIsIHIsIGMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tkMl0gPSBzdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTFELm5ldyh2YWx1ZXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgY2hNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIHZhciB5ID0gb3BzLnplcm9zKGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkhlaWdodCwgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY2hNdWw7ICsrcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LnNldChkb3RQcm9kLCBiLCB5UiwgeUMsIGQxICogY2hNdWwgKyBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHgsIHJlcHMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KHgucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0geC5zaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhuZXdTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMb2MgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG9yaWdpbmFsTG9jLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExvY1tpXzFdID0gbmV3TG9jW2lfMV0gJSB4LnNoYXBlW2lfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IHgubG9jVG9JbmRleChvcmlnaW5hbExvYyk7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSB2YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wYWQxRCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB2YXIgbGVmdFBhZGRpbmcgPSBwYWRkaW5nc1swXTtcbiAgICAgICAgdmFyIHJpZ2h0UGFkZGluZyA9IHBhZGRpbmdzWzFdO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKFtsZWZ0UGFkZGluZyArIHZhbHVlcy5sZW5ndGggKyByaWdodFBhZGRpbmddLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgeiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZWZ0UGFkZGluZyAmJiBpIDwgbGVmdFBhZGRpbmcgKyB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gdmFsdWVzW3orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBjb25zdGFudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucGFkMkQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcgPSBwYWRkaW5nc1swXVswXTtcbiAgICAgICAgdmFyIGJvdHRvbVBhZGRpbmcgPSBwYWRkaW5nc1swXVsxXTtcbiAgICAgICAgdmFyIGxlZnRQYWRkaW5nID0gcGFkZGluZ3NbMV1bMF07XG4gICAgICAgIHZhciByaWdodFBhZGRpbmcgPSBwYWRkaW5nc1sxXVsxXTtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gW1xuICAgICAgICAgICAgdG9wUGFkZGluZyArIHguc2hhcGVbMF0gKyBib3R0b21QYWRkaW5nLFxuICAgICAgICAgICAgbGVmdFBhZGRpbmcgKyB4LnNoYXBlWzFdICsgcmlnaHRQYWRkaW5nXG4gICAgICAgIF07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3MobmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciB6ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZVswXTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VTdGFydCA9IC0xO1xuICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gLTE7XG4gICAgICAgICAgICBpZiAoaSA+PSB0b3BQYWRkaW5nICYmIGkgPCBuZXdTaGFwZVswXSAtIGJvdHRvbVBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICByYW5nZVN0YXJ0ID0gaSAqIG5ld1NoYXBlWzFdICsgbGVmdFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgeC5zaGFwZVsxXSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld1NoYXBlWzFdOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGkgKiBuZXdTaGFwZVsxXSArIGo7XG4gICAgICAgICAgICAgICAgaWYgKHYgPj0gcmFuZ2VTdGFydCAmJiB2IDw9IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1t2XSA9IHZhbHVlc1t6KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzW3ZdID0gY29uc3RhbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgcGVybSkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSB4LnNoYXBlW3Blcm1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHguc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0geC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IG5ld0xvYy5sZW5ndGg7IGlfMisrKSB7XG4gICAgICAgICAgICAgICAgbmV3TG9jW2lfMl0gPSBsb2NbcGVybVtpXzJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IHJlc3VsdC5sb2NUb0luZGV4KG5ld0xvYyk7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbbmV3SW5kZXhdID0gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKHgsIGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICAgICAgICB2YXIgaW5kaWNlc1ZhbHVlcyA9IGluZGljZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgbmV3U2hhcGVbYXhpc10gPSBpbmRpY2VzVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhuZXdTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMb2MgPSBuZXdMb2Muc2xpY2UoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsTG9jW2F4aXNdID0gaW5kaWNlc1ZhbHVlc1tuZXdMb2NbYXhpc11dO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSB4LmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbywgcG9vbFR5cGUpIHtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgeSA9IG9wcy56ZXJvcyhjb252SW5mby5vdXRTaGFwZSk7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkhlaWdodCwgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogc3RyaWRlV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5XaWR0aCwgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluTWF4VmFsdWUgPSAocG9vbFR5cGUgPT09ICdtYXgnID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF2Z1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwaXhlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgPSBOYU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBvb2xUeXBlID09PSAnbWF4JyAmJiBwaXhlbCA+IG1pbk1heFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvb2xUeXBlID09PSAnbWluJyAmJiBwaXhlbCA8IG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlICs9IHBpeGVsIC8gKGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHkuc2V0KHBvb2xUeXBlID09PSAnYXZnJyA/IGF2Z1ZhbHVlIDogbWluTWF4VmFsdWUsIGIsIHlSLCB5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gb3BzLnplcm9zKGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLmluV2lkdGgsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb24gPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbnMuc2V0KG1heFBvc2l0aW9uLCBiLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhQb3NpdGlvbnM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gdGhpcy5tYXhQb29sUG9zaXRpb25zKHgsIGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLnplcm9zKHguc2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Uikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBjb252SW5mby5pbldpZHRoOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggLSAxIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyUG9zID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogbWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgYiwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC5hc1R5cGUoeC5kdHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgZHggPSBvcHMuemVyb3MoeC5zaGFwZSk7XG4gICAgICAgIHZhciBhdmdNdWx0aXBsaWVyID0gMSAvIChmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR4QyA9IDA7IGR4QyA8IGNvbnZJbmZvLmluV2lkdGg7ICsrZHhDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q0Nvcm5lciA9IGR4QyAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IGNvbnZJbmZvLm91dEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5UikgIT09IGR5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBjb252SW5mby5vdXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeUMpICE9PSBkeUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QgKiBhdmdNdWx0aXBsaWVyLCBiLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4LmFzVHlwZSh4LmR0eXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5taW5Qb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdtaW4nKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdhdmcnKS50b0Zsb2F0KCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIGJhdGNoID0gX2FbMF0sIG9sZEhlaWdodCA9IF9hWzFdLCBvbGRXaWR0aCA9IF9hWzJdLCBudW1DaGFubmVscyA9IF9hWzNdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gb3BzLnplcm9zKFtiYXRjaCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgbnVtQ2hhbm5lbHNdKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtvbGRIZWlnaHQgLSAxLCBvbGRXaWR0aCAtIDFdIDogW29sZEhlaWdodCwgb2xkV2lkdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtuZXdIZWlnaHQgLSAxLCBuZXdXaWR0aCAtIDFdIDogW25ld0hlaWdodCwgbmV3V2lkdGhdO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmV3SGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5ld1dpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBudW1DaGFubmVsczsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjQ29sID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0Zsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4ob2xkSGVpZ2h0IC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sQ2VpbCA9IE1hdGgubWluKG9sZFdpZHRoIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xGcmFjID0gc291cmNlRnJhY0NvbCAtIHNvdXJjZUNvbEZsb29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9wXzEgKyAoYm90dG9tIC0gdG9wXzEpICogcm93RnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uMkQgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgeFZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG1lYW5WYWx1ZXMgPSBtZWFuLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciB2YXJpYW5jZVZhbHVlcyA9IHZhcmlhbmNlLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlID8gc2NhbGUuZGF0YVN5bmMoKSA6IFsxXTtcbiAgICAgICAgdmFyIG9mZnNldFZhbHVlcyA9IG9mZnNldCA/IG9mZnNldC5kYXRhU3luYygpIDogWzBdO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4VmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0VmFsdWVzW2ldID0gb2Zmc2V0VmFsdWVzW2kgJSBvZmZzZXRWYWx1ZXMubGVuZ3RoXSArXG4gICAgICAgICAgICAgICAgKHhWYWx1ZXNbaV0gLSBtZWFuVmFsdWVzW2kgJSBtZWFuVmFsdWVzLmxlbmd0aF0pICpcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWYWx1ZXNbaSAlIHNjYWxlVmFsdWVzLmxlbmd0aF0gL1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQodmFyaWFuY2VWYWx1ZXNbaSAlIHZhcmlhbmNlVmFsdWVzLmxlbmd0aF0gKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoeC5zaGFwZSwgb3V0VmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24zRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbWVhblZhbHVlcyA9IG1lYW4uZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5kYXRhU3luYygpIDogWzFdO1xuICAgICAgICB2YXIgb2Zmc2V0VmFsdWVzID0gb2Zmc2V0ID8gb2Zmc2V0LmRhdGFTeW5jKCkgOiBbMF07XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTNELm5ldyh4LnNoYXBlLCBvdXRWYWx1ZXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjREID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHhWYWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBtZWFuVmFsdWVzID0gbWVhbi5kYXRhU3luYygpO1xuICAgICAgICB2YXIgdmFyaWFuY2VWYWx1ZXMgPSB2YXJpYW5jZS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgc2NhbGVWYWx1ZXMgPSBzY2FsZSA/IHNjYWxlLmRhdGFTeW5jKCkgOiBuZXcgRmxvYXQzMkFycmF5KFsxXSk7XG4gICAgICAgIHZhciBvZmZzZXRWYWx1ZXMgPSBvZmZzZXQgPyBvZmZzZXQuZGF0YVN5bmMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzBdKTtcbiAgICAgICAgdmFyIG91dFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeFZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dFZhbHVlc1tpXSA9IG9mZnNldFZhbHVlc1tpICUgb2Zmc2V0VmFsdWVzLmxlbmd0aF0gK1xuICAgICAgICAgICAgICAgICh4VmFsdWVzW2ldIC0gbWVhblZhbHVlc1tpICUgbWVhblZhbHVlcy5sZW5ndGhdKSAqXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlVmFsdWVzW2kgJSBzY2FsZVZhbHVlcy5sZW5ndGhdIC9cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KHZhcmlhbmNlVmFsdWVzW2kgJSB2YXJpYW5jZVZhbHVlcy5sZW5ndGhdICsgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5NEQubmV3KHguc2hhcGUsIG91dFZhbHVlcyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhLCBub3JtUmVnaW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuemVyb3MoeC5zaGFwZSk7XG4gICAgICAgIHZhciByYWQgPSByYWRpdXM7XG4gICAgICAgIHZhciBtYXhXID0gb3V0cHV0LnNoYXBlWzFdIC0gMTtcbiAgICAgICAgdmFyIG1heEggPSBvdXRwdXQuc2hhcGVbMl0gLSAxO1xuICAgICAgICB2YXIgbWF4RCA9IG91dHB1dC5zaGFwZVszXSAtIDE7XG4gICAgICAgIHZhciBzdW1BY3Jvc3NDaGFubmVscyA9IGZ1bmN0aW9uIChiLCByLCBjLCBkKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGQgLSByYWQpOyBqIDw9IE1hdGgubWluKGQgKyByYWQsIG1heEQpOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHguZ2V0KGIsIHIsIGMsIGopO1xuICAgICAgICAgICAgICAgIHN1bSArPSB6ICogejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdW1XaXRoaW5DaGFubmVsID0gZnVuY3Rpb24gKGIsIHIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gTWF0aC5tYXgoMCwgciAtIHJhZCk7IHUgPD0gTWF0aC5taW4ociArIHJhZCwgbWF4Vyk7IHUrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSBNYXRoLm1heCgwLCBjIC0gcmFkKTsgdiA8PSBNYXRoLm1pbihjICsgcmFkLCBtYXhIKTsgdisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4LmdldChiLCB1LCB2LCBkKSwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBvdXRwdXQuc2hhcGVbMF07IGIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPD0gb3V0cHV0LnNoYXBlWzFdOyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG91dHB1dC5zaGFwZVsyXTsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgb3V0cHV0LnNoYXBlWzNdOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBub3JtUmVnaW9uID09PSAnd2l0aGluQ2hhbm5lbCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bVdpdGhpbkNoYW5uZWwoYiwgciwgYywgZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bUFjcm9zc0NoYW5uZWxzKGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHguZ2V0KGIsIHIsIGMsIGQpICogTWF0aC5wb3coYmlhcyArIGFscGhhICogc3VtLCAtYmV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KHZhbCwgYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBwcm9iYWJpbGl0aWVzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtRXZlbnRzID0gcHJvYmFiaWxpdGllcy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHJlcyA9IG9wcy56ZXJvcyhbYmF0Y2hTaXplLCBudW1TYW1wbGVzXSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZXNWYWxzID0gcmVzLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBwcm9iVmFscyA9IHByb2JhYmlsaXRpZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGIgKiBudW1FdmVudHM7XG4gICAgICAgICAgICB2YXIgY2RmID0gbmV3IEZsb2F0MzJBcnJheShudW1FdmVudHMgLSAxKTtcbiAgICAgICAgICAgIGNkZlswXSA9IHByb2JWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudF8xID0gMTsgZXZlbnRfMSA8IGNkZi5sZW5ndGg7ICsrZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgIGNkZltldmVudF8xXSA9IGNkZltldmVudF8xIC0gMV0gKyBwcm9iVmFsc1tvZmZzZXQgKyBldmVudF8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBvdXRPZmZzZXQgPSBiICogbnVtU2FtcGxlcztcbiAgICAgICAgICAgIGZvciAodmFyIHNhbXBsZUlkID0gMDsgc2FtcGxlSWQgPCBudW1TYW1wbGVzOyArK3NhbXBsZUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByYW5kb20oKTtcbiAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGNkZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMiA9IDA7IGV2ZW50XzIgPCBjZGYubGVuZ3RoOyBldmVudF8yKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCBjZGZbZXZlbnRfMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ZhbHNbb3V0T2Zmc2V0ICsgc2FtcGxlSWRdID0gZXZlbnRfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLnNpemUgKiBkZXB0aCk7XG4gICAgICAgIHJlcy5maWxsKG9mZlZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnRfMyA9IDA7IGV2ZW50XzMgPCBpbmRpY2VzLnNpemU7ICsrZXZlbnRfMykge1xuICAgICAgICAgICAgcmVzW2V2ZW50XzMgKiBkZXB0aCArIGluZGljZXMuZ2V0KGV2ZW50XzMpXSA9IG9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTJELm5ldyhbaW5kaWNlcy5zaXplLCBkZXB0aF0sIHJlcyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcCA9IGZ1bmN0aW9uIChhLCBiLCBkdHlwZSwgb3ApIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3MobmV3U2hhcGUsIGR0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhQnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoYS5zaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgYkJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGIuc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIGFMb2MgPSBsb2Muc2xpY2UoLWEucmFuayk7XG4gICAgICAgICAgICBhQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBhTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYUluZGV4ID0gYS5sb2NUb0luZGV4KGFMb2MpO1xuICAgICAgICAgICAgdmFyIGJMb2MgPSBsb2Muc2xpY2UoLWIucmFuayk7XG4gICAgICAgICAgICBiQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBiTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYkluZGV4ID0gYi5sb2NUb0luZGV4KGJMb2MpO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gb3AoYVZhbHVlc1thSW5kZXhdLCBiVmFsdWVzW2JJbmRleF0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIE1hdGhCYWNrZW5kQ1BVO1xufSgpKTtcbmV4cG9ydHMuTWF0aEJhY2tlbmRDUFUgPSBNYXRoQmFja2VuZENQVTtcbmVudmlyb25tZW50XzEuRU5WLnJlZ2lzdGVyQmFja2VuZCgnY3B1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hdGhCYWNrZW5kQ1BVKCk7IH0pO1xudmFyIE5EQXJyYXlNYXRoQ1BVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTkRBcnJheU1hdGhDUFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGhDUFUoc2FmZU1vZGUpIHtcbiAgICAgICAgaWYgKHNhZmVNb2RlID09PSB2b2lkIDApIHsgc2FmZU1vZGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25zb2xlLndhcm4oJ25ldyBOREFycmF5TWF0aENQVSgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIGdsb2JhbCAnICtcbiAgICAgICAgICAgICdkbC5FTlYubWF0aC4gSW4gcmFyZSBjYXNlcywgdG8gY29uc3RydWN0IHlvdXIgb3duIE5EQXJyYXlNYXRoICcgK1xuICAgICAgICAgICAgJ3RoYXQgcnVucyBvbiBDUFUsIHVzZSBtYXRoID0gbmV3IE5EQXJyYXlNYXRoKFxcJ2NwdVxcJywgc2FmZU1vZGUpOyAnICtcbiAgICAgICAgICAgICdhbmQgbWFrZSBzdXJlIHRvIHNldCBpdCBhcyBnbG9iYWw6IGRsLkVOVi5zZXRNYXRoKG1hdGgpOycpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdjcHUnLCBzYWZlTW9kZSkgfHwgdGhpcztcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuc2V0TWF0aChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoQ1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhDUFUgPSBOREFycmF5TWF0aENQVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmRfY3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbmRhcnJheVwiKTtcbnZhciBrZXJuZWxfcmVnaXN0cnkgPSByZXF1aXJlKFwiLi9rZXJuZWxfcmVnaXN0cnlcIik7XG52YXIgdGFwZV91dGlsID0gcmVxdWlyZShcIi4vdGFwZV91dGlsXCIpO1xudmFyIEJhY2tlbmRFbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhY2tlbmRFbmdpbmUoYmFja2VuZCwgc2FmZU1vZGUpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdGhpcy5zYWZlTW9kZSA9IHNhZmVNb2RlO1xuICAgICAgICB0aGlzLm5leHRUYXBlTm9kZUlkID0gMDtcbiAgICAgICAgdGhpcy5ncmFkaWVudFNjb3BlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGggPSAwO1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0geyBrZWVwOiBbXSwgdHJhY2s6IFtdIH07XG4gICAgICAgIHRoaXMuc2NvcGVTdGFjayA9IFt0aGlzLmFjdGl2ZVNjb3BlXTtcbiAgICB9XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUuZW5hYmxlRGVidWdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IHRydWU7XG4gICAgfTtcbiAgICBCYWNrZW5kRW5naW5lLnByb3RvdHlwZS5leGVjdXRlS2VybmVsID0gZnVuY3Rpb24gKGtlcm5lbE5hbWUsIGNvbmZpZywgZ3JhZCkge1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ga2VybmVsX3JlZ2lzdHJ5LmV4ZWN1dGVLZXJuZWwodGhpcy5iYWNrZW5kLCBrZXJuZWxOYW1lLCBjb25maWcpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHV0aWwucmlnaHRQYWQocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCArIFwibXNcIiwgOSk7XG4gICAgICAgICAgICB2YXIgcGFkZGVkTmFtZSA9IHV0aWwucmlnaHRQYWQoa2VybmVsTmFtZSwgMjUpO1xuICAgICAgICAgICAgdmFyIHJhbmsgPSByZXN1bHQucmFuaztcbiAgICAgICAgICAgIHZhciBzaXplID0gcmVzdWx0LnNpemU7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB1dGlsLnJpZ2h0UGFkKHJlc3VsdC5zaGFwZS50b1N0cmluZygpLCAxNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVjXCIgKyBwYWRkZWROYW1lICsgXCJcXHQlY1wiICsgdGltZSArIFwiXFx0JWNcIiArIHJhbmsgKyBcIkQgXCIgKyBzaGFwZSArIFwiXFx0JWNcIiArIHNpemUsICdmb250LXdlaWdodDpib2xkJywgJ2NvbG9yOnJlZCcsICdjb2xvcjpibHVlJywgJ2NvbG9yOiBvcmFuZ2UnKTtcbiAgICAgICAgICAgIHV0aWwuY2hlY2tGb3JOYU4odmFscywgcmVzdWx0LmR0eXBlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmVUYXBlICE9IG51bGwgJiYgdGhpcy5jdXN0b21HcmFkaWVudERlcHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcgPSB0YXBlX3V0aWwuc3RyaXBVbmRlZmluZWRJbnB1dHNGcm9tSW5wdXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZWROb2RlID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm5leHRUYXBlTm9kZUlkKyssXG4gICAgICAgICAgICAgICAgdHlwZTogJ2tlcm5lbCcsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJrZXJuZWw6IFwiICsga2VybmVsTmFtZSxcbiAgICAgICAgICAgICAgICBrZXJuZWw6IGtlcm5lbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRBbmRBcmdzOiBjb25maWcsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQ6IGdyYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUucHVzaChldmFsdWF0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUuY3VzdG9tR3JhZGllbnQgPSBmdW5jdGlvbiAoZiwgaW5wdXRzLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCsrO1xuICAgICAgICB2YXIgZ3JhZGllbnRzRnVuYztcbiAgICAgICAgdmFyIGdyYWRpZW50c01vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zY29wZSgnY3VzdG9tR3JhZGllbnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBmKCksIHZhbHVlID0gX2EudmFsdWUsIGdyYWRpZW50cyA9IF9hLmdyYWRpZW50cztcbiAgICAgICAgICAgIGdyYWRpZW50c0Z1bmMgPSBncmFkaWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIGdyYWRpZW50c01vZGUpO1xuICAgICAgICB0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGgtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFwZSAhPSBudWxsICYmIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMubmV4dFRhcGVOb2RlSWQrKyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY3VzdG9tR3JhZGllbnQnLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRBbmRBcmdzOiB7IGlucHV0czogaW5wdXRzIH0sXG4gICAgICAgICAgICAgICAgb3V0cHV0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQ6IGdyYWRpZW50c0Z1bmNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUucHVzaChldmFsdWF0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUuZ3JhZGllbnRzID0gZnVuY3Rpb24gKGYsIHhzLCByZXR1cm5WYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhZGllbnRzTW9kZSA9IHRydWU7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNjb3BlKCdncmFkaWVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeSA9IGYoKTtcbiAgICAgICAgICAgIGlmICh5LnJhbmsgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiBub24tc2NhbGFyIHkgb3V0cHV0IG9mIGYoKS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJHb3QgeSB3aXRoIHJhbmsgXCIgKyB5LnJhbmsgKyBcIiBhbmQgc2hhcGUgXCIgKyB5LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFkaWVudHMgPSBfdGhpcy5ncmFkaWVudFdydCh5LCB4cyk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ldLmNvbmNhdChncmFkaWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZ3JhZGllbnRzTW9kZSk7XG4gICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdFswXSwgZ3JhZGllbnRzOiByZXN1bHQuc2xpY2UoMSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhY2tlbmRFbmdpbmUucHJvdG90eXBlLnZqcCA9IGZ1bmN0aW9uIChmLCB4cywgZHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdyYWRpZW50c01vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZSgndmpwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHkgPSBmKCk7XG4gICAgICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoeS5zaGFwZSwgZHkuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmVjdG9yIGphY29iaWFuIHByb2R1Y3QsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwieSBzaGFwZSAoXCIgKyB5LnNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIGR5IHNoYXBlIChcIiArIGR5LnNoYXBlICsgXCIpLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ3JhZGllbnRXcnQoeSwgeHMsIGR5KTtcbiAgICAgICAgfSwgZ3JhZGllbnRzTW9kZSk7XG4gICAgfTtcbiAgICBCYWNrZW5kRW5naW5lLnByb3RvdHlwZS52YXJpYWJsZUdyYWRpZW50c0FuZFZhbHVlID0gZnVuY3Rpb24gKGYsIHZhckxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdyYWRpZW50c01vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgdmFyaWFibGVOYW1lcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2NvcGUoJ2dyYWRpZW50cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5ID0gZigpO1xuICAgICAgICAgICAgaWYgKHkucmFuayAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIG5vbi1zY2FsYXIgeSBvdXRwdXQgb2YgZigpLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkdvdCB5IHdpdGggcmFuayBcIiArIHkucmFuayArIFwiIGFuZCBzaGFwZSBcIiArIHkuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlucHV0VmFyaWFibGVzID0gdGFwZV91dGlsLmNvbXB1dGVWYXJpYWJsZUlucHV0cyhfdGhpcy5hY3RpdmVUYXBlLCB2YXJMaXN0KTtcbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZXMgPSBpbnB1dFZhcmlhYmxlcy5tYXAoZnVuY3Rpb24gKHZhcmlhYmxlKSB7IHJldHVybiB2YXJpYWJsZS5uYW1lOyB9KTtcbiAgICAgICAgICAgIHZhciBncmFkaWVudHMgPSBpbnB1dFZhcmlhYmxlcy5sZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmFkaWVudFdydCh5LCBpbnB1dFZhcmlhYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gW3ldLmNvbmNhdChncmFkaWVudHMpO1xuICAgICAgICB9LCBncmFkaWVudHNNb2RlKTtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyYWRpZW50c1t2YXJpYWJsZU5hbWVzW2ldXSA9IHJlc3VsdFtpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdFswXSwgZ3JhZGllbnRzOiBncmFkaWVudHMgfTtcbiAgICB9O1xuICAgIEJhY2tlbmRFbmdpbmUucHJvdG90eXBlLmdyYWRpZW50V3J0ID0gZnVuY3Rpb24gKHksIHhzLCBkeSkge1xuICAgICAgICB2YXIgZmlsdGVyZWRUYXBlID0gdGFwZV91dGlsLmdldEZpbHRlcmVkTm9kZXNYVG9ZKHRoaXMuYWN0aXZlVGFwZSwgeHMsIHkpO1xuICAgICAgICBpZiAoZmlsdGVyZWRUYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQ6IHkgaXMgbm90IGEgZnVuY3Rpb24gb2YgeHMuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoZSB4cyB5b3UgYXJlIGNvbXB1dGluZyBncmFkaWVudHMgd2l0aCByZXNwZWN0IFwiICtcbiAgICAgICAgICAgICAgICBcInRvIGFyZSB1c2VkIGluc2lkZSB0aGUgZ3JhZGllbnQgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheUFjY3VtdWxhdGVkR3JhZGllbnRNYXAgPSB7fTtcbiAgICAgICAgYXJyYXlBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3kuaWRdID1cbiAgICAgICAgICAgIGR5ID09IG51bGwgPyBuZGFycmF5XzEuU2NhbGFyLm5ldygxLCAnZmxvYXQzMicpIDogZHk7XG4gICAgICAgIHRhcGVfdXRpbC5iYWNrcHJvcGFnYXRlR3JhZGllbnRzKGFycmF5QWNjdW11bGF0ZWRHcmFkaWVudE1hcCwgZmlsdGVyZWRUYXBlKTtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHhzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYXJyYXlBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdOyB9KTtcbiAgICAgICAgZ3JhZGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGdyYWQsIGkpIHtcbiAgICAgICAgICAgIGlmIChncmFkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBlcnJvcjogeSB3YXMgbm90IGEgZnVuY3Rpb24gb2YgeHNbXCIgKyBpICsgXCJdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYWRpZW50cztcbiAgICB9O1xuICAgIEJhY2tlbmRFbmdpbmUucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlRm4sIGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGFydFNjb3BlKGdyYWRpZW50c01vZGUpO1xuICAgICAgICB2YXIga2VlcEZuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHsgcmV0dXJuIF90aGlzLmtlZXAobmRhcnJheSk7IH07XG4gICAgICAgIHZhciB0cmFja0ZuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHsgcmV0dXJuIG5kYXJyYXk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSBzY29wZUZuKGtlZXBGbiwgdHJhY2tGbik7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMuZW5kU2NvcGUociwgZ3JhZGllbnRzTW9kZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5kU2NvcGUocmVzdWx0LCBncmFkaWVudHNNb2RlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhY2tlbmRFbmdpbmUucHJvdG90eXBlLnN0YXJ0U2NvcGUgPSBmdW5jdGlvbiAoZ3JhZGllbnRzTW9kZSkge1xuICAgICAgICBpZiAoZ3JhZGllbnRzTW9kZSAmJiB0aGlzLmdyYWRpZW50U2NvcGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTY29wZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Njb3BlQXJyYXlzID0geyBrZWVwOiBbXSwgdHJhY2s6IFtdIH07XG4gICAgICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ld1Njb3BlQXJyYXlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IG5ld1Njb3BlQXJyYXlzO1xuICAgIH07XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUuZW5kU2NvcGUgPSBmdW5jdGlvbiAocmVzdWx0LCBncmFkaWVudHNNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U2NvcGVDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnRTY29wZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXlzVG9LZWVwID0gdGhpcy5hY3RpdmVTY29wZS5rZWVwO1xuICAgICAgICB2YXIgYXJyYXlzVG9UcmFja0luUGFyZW50ID0gdGFwZV91dGlsLmV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdChyZXN1bHQpO1xuICAgICAgICBhcnJheXNUb0tlZXAgPSBhcnJheXNUb0tlZXAuY29uY2F0KGFycmF5c1RvVHJhY2tJblBhcmVudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSB0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNOREFycmF5SW5MaXN0KG5kYXJyYXksIGFycmF5c1RvS2VlcCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFycmF5c1RvVHJhY2tJblBhcmVudC5wdXNoKG5kYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmRhcnJheS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGFycmF5c1RvVHJhY2tJblBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNOREFycmF5SW5MaXN0KG5kYXJyYXksIF90aGlzLmFjdGl2ZVNjb3BlLmtlZXApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2sobmRhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUua2VlcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVTdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhZmVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHVzaW5nIG1hdGggaW4gc2FmZSBtb2RlLiBFbmNsb3NlIGFsbCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGgubWV0aG9kKCkgY2FsbHMgaW5zaWRlIGEgc2NvcGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5zY29wZSgoKSA9PiB7bWF0aC5tZXRob2QoKTsuLi59KSB0byBhdm9pZCBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlLmtlZXAucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFja2VuZEVuZ2luZS5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zYWZlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSB1c2luZyBtYXRoIGluIHNhZmUgbW9kZS4gRW5jbG9zZSBhbGwgJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLm1ldGhvZCgpIGNhbGxzIGluc2lkZSBhIHNjb3BlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGguc2NvcGUoKCkgPT4ge21hdGgubWV0aG9kKCk7Li4ufSkgdG8gYXZvaWQgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVha3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZS50cmFjay5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBCYWNrZW5kRW5naW5lLnByb3RvdHlwZS5nZXRCYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kO1xuICAgIH07XG4gICAgcmV0dXJuIEJhY2tlbmRFbmdpbmU7XG59KCkpO1xuZXhwb3J0cy5CYWNrZW5kRW5naW5lID0gQmFja2VuZEVuZ2luZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmRfZW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi4vYXhpc191dGlsXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuLi9tYXRoXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9uZGFycmF5XCIpO1xudmFyIHJlZHVjZV91dGlsID0gcmVxdWlyZShcIi4uL3JlZHVjZV91dGlsXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGFyZ21pbm1heF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2FyZ21pbm1heF9ncHVcIik7XG52YXIgYXZnX3Bvb2xfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hdmdfcG9vbF9iYWNrcHJvcF9ncHVcIik7XG52YXIgYmF0Y2hub3JtX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmF0Y2hub3JtX2dwdVwiKTtcbnZhciBiaW5hcnlvcF9ncHUgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgY2xpcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NsaXBfZ3B1XCIpO1xudmFyIGNvbmNhdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbmNhdF9ncHVcIik7XG52YXIgY29udl9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1XCIpO1xudmFyIGNvbnZfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdVwiKTtcbnZhciBjb252X2dwdV9kZXB0aHdpc2VfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZVwiKTtcbnZhciBjb3B5X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29weV9ncHVcIik7XG52YXIgZnJvbV9waXhlbHNfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9mcm9tX3BpeGVsc19ncHVcIik7XG52YXIgZ2F0aGVyX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvZ2F0aGVyX2dwdVwiKTtcbnZhciBncGdwdV9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xudmFyIGdwZ3B1X21hdGggPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9tYXRoXCIpO1xudmFyIGxvZ2ljYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9sb2dpY2FsX2dwdVwiKTtcbnZhciBscm5fZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9scm5fZ3B1XCIpO1xudmFyIG1heF9wb29sX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XCIpO1xudmFyIG11bG1hdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bG1hdF9ncHVcIik7XG52YXIgbXVsdGlub21pYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWx0aW5vbWlhbF9ncHVcIik7XG52YXIgb25laG90X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvb25laG90X2dwdVwiKTtcbnZhciBwYWRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9wYWRfZ3B1XCIpO1xudmFyIHBvb2xfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9wb29sX2dwdVwiKTtcbnZhciByZWR1Y2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZWR1Y2VfZ3B1XCIpO1xudmFyIHJlc2l6ZV9iaWxpbmVhcl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHVcIik7XG52YXIgcmV2ZXJzZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3JldmVyc2VfZ3B1XCIpO1xudmFyIHNsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc2xpY2VfZ3B1XCIpO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi93ZWJnbC90ZXhfdXRpbFwiKTtcbnZhciB0ZXh0dXJlX21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RleHR1cmVfbWFuYWdlclwiKTtcbnZhciB0aWxlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGlsZV9ncHVcIik7XG52YXIgdHJhbnNwb3NlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdHJhbnNwb3NlX2dwdVwiKTtcbnZhciB1bmFyeV9vcCA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHVuYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC91bmFyeW9wX2dwdVwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbnZhciBNYXRoQmFja2VuZFdlYkdMID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoQmFja2VuZFdlYkdMKGdwZ3B1LCBkZWxheWVkU3RvcmFnZSkge1xuICAgICAgICBpZiAoZGVsYXllZFN0b3JhZ2UgPT09IHZvaWQgMCkgeyBkZWxheWVkU3RvcmFnZSA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLmRlbGF5ZWRTdG9yYWdlID0gZGVsYXllZFN0b3JhZ2U7XG4gICAgICAgIHRoaXMudGV4RGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmJpbmFyeUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdwZ3B1ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUgPSBuZXcgZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgdGV4dHVyZV9tYW5hZ2VyXzEuVGV4dHVyZU1hbmFnZXIodGhpcy5ncGdwdSk7XG4gICAgfVxuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRhdGFJZCwgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkYXRhSWQgaW4gdGhpcy50ZXhEYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGlkIFwiICsgZGF0YUlkICsgXCIgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4RGF0YVtkYXRhSWRdID0ge1xuICAgICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgZHR5cGU6IGR0eXBlLFxuICAgICAgICAgICAgdmFsdWVzOiBudWxsLFxuICAgICAgICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgICAgICAgIHRleFNoYXBlOiBudWxsLFxuICAgICAgICAgICAgdGV4VHlwZTogdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5GTE9BVFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChwaXhlbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRoQmFja2VuZFdlYkdMLndyaXRlUGl4ZWxzKCk6IHBpeGVscyBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGUgPSBbcGl4ZWxzLmhlaWdodCwgcGl4ZWxzLndpZHRoXTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aCwgbnVtQ2hhbm5lbHNdO1xuICAgICAgICBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgZnJvbSBIVE1MSW1hZ2VFbGVtZW50IG91dHNpZGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGUgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHBpeGVscywgMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHBpeGVscyA9IHRoaXMuY2FudmFzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wUGl4ZWxBcnJheSA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UodGV4U2hhcGUsIHt9LCAnaW50MzInKTtcbiAgICAgICAgdGhpcy50ZXhEYXRhW3RlbXBQaXhlbEFycmF5LmRhdGFJZF0udGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuVU5TSUdORURfQllURTtcbiAgICAgICAgdGhpcy5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKHRlbXBQaXhlbEFycmF5LmRhdGFJZCksIHBpeGVscyk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGZyb21fcGl4ZWxzX2dwdV8xLkZyb21QaXhlbHNQcm9ncmFtKG91dFNoYXBlKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbdGVtcFBpeGVsQXJyYXldKTtcbiAgICAgICAgdGVtcFBpeGVsQXJyYXkuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGFbZGF0YUlkXSwgdGV4dHVyZSA9IF9hLnRleHR1cmUsIHRleFNoYXBlID0gX2EudGV4U2hhcGUsIHRleFR5cGUgPSBfYS50ZXhUeXBlO1xuICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgICAgIHRoaXMudGV4RGF0YVtkYXRhSWRdLnRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50ZXhEYXRhW2RhdGFJZF0udGV4U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4RGF0YVtkYXRhSWRdLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRTdG9yYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlYWRTeW5jID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhW2RhdGFJZF0sIHRleHR1cmUgPSBfYS50ZXh0dXJlLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHRleFNoYXBlID0gX2EudGV4U2hhcGU7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbG9hdDMyVmFsdWVzID0gdGhpcy5ncGdwdS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSk7XG4gICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQsIGZsb2F0MzJWYWx1ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXhEYXRhW2RhdGFJZF0udmFsdWVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCB0ZXh0dXJlLCB2YWx1ZXMsIHRleFNoYXBlLCBmbG9hdDMyVmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMudGV4RGF0YVtkYXRhSWRdLCB0ZXh0dXJlID0gX2EudGV4dHVyZSwgdmFsdWVzID0gX2EudmFsdWVzLCB0ZXhTaGFwZSA9IF9hLnRleFNoYXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB2YWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5ncGdwdS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlQXN5bmModGV4dHVyZSwgdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0MzJWYWx1ZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlT25DUFUoZGF0YUlkLCBmbG9hdDMyVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy50ZXhEYXRhW2RhdGFJZF0udmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVhZFN5bmMoZGF0YUlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZ3BncHUucnVuUXVlcnkoZnVuY3Rpb24gKCkgeyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZWFkU3luYyhkYXRhSWQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gcXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYS5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgdGhpcy5ncGdwdS5ydW5RdWVyeShxdWVyeSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmRpc3Bvc2VEYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoZGF0YUlkIGluIHRoaXMudGV4RGF0YSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhW2RhdGFJZF0sIHRleHR1cmUgPSBfYS50ZXh0dXJlLCB0ZXhTaGFwZSA9IF9hLnRleFNoYXBlLCB0ZXhUeXBlID0gX2EudGV4VHlwZTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRleERhdGFbZGF0YUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy51cGxvYWRUb0dQVShkYXRhSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXhEYXRhW2RhdGFJZF0udGV4dHVyZTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldFRleHR1cmVEYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleERhdGFbZGF0YUlkXTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YSh4LmRhdGFJZCk7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUoeC5kYXRhSWQpO1xuICAgICAgICB2YXIgdGV4U2hhcGUgPSB0aGlzLnRleERhdGFbeC5kYXRhSWRdLnRleFNoYXBlO1xuICAgICAgICB2YXIgc291cmNlID0geC5hczJEKHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheSh0ZXhTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHRoaXMuY29weTJEKHNvdXJjZSwgWzAsIDBdLCB0ZXhTaGFwZSwgb3V0cHV0LCBbMCwgMF0sIHRleFNoYXBlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5yZXNoYXBlKHguc2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2xpY2UxRCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oW3NpemVdKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoW2JlZ2luXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zbGljZTJEID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2xpY2UzRCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKGJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNsaWNlNEQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKHNpemUpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhiZWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZXZlcnNlNEQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXZlcnNlX2dwdV8xLlJldmVyc2VQcm9ncmFtKHguc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb3B5MkQgPSBmdW5jdGlvbiAoc291cmNlLCBzb3VyY2VCZWdpblJvd0NvbCwgc291cmNlU2l6ZVJvd0NvbCwgZGVzdCwgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb3B5X2dwdV8xLkNvcHkyRFByb2dyYW0oc291cmNlU2l6ZVJvd0NvbFsxXSwgZGVzdFNpemVSb3dDb2xbMV0pO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzb3VyY2VCZWdpblJvd0NvbCwgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCk7XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbc291cmNlXSwgZGVzdCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTkVHKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG11bG1hdF9ncHVfMS5NYXRNdWxQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk1VTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24yRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24zRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREID0gZnVuY3Rpb24gKHgsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEsIG5vcm1SZWdpb24pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbHJuX2dwdV8xLkxSTlByb2dyYW0oeC5zaGFwZSwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRpbGUgPSBmdW5jdGlvbiAoeCwgcmVwcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB0aWxlX2dwdV8xLlRpbGVQcm9ncmFtKHguc2hhcGUsIHJlcHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5wYWQxRCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwYWRfZ3B1XzEuUGFkMURQcm9ncmFtKHguc2hhcGUsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucGFkMkQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcGFkX2dwdV8xLlBhZDJEUHJvZ3JhbSh4LnNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBwZXJtKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHRyYW5zcG9zZV9ncHVfMS5UcmFuc3Bvc2VQcm9ncmFtKHguc2hhcGUsIHBlcm0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoeCwgaW5kaWNlcywgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBnYXRoZXJfZ3B1XzEuR2F0aGVyUHJvZ3JhbSh4LnNoYXBlLCBpbmRpY2VzLnNpemUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBpbmRpY2VzXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCwgcmVkdWNlVHlwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlZHVjZV9ncHVfMS5SZWR1Y2VQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSBwcm9ncmFtLm91dHB1dFNoYXBlLCByb3dzID0gX2FbMF0sIGNvbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGR0eXBlKS5hczJEKHJvd3MsIGNvbHMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgICAgICBpZiAob3V0cHV0LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShvdXRwdXQsIHJlZHVjZVR5cGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFyZ1JlZHVjZSA9IGZ1bmN0aW9uICh4LCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EpIHtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSA9PT0gdm9pZCAwKSB7IGJlc3RJbmRpY2VzQSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGluU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGFyZ21pbm1heF9ncHVfMS5BcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSA9PSBudWxsKTtcbiAgICAgICAgdmFyIF9hID0gcHJvZ3JhbS5vdXRwdXRTaGFwZSwgcm93cyA9IF9hWzBdLCBjb2xzID0gX2FbMV07XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnaW50MzInKS5hczJEKHJvd3MsIGNvbHMpO1xuICAgICAgICB2YXIgaW5wdXRzID0gW3hdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKGJlc3RJbmRpY2VzQSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgaWYgKG91dHB1dC5zaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoeCwgcmVkdWNlVHlwZSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnc3VtJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICB2YXIgb3V0cHV0RFR5cGUgPSB0eXBlcy5zdW1PdXRUeXBlKHguZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnc3VtJywgb3V0cHV0RFR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNaW4nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhMkQsICdtaW4nKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWF4JywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYTJELCAnbWF4JykucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuRVFVQUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTk9UX0VRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTEVTUywgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxlc3NFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTEVTU19FUVVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkdSRUFURVIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5ncmVhdGVyRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkdSRUFURVJfRVFVQUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5MT0dJQ0FMX0FORCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTE9HSUNBTF9PUiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYiwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbG9naWNhbF9ncHVfMS5XaGVyZVByb2dyYW0oY29uZGl0aW9uLnJhbmssIGEuc2hhcGUsIGEucmFuayk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2NvbmRpdGlvbiwgYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50b3BLVmFsdWVzID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLVmFsdWVzIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudG9wS0luZGljZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvcEtJbmRpY2VzIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtaW4nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtaW4nLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTUlOLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtYXgnLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTUFYLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5ESVYsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkFERCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuU1VCLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuUE9XLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNFSUwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuRkxPT1IpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkVYUCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTE9HKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1FSVCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1FVQVJFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuUkVMVSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZWx1RGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FTFVfREVSKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2VsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU0VMVSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxlYWt5UmVsdSA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkxFQUtZX1JFTFUoYWxwaGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucHJlbHUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LlBSRUxVLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucHJlbHVEZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LlBSRUxVX0RFUiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmludCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuVE9fSU5UKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY2xpcF9ncHVfMS5DbGlwUHJvZ3JhbSh4LnNoYXBlLCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQUJTKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU0lHTU9JRCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU0lOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5DT1MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlRBTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFTSU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BQ09TKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQVRBTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNpbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNJTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5DT1NIKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuVEFOSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TVEVQKGFscGhhKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1XzEuQ29udjJEUHJvZ3JhbShjb252SW5mbywgYmlhcyAhPSBudWxsKTtcbiAgICAgICAgdmFyIGlucHV0cyA9IGJpYXMgIT0gbnVsbCA/IFt4LCBmaWx0ZXIsIGJpYXNdIDogW3gsIGZpbHRlcl07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHksIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlckZpbHRlclByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBkeV0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29udjJkRGVyQmlhcyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlckJpYXNQcm9ncmFtKGR5LnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHldKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1X2RlcHRod2lzZV8xLkRlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZmFsc2UpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluUG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtaW4nLCBmYWxzZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ2F2ZycsIGZhbHNlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgZ2V0UG9zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGdldFBvc2l0aW9ucyk7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtLCBbeF0pO1xuICAgICAgICB2YXIgbWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSA9IG5ldyBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMS5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkobWF4UG9vbEJhY2tQcm9wUHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbXBpbGVBbmRSdW4obWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSwgW2R5LCBtYXhQb29sUG9zaXRpb25zXSwgb3V0cHV0KTtcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBhdmdQb29sQmFja3Byb3BQcm9ncmFtID0gbmV3IGF2Z19wb29sX2JhY2twcm9wX2dwdV8xLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShhdmdQb29sQmFja3Byb3BQcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhdmdQb29sQmFja3Byb3BQcm9ncmFtLCBbZHldLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9iaWxpbmVhcl9ncHVfMS5SZXNpemVCaWxpbmVhclByb2dyYW0oeC5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlub21pYWwgPSBmdW5jdGlvbiAocHJvYnMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtT3V0Y29tZXMgPSBwcm9icy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsdGlub21pYWxfZ3B1XzEuTXVsdGlub21pYWxQcm9ncmFtKGJhdGNoU2l6ZSwgbnVtT3V0Y29tZXMsIG51bVNhbXBsZXMpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKHNlZWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtwcm9ic10sIG91dHB1dCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBvbmVob3RfZ3B1XzEuT25lSG90UHJvZ3JhbShpbmRpY2VzLnNpemUsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2luZGljZXNdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1ha2VPdXRwdXRBcnJheSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2Uoc2hhcGUsIHt9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb21waWxlQW5kUnVuID0gZnVuY3Rpb24gKHByb2dyYW0sIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGlucHV0c1swXS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0c0RhdGEgPSBpbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgX3RoaXMudXBsb2FkVG9HUFUoaW5wdXQuZGF0YUlkKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFycmF5OiBpbnB1dCwgdGV4RGF0YTogX3RoaXMudGV4RGF0YVtpbnB1dC5kYXRhSWRdIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKG91dHB1dC5kYXRhSWQpO1xuICAgICAgICB2YXIgb3V0cHV0RGF0YSA9IHsgYXJyYXk6IG91dHB1dCwgdGV4RGF0YTogdGhpcy50ZXhEYXRhW291dHB1dC5kYXRhSWRdIH07XG4gICAgICAgIHZhciBrZXkgPSBncGdwdV9tYXRoLm1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSk7XG4gICAgICAgIHZhciBiaW5hcnkgPSB0aGlzLmdldEFuZFNhdmVCaW5hcnkoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfbWF0aC5jb21waWxlUHJvZ3JhbShfdGhpcy5ncGdwdSwgcHJvZ3JhbSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBncGdwdV9tYXRoLnJ1blByb2dyYW0oYmluYXJ5LCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhLCBjdXN0b21TZXR1cCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRBbmRTYXZlQmluYXJ5ID0gZnVuY3Rpb24gKGtleSwgZ2V0QmluYXJ5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLmJpbmFyeUNhY2hlKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlDYWNoZVtrZXldID0gZ2V0QmluYXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcjtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlUHJvZ3JhbSh0aGlzLmJpbmFyeUNhY2hlW2tleV0ud2ViR0xQcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aHJvd0lmTm9EYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoIShkYXRhSWQgaW4gdGhpcy50ZXhEYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YSBmb3VuZCBmb3IgTkRBcnJheSB3aXRoIGRhdGEgaWQgXCIgKyBkYXRhSWQgKyBcIi4gXCIgK1xuICAgICAgICAgICAgICAgIFwiVXNlIGRsLkVOVi5tYXRoIGluc3RlYWQgb2YgY29uc3RydWN0aW5nIHlvdXIgb3duIE5EQXJyYXlNYXRoLiBcIiArXG4gICAgICAgICAgICAgICAgXCJJZiB5b3UgbmVlZCB0byBjb25zdHJ1Y3QgeW91ciBvd24gbWF0aCwgbWFrZSBzdXJlIHRoaXMgYXJyYXkgaXMgXCIgK1xuICAgICAgICAgICAgICAgIFwiYWxsb2NhdGVkIGFmdGVyIHRoZSBtYXRoIGNvbnN0cnVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudXBsb2FkVG9HUFUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGFbZGF0YUlkXSwgc2hhcGUgPSBfYS5zaGFwZSwgdmFsdWVzID0gX2EudmFsdWVzLCB0ZXh0dXJlID0gX2EudGV4dHVyZSwgZHR5cGUgPSBfYS5kdHlwZSwgdGV4VHlwZSA9IF9hLnRleFR5cGU7XG4gICAgICAgIGlmICh0ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGUgPSB3ZWJnbF91dGlsLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUodGhpcy5ncGdwdS5nbCwgc2hhcGUpO1xuICAgICAgICB0aGlzLnRleERhdGFbZGF0YUlkXS50ZXhTaGFwZSA9IHRleFNoYXBlO1xuICAgICAgICB2YXIgbmV3VGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICB0aGlzLnRleERhdGFbZGF0YUlkXS50ZXh0dXJlID0gbmV3VGV4dHVyZTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShuZXdUZXh0dXJlLCB0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0sIHR5cGVkQXJyYXlUb0Zsb2F0MzIodmFsdWVzLCBkdHlwZSkpO1xuICAgICAgICAgICAgdGhpcy50ZXhEYXRhW2RhdGFJZF0udmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2FjaGVPbkNQVSA9IGZ1bmN0aW9uIChkYXRhSWQsIGZsb2F0MzJWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGRvbnRLZWVwQ29weU9uR1BVID0gdGhpcy5kZWxheWVkU3RvcmFnZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhW2RhdGFJZF0sIHRleHR1cmUgPSBfYS50ZXh0dXJlLCB0ZXhTaGFwZSA9IF9hLnRleFNoYXBlLCBkdHlwZSA9IF9hLmR0eXBlLCB0ZXhUeXBlID0gX2EudGV4VHlwZTtcbiAgICAgICAgaWYgKGRvbnRLZWVwQ29weU9uR1BVICYmIHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnRleERhdGFbZGF0YUlkXS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGV4RGF0YVtkYXRhSWRdLnRleFNoYXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXQzMlZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleERhdGFbZGF0YUlkXS52YWx1ZXMgPSBmbG9hdDMyVG9UeXBlZEFycmF5KGZsb2F0MzJWYWx1ZXMsIGR0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1hdGhCYWNrZW5kV2ViR0w7XG59KCkpO1xuZXhwb3J0cy5NYXRoQmFja2VuZFdlYkdMID0gTWF0aEJhY2tlbmRXZWJHTDtcbmVudmlyb25tZW50XzEuRU5WLnJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWF0aEJhY2tlbmRXZWJHTCgpOyB9KTtcbnZhciBOREFycmF5TWF0aEdQVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5EQXJyYXlNYXRoR1BVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlNYXRoR1BVKGdwZ3B1LCBzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnNvbGUud2FybignbmV3IE5EQXJyYXlNYXRoR1BVKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgZ2xvYmFsICcgK1xuICAgICAgICAgICAgJ2RsLkVOVi5tYXRoLiBJbiByYXJlIGNhc2VzLCB0byBjb25zdHJ1Y3QgeW91ciBvd24gTkRBcnJheU1hdGggJyArXG4gICAgICAgICAgICAndGhhdCBydW5zIG9uIEdQVSwgdXNlIG1hdGggPSBuZXcgTkRBcnJheU1hdGgoXFwnd2ViZ2xcXCcsIHNhZmVNb2RlKTsgJyArXG4gICAgICAgICAgICAnYW5kIG1ha2Ugc3VyZSB0byBzZXQgaXQgYXMgZ2xvYmFsOiBkbC5FTlYuc2V0TWF0aChtYXRoKTsnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgTWF0aEJhY2tlbmRXZWJHTChncGdwdSksIHNhZmVNb2RlKSB8fCB0aGlzO1xuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5zZXRNYXRoKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZ2V0QmFja2VuZCgpLmdldEdQR1BVQ29udGV4dCgpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZ2V0QmFja2VuZCgpLmdldFRleHR1cmVNYW5hZ2VyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGhHUFU7XG59KG1hdGhfMS5OREFycmF5TWF0aCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aEdQVSA9IE5EQXJyYXlNYXRoR1BVO1xuZnVuY3Rpb24gZmxvYXQzMlRvVHlwZWRBcnJheShhLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJyB8fCBkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAoZHR5cGUgPT09ICdpbnQzMicpID8gbmV3IEludDMyQXJyYXkoYS5sZW5ndGgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhW2ldO1xuICAgICAgICAgICAgdmFsID0gaXNOYU4odmFsKSA/IHV0aWwuZ2V0TmFOKGR0eXBlKSA6IE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0eXBlZEFycmF5VG9GbG9hdDMyKGEsIGR0eXBlKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYVtpXTtcbiAgICAgICAgICAgIHJlc1tpXSA9IHV0aWwuaXNWYWxOYU4odmFsLCBkdHlwZSkgPyBOYU4gOiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kX3dlYmdsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbmRhcnJheVwiKTtcbmZ1bmN0aW9uIGV4ZWN1dGVLZXJuZWwoYmFja2VuZCwga2VybmVsTmFtZSwgaW5wdXRBbmRBcmdzKSB7XG4gICAgaWYgKGtlcm5lbE5hbWUgPT09ICdNYXRNdWwnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm1hdE11bChjb25maWcuaW5wdXRzLmEsIGNvbmZpZy5pbnB1dHMuYiwgY29uZmlnLmFyZ3MuYU9yaWVudGF0aW9uLCBjb25maWcuYXJncy5iT3JpZW50YXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQ2xvbmUnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNsb25lKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdTbGljZTFEJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5zbGljZTFEKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYmVnaW4sIGNvbmZpZy5hcmdzLnNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnU2xpY2UyRCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuc2xpY2UyRChjb25maWcuaW5wdXRzLngsIGNvbmZpZy5hcmdzLmJlZ2luLCBjb25maWcuYXJncy5zaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1NsaWNlM0QnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnNsaWNlM0QoY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5iZWdpbiwgY29uZmlnLmFyZ3Muc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdTbGljZTREJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5zbGljZTREKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYmVnaW4sIGNvbmZpZy5hcmdzLnNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUmV2ZXJzZTREJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5yZXZlcnNlNEQoY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5heGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0NvbmNhdCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29uY2F0KGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ05lZycpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubmVnKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBZGQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmFkZChjb25maWcuaW5wdXRzLmEsIGNvbmZpZy5pbnB1dHMuYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdTdWInKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnN1YnRyYWN0KGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ011bCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubXVsdGlwbHkoY29uZmlnLmlucHV0cy5hLCBjb25maWcuaW5wdXRzLmIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnRGl2Jykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5kaXZpZGUoY29uZmlnLmlucHV0cy5hLCBjb25maWcuaW5wdXRzLmIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnU3VtJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5zdW0oY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5heGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0FyZ01heCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuYXJnTWF4KGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYXhlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBcmdNaW4nKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmFyZ01pbihjb25maWcuaW5wdXRzLngsIGNvbmZpZy5hcmdzLmF4ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnRXF1YWwnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmVxdWFsKGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ05vdEVxdWFsJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5ub3RFcXVhbChjb25maWcuaW5wdXRzLmEsIGNvbmZpZy5pbnB1dHMuYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdMZXNzJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5sZXNzKGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0xlc3NFcXVhbCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubGVzc0VxdWFsKGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0dyZWF0ZXInKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmdyZWF0ZXIoY29uZmlnLmlucHV0cy5hLCBjb25maWcuaW5wdXRzLmIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnR3JlYXRlckVxdWFsJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5ncmVhdGVyRXF1YWwoY29uZmlnLmlucHV0cy5hLCBjb25maWcuaW5wdXRzLmIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnTG9naWNhbEFuZCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubG9naWNhbEFuZChjb25maWcuaW5wdXRzLmEsIGNvbmZpZy5pbnB1dHMuYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdMb2dpY2FsT3InKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmxvZ2ljYWxPcihjb25maWcuaW5wdXRzLmEsIGNvbmZpZy5pbnB1dHMuYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdXaGVyZScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQud2hlcmUoY29uZmlnLmlucHV0cy5jb25kaXRpb24sIGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iLCBjb25maWcuYXJncy5kdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdUb3BLVmFsdWVzJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC50b3BLVmFsdWVzKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3Muayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdUb3BLSW5kaWNlcycpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQudG9wS0luZGljZXMoY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5rKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ01pbicpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWluKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYXhlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdNaW5pbXVtJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5taW5pbXVtKGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ01heCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWF4KGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYXhlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdNYXhpbXVtJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYXhpbXVtKGNvbmZpZy5pbnB1dHMuYSwgY29uZmlnLmlucHV0cy5iKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0NlaWwnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNlaWwoY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0Zsb29yJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5mbG9vcihjb25maWcuaW5wdXRzLngpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUG93Jykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5wb3coY29uZmlnLmlucHV0cy5iYXNlLCBjb25maWcuaW5wdXRzLmV4cCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdFeHAnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmV4cChjb25maWcuaW5wdXRzLngpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnTG9nJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5sb2coY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1NxcnQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnNxcnQoY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1NxdWFyZScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuc3F1YXJlKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdSZWx1Jykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5yZWx1KGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdSZXNoYXBlJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5pbnB1dHMueDtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gY29uZmlnLmFyZ3MubmV3U2hhcGU7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IGRhdGFJZDogeC5kYXRhSWQgfSwgeC5kdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdDYXN0Jykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5pbnB1dHMueDtcbiAgICAgICAgdmFyIG5ld0RUeXBlID0gY29uZmlnLmFyZ3MubmV3RFR5cGU7XG4gICAgICAgIGlmICghdXRpbC5oYXNFbmNvZGluZ0xvc3MoeC5kdHlwZSwgbmV3RFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh4LnNoYXBlLCB7IGRhdGFJZDogeC5kYXRhSWQgfSwgbmV3RFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdEVHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmQuaW50KHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0RUeXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiYWNrZW5kLm5vdEVxdWFsKHgsIG5kYXJyYXlfMS5TY2FsYXIubmV3KDAsIHguZHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIENhc3Q6IHVua25vd24gZHR5cGUgYXJndW1lbnQgKFwiICsgbmV3RFR5cGUgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0xlYWt5UmVsdScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubGVha3lSZWx1KGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuYWxwaGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUFJlTFUnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnByZWx1KGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmlucHV0cy5hbHBoYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdQUmVMVURlcicpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQucHJlbHVEZXIoY29uZmlnLmlucHV0cy54LCBjb25maWcuaW5wdXRzLmFscGhhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0VsdScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuZWx1KGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdFbHVEZXInKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmVsdURlcihjb25maWcuaW5wdXRzLngpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnU2VsdScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuc2VsdShjb25maWcuaW5wdXRzLngpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQWJzJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hYnMoY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1NpZ21vaWQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnNpZ21vaWQoY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1N0ZXAnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnN0ZXAoY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5hbHBoYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdTaW4nKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnNpbihjb25maWcuaW5wdXRzLngpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQ29zJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jb3MoY29uZmlnLmlucHV0cy54KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ1RhbicpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQudGFuKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBc2luJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hc2luKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBY29zJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hY29zKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBdGFuJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hdGFuKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdTaW5oJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5zaW5oKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdDb3NoJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jb3NoKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdUYW5oJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC50YW5oKGNvbmZpZy5pbnB1dHMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdDbGlwJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jbGlwKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MubWluLCBjb25maWcuYXJncy5tYXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnVGlsZScpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQudGlsZShjb25maWcuaW5wdXRzLngsIGNvbmZpZy5hcmdzLnJlcHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnR2F0aGVyJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5nYXRoZXIoY29uZmlnLmlucHV0cy54LCBjb25maWcuaW5wdXRzLmluZGljZXMsIGNvbmZpZy5hcmdzLmF4aXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUGFkMUQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnBhZDFEKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MucGFkZGluZ3MsIGNvbmZpZy5hcmdzLmNvbnN0YW50VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUGFkMkQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnBhZDJEKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MucGFkZGluZ3MsIGNvbmZpZy5hcmdzLmNvbnN0YW50VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnVHJhbnNwb3NlJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC50cmFuc3Bvc2UoY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5wZXJtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0NvbnYyRCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29udjJkKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmlucHV0cy5maWx0ZXIsIGNvbmZpZy5pbnB1dHMuYmlhcywgY29uZmlnLmFyZ3MuY29udkluZm8pO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQ29udjJERGVySW5wdXQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbnYyZERlcklucHV0KGNvbmZpZy5pbnB1dHMuZHksIGNvbmZpZy5pbnB1dHMuZmlsdGVyLCBjb25maWcuYXJncy5jb252SW5mbyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdDb252MkREZXJGaWx0ZXInKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbnYyZERlckZpbHRlcihjb25maWcuaW5wdXRzLngsIGNvbmZpZy5pbnB1dHMuZHksIGNvbmZpZy5hcmdzLmNvbnZJbmZvKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0NvbnYyRERlckJpYXMnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbnYyZERlckJpYXMoY29uZmlnLmlucHV0cy5keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdEZXB0aHdpc2VDb252MkQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmRlcHRod2lzZUNvbnYyRChjb25maWcuaW5wdXRzLngsIGNvbmZpZy5pbnB1dHMuZmlsdGVyLCBjb25maWcuYXJncy5jb252SW5mbyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdNYXhQb29sJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYXhQb29sKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuY29udkluZm8pO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnTWF4UG9vbEJhY2twcm9wJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYXhQb29sQmFja3Byb3AoY29uZmlnLmlucHV0cy5keSwgY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5jb252SW5mbyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdBdmdQb29sJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hdmdQb29sKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuY29udkluZm8pO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQXZnUG9vbEJhY2twcm9wJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5hdmdQb29sQmFja3Byb3AoY29uZmlnLmlucHV0cy5keSwgY29uZmlnLmlucHV0cy54LCBjb25maWcuYXJncy5jb252SW5mbyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdNaW5Qb29sJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5taW5Qb29sKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MuY29udkluZm8pO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnUmVzaXplQmlsaW5lYXInKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnJlc2l6ZUJpbGluZWFyKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MubmV3SGVpZ2h0LCBjb25maWcuYXJncy5uZXdXaWR0aCwgY29uZmlnLmFyZ3MuYWxpZ25Db3JuZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0JhdGNoTm9ybTREJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5iYXRjaE5vcm1hbGl6YXRpb240RChjb25maWcuaW5wdXRzLngsIGNvbmZpZy5pbnB1dHMubWVhbiwgY29uZmlnLmlucHV0cy52YXJpYW5jZSwgY29uZmlnLmFyZ3MudmFyaWFuY2VFcHNpbG9uLCBjb25maWcuaW5wdXRzLnNjYWxlLCBjb25maWcuaW5wdXRzLm9mZnNldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdCYXRjaE5vcm0zRCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuYmF0Y2hOb3JtYWxpemF0aW9uM0QoY29uZmlnLmlucHV0cy54LCBjb25maWcuaW5wdXRzLm1lYW4sIGNvbmZpZy5pbnB1dHMudmFyaWFuY2UsIGNvbmZpZy5hcmdzLnZhcmlhbmNlRXBzaWxvbiwgY29uZmlnLmlucHV0cy5zY2FsZSwgY29uZmlnLmlucHV0cy5vZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXJuZWxOYW1lID09PSAnQmF0Y2hOb3JtMkQnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmJhdGNoTm9ybWFsaXphdGlvbjJEKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmlucHV0cy5tZWFuLCBjb25maWcuaW5wdXRzLnZhcmlhbmNlLCBjb25maWcuYXJncy52YXJpYW5jZUVwc2lsb24sIGNvbmZpZy5pbnB1dHMuc2NhbGUsIGNvbmZpZy5pbnB1dHMub2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2VybmVsTmFtZSA9PT0gJ0xSTjREJykge1xuICAgICAgICB2YXIgY29uZmlnID0gaW5wdXRBbmRBcmdzO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREKGNvbmZpZy5pbnB1dHMueCwgY29uZmlnLmFyZ3MucmFkaXVzLCBjb25maWcuYXJncy5iaWFzLCBjb25maWcuYXJncy5hbHBoYSwgY29uZmlnLmFyZ3MuYmV0YSwgY29uZmlnLmFyZ3Mubm9ybVJlZ2lvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdNdWx0aW5vbWlhbCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGlucHV0QW5kQXJncztcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubXVsdGlub21pYWwoY29uZmlnLmlucHV0cy5wcm9icywgY29uZmlnLmFyZ3MubnVtU2FtcGxlcywgY29uZmlnLmFyZ3Muc2VlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtlcm5lbE5hbWUgPT09ICdPbmVIb3QnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpbnB1dEFuZEFyZ3M7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm9uZUhvdChjb25maWcuaW5wdXRzLmluZGljZXMsIGNvbmZpZy5hcmdzLmRlcHRoLCBjb25maWcuYXJncy5vblZhbHVlLCBjb25maWcuYXJncy5vZmZWYWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJhY2tlbmQgbWV0aG9kIGZvdW5kIGZvciBrZXJuZWwgXCIgKyBrZXJuZWxOYW1lKTtcbn1cbmV4cG9ydHMuZXhlY3V0ZUtlcm5lbCA9IGV4ZWN1dGVLZXJuZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXJuZWxfcmVnaXN0cnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9uZGFycmF5XCIpO1xuZnVuY3Rpb24gZ2V0RmlsdGVyZWROb2Rlc1hUb1kodGFwZSwgeHMsIHkpIHtcbiAgICB2YXIgYXJyYXlzRnJvbVggPSB7fTtcbiAgICB2YXIgbm9kZXNGcm9tWCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlzRnJvbVhbeHNbaV0uaWRdID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGFwZVtpXTtcbiAgICAgICAgdmFyIG5vZGVJbnB1dHMgPSBub2RlLmlucHV0QW5kQXJncy5pbnB1dHM7XG4gICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlSW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlSW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICB2YXIgYW55SW5wdXRGcm9tWCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB4cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheXNGcm9tWFtpbnB1dC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0IGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5c0Zyb21YW25vZGUub3V0cHV0LmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlzRnJvbVhbbm9kZS5vdXRwdXRba2V5XS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFueUlucHV0RnJvbVggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc0Zyb21YW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFueUlucHV0RnJvbVgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJyYXlzTGVhZFRvWSA9IHt9O1xuICAgIGFycmF5c0xlYWRUb1lbeS5pZF0gPSB0cnVlO1xuICAgIHZhciBub2Rlc1RvWSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSB0YXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gdGFwZVtpXTtcbiAgICAgICAgdmFyIG5vZGVJbnB1dHMgPSBub2RlLmlucHV0QW5kQXJncy5pbnB1dHM7XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIGlmIChub2RlLm91dHB1dCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2gobm9kZS5vdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLm91dHB1dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGtleXNfMiA9IGtleXM7IF9hIDwga2V5c18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzJbX2FdO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChub2RlLm91dHB1dFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dHB1dHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheXNMZWFkVG9ZW291dHB1dHNbal0uaWRdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5wdXROYW1lIGluIG5vZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlzTGVhZFRvWVtub2RlSW5wdXRzW2lucHV0TmFtZV0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1lbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmlsdGVyZWRUYXBlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGFwZVtpXTtcbiAgICAgICAgaWYgKG5vZGVzRnJvbVhbbm9kZS5pZF0gJiYgbm9kZXNUb1lbbm9kZS5pZF0pIHtcbiAgICAgICAgICAgIHZhciBwcnVuZWRJbnB1dHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlLmlucHV0QW5kQXJncy5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUlucHV0ID0gbm9kZS5pbnB1dEFuZEFyZ3MuaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5c0Zyb21YW25vZGVJbnB1dC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVkSW5wdXRzW2lucHV0TmFtZV0gPSBub2RlSW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBydW5lZE91dHB1dHMgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXQgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgICAgIHBydW5lZE91dHB1dHMgPSBub2RlLm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBydW5lZE91dHB1dHMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvdXRwdXROYW1lIGluIG5vZGUub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dFtvdXRwdXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5c0xlYWRUb1lbb3V0cHV0LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJ1bmVkT3V0cHV0c1tvdXRwdXROYW1lXSA9IG5vZGUub3V0cHV0W291dHB1dE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBydW5lZE5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgICAgIHBydW5lZE5vZGUuaW5wdXRBbmRBcmdzID0geyBpbnB1dHM6IHBydW5lZElucHV0cyB9O1xuICAgICAgICAgICAgcHJ1bmVkTm9kZS5vdXRwdXQgPSBwcnVuZWRPdXRwdXRzO1xuICAgICAgICAgICAgZmlsdGVyZWRUYXBlLnB1c2gocHJ1bmVkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkVGFwZTtcbn1cbmV4cG9ydHMuZ2V0RmlsdGVyZWROb2Rlc1hUb1kgPSBnZXRGaWx0ZXJlZE5vZGVzWFRvWTtcbmZ1bmN0aW9uIGJhY2twcm9wYWdhdGVHcmFkaWVudHMoYXJyYXlBY2N1bXVsYXRlZEdyYWRpZW50TWFwLCBmaWx0ZXJlZFRhcGUpIHtcbiAgICBmb3IgKHZhciBpID0gZmlsdGVyZWRUYXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gZmlsdGVyZWRUYXBlW2ldO1xuICAgICAgICB2YXIgZHkgPSB2b2lkIDA7XG4gICAgICAgIGlmIChub2RlLm91dHB1dCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICBkeSA9IGFycmF5QWNjdW11bGF0ZWRHcmFkaWVudE1hcFtub2RlLm91dHB1dC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkeSA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLm91dHB1dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMyA9IGtleXM7IF9pIDwga2V5c18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzNbX2ldO1xuICAgICAgICAgICAgICAgIGR5W2tleV0gPSBhcnJheUFjY3VtdWxhdGVkR3JhZGllbnRNYXBbbm9kZS5vdXRwdXRba2V5XS5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ3JhZGllbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQ6IGdyYWRpZW50IGZ1bmN0aW9uIG5vdCBmb3VuZCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZm9yIFwiICsgbm9kZS5uYW1lICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRHcmFkaWVudHMgPSBub2RlLmdyYWRpZW50KGR5LCBub2RlLm91dHB1dCk7XG4gICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlLmlucHV0QW5kQXJncy5pbnB1dHMpIHtcbiAgICAgICAgICAgIGlmICghKGlucHV0TmFtZSBpbiBpbnB1dEdyYWRpZW50cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIiArIGlucHV0TmFtZSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiICsgT2JqZWN0LmtleXMoaW5wdXRHcmFkaWVudHMpICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkeCA9IGlucHV0R3JhZGllbnRzW2lucHV0TmFtZV0oKTtcbiAgICAgICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dEFuZEFyZ3MuaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoZHguc2hhcGUsIHguc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiICsgbm9kZS5uYW1lICsgXCIuIFRoZSBncmFkaWVudCBvZiBpbnB1dCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIidcIiArIGlucHV0TmFtZSArIFwiJyBoYXMgc2hhcGUgJ1wiICsgZHguc2hhcGUgKyBcIicsIHdoaWNoIGRvZXMgbm90IG1hdGNoIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcInRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgJ1wiICsgeC5zaGFwZSArIFwiJ1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyYXlBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhcnJheUFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPSBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjdXJHcmFkaWVudCA9IGFycmF5QWNjdW11bGF0ZWRHcmFkaWVudE1hcFt4LmlkXTtcbiAgICAgICAgICAgICAgICBhcnJheUFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPSBjdXJHcmFkaWVudC5hZGQoZHgpO1xuICAgICAgICAgICAgICAgIGN1ckdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYmFja3Byb3BhZ2F0ZUdyYWRpZW50cyA9IGJhY2twcm9wYWdhdGVHcmFkaWVudHM7XG5mdW5jdGlvbiBjb21wdXRlVmFyaWFibGVJbnB1dHModGFwZSwgdmFyTGlzdCkge1xuICAgIHZhciB0cmFpbmFibGVWYXJpYWJsZXMgPSBbXTtcbiAgICB2YXIgdHJhaW5hYmxlVmFyaWFibGVzU2VlbiA9IHt9O1xuICAgIHZhciB2YXJpYWJsZUlkcyA9IHt9O1xuICAgIHZhckxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgdmFyaWFibGVJZHNbdmFyaWFibGUuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YXBlW2ldO1xuICAgICAgICB2YXIgaW5wdXRzID0gbm9kZS5pbnB1dEFuZEFyZ3MuaW5wdXRzO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0cyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c180ID0ga2V5czsgX2kgPCBrZXlzXzQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c180W19pXTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c1trZXldO1xuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgbmRhcnJheV8xLlZhcmlhYmxlICYmICF0cmFpbmFibGVWYXJpYWJsZXNTZWVuW2lucHV0LmlkXSkge1xuICAgICAgICAgICAgICAgIGlmICh2YXJMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlSWRzW2lucHV0LmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFpbmFibGVWYXJpYWJsZXMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgdHJhaW5hYmxlVmFyaWFibGVzU2VlbltpbnB1dHNba2V5XS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFpbmFibGVWYXJpYWJsZXM7XG59XG5leHBvcnRzLmNvbXB1dGVWYXJpYWJsZUlucHV0cyA9IGNvbXB1dGVWYXJpYWJsZUlucHV0cztcbmZ1bmN0aW9uIGV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciByZXN1bHRPYmogPSByZXN1bHQ7XG4gICAgZm9yICh2YXIgayBpbiByZXN1bHRPYmopIHtcbiAgICAgICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIHV0aWwuZmxhdHRlbihyZXN1bHRPYmpba10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5leHBvcnRzLmV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdCA9IGV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdDtcbmZ1bmN0aW9uIHN0cmlwVW5kZWZpbmVkSW5wdXRzRnJvbUlucHV0Q29uZmlnKGNvbmZpZykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnLmlucHV0cyk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5pbnB1dHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLmlucHV0c1trZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbmV4cG9ydHMuc3RyaXBVbmRlZmluZWRJbnB1dHNGcm9tSW5wdXRDb25maWcgPSBzdHJpcFVuZGVmaW5lZElucHV0c0Zyb21JbnB1dENvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcGVfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXRyaXhPcmllbnRhdGlvbjtcbihmdW5jdGlvbiAoTWF0cml4T3JpZW50YXRpb24pIHtcbiAgICBNYXRyaXhPcmllbnRhdGlvbltNYXRyaXhPcmllbnRhdGlvbltcIlJFR1VMQVJcIl0gPSAwXSA9IFwiUkVHVUxBUlwiO1xuICAgIE1hdHJpeE9yaWVudGF0aW9uW01hdHJpeE9yaWVudGF0aW9uW1wiVFJBTlNQT1NFRFwiXSA9IDFdID0gXCJUUkFOU1BPU0VEXCI7XG59KShNYXRyaXhPcmllbnRhdGlvbiA9IGV4cG9ydHMuTWF0cml4T3JpZW50YXRpb24gfHwgKGV4cG9ydHMuTWF0cml4T3JpZW50YXRpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0bXVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFyZ01pbk1heFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZ01pbk1heFByb2dyYW0ocmVkdWNlSW5mbywgb3AsIGZpcnN0UGFzcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgaWYgKCFmaXJzdFBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiZXN0SW5kaWNlc0EnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBjb21wT3AgPSAob3AgPT09ICdtYXgnKSA/ICc+JyA6ICc8JztcbiAgICAgICAgdmFyIGluZGV4U25pcHBldCA9IGZpcnN0UGFzcyA/XG4gICAgICAgICAgICAnaW5PZmZzZXQgKyBpOycgOlxuICAgICAgICAgICAgJ3JvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7JztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gMDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGluT2Zmc2V0KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplICsgXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIiArIGluZGV4U25pcHBldCArIFwiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChpc05hTihjYW5kaWRhdGUpKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGNhbmRpZGF0ZSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIgKyBjb21wT3AgKyBcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQXJnTWluTWF4UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkFyZ01pbk1heFByb2dyYW0gPSBBcmdNaW5NYXhQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWlubWF4X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIiArIGF2Z011bHRpcGxpZXIgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbSA9IEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF2Z19wb29sX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBCYXRjaE5vcm1Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1Qcm9ncmFtKHhTaGFwZSwgbWVhblNoYXBlLCB2YXJpYW5jZVNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdtZWFuJywgJ3ZhcmlhbmNlJ107XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCB2YXJpYW5jZVNoYXBlKTtcbiAgICAgICAgdmFyIG9mZnNldFNuaXBwZXQgPSAnMC4wJztcbiAgICAgICAgaWYgKG9mZnNldFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgb2Zmc2V0U2hhcGUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ29mZnNldCcpO1xuICAgICAgICAgICAgb2Zmc2V0U25pcHBldCA9ICdnZXRPZmZzZXRBdE91dENvb3JkcygpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTbmlwcGV0ID0gJzEuMCc7XG4gICAgICAgIGlmIChzY2FsZVNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiICsgc2NhbGVTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1Qcm9ncmFtID0gQmF0Y2hOb3JtUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNobm9ybV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgQ0hFQ0tfTkFOX1NOSVBQRVQgPSBcIlxcbiAgaWYgKGlzTmFOKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc05hTihiKSkgcmV0dXJuIGI7XFxuXCI7XG5leHBvcnRzLkFERCA9ICdyZXR1cm4gYSArIGI7JztcbmV4cG9ydHMuU1VCID0gJ3JldHVybiBhIC0gYjsnO1xuZXhwb3J0cy5NVUwgPSAncmV0dXJuIGEgKiBiOyc7XG5leHBvcnRzLkRJViA9ICdyZXR1cm4gYSAvIGI7JztcbmV4cG9ydHMuUE9XID0gXCJcXG4gIHJldHVybiAocm91bmQobW9kKGIsIDIuMCkpID09IDAgfHwgcm91bmQobW9kKGIsIDIuMCkpID09IDIpID9cXG4gICAgICBwb3coYWJzKGEpLCBiKSA6IHNpZ24oYSkgKiBwb3coYWJzKGEpLCBiKTtcXG5cIjtcbmV4cG9ydHMuRVFVQUwgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG5cIjtcbmV4cG9ydHMuTk9UX0VRVUFMID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KGEgIT0gYik7XFxuXCI7XG5leHBvcnRzLkxFU1MgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA8IGIpO1xcblwiO1xuZXhwb3J0cy5MRVNTX0VRVUFMID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KGEgPD0gYik7XFxuXCI7XG5leHBvcnRzLkdSRUFURVIgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA+IGIpO1xcblwiO1xuZXhwb3J0cy5HUkVBVEVSX0VRVUFMID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KGEgPj0gYik7XFxuXCI7XG5leHBvcnRzLkxPR0lDQUxfQU5EID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KGEgPj0gMS4wICYmIGIgPj0gMS4wKTtcXG5cIjtcbmV4cG9ydHMuTE9HSUNBTF9PUiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XFxuXCI7XG5leHBvcnRzLlBSRUxVID0gXCJcXG4gIHJldHVybiAoYSA+PSAwLjApID8gYSA6IGIgKiBhO1xcblwiO1xuZXhwb3J0cy5QUkVMVV9ERVIgPSBcIlxcbiAgcmV0dXJuIChhID4gMC4wKSA/IDEuMCA6ICgoYSA8IDAuMCkgPyBiIDogYSk7XFxuXCI7XG5leHBvcnRzLk1BWCA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBtYXgoYSwgYik7XFxuXCI7XG5leHBvcnRzLk1JTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCI7XG52YXIgQmluYXJ5T3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlPcFByb2dyYW0ob3AsIGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgIFwiICsgb3AgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQmluYXJ5T3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5T3BQcm9ncmFtID0gQmluYXJ5T3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5b3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENsaXBQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGlwUHJvZ3JhbShhU2hhcGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB2YXIgbWluRml4ZWQgPSBtaW4udG9GaXhlZCgyMCk7XG4gICAgICAgIHZhciBtYXhGaXhlZCA9IG1heC50b0ZpeGVkKDIwKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBcIiArIG1pbkZpeGVkICsgXCIsIFwiICsgbWF4Rml4ZWQgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDbGlwUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNsaXBQcm9ncmFtID0gQ2xpcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGlwX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb25jYXRfdXRpbFwiKTtcbnZhciBDb25jYXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRQcm9ncmFtKGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYVNoYXBlLCBiU2hhcGUsIDEpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB5UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgIGlmICh5QyA8IFwiICsgYVNoYXBlWzFdICsgXCIpIHtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRBKHlSLCB5Qyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB5QyAtPSBcIiArIGFTaGFwZVsxXSArIFwiO1xcbiAgICAgICAgICB2YWx1ZSA9IGdldEIoeVIsIHlDKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbmNhdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db25jYXRQcm9ncmFtID0gQ29uY2F0UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29udjJERGVyRmlsdGVyUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiICsgY29udkluZm8uYmF0Y2hTaXplICsgXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIiArIHN0cmlkZVdpZHRoICsgXCIgLSBcIiArIHBhZExlZnQgKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlckZpbHRlclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJGaWx0ZXJQcm9ncmFtID0gQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbnZhciBDb252MkREZXJJbnB1dFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIgKyBmaWx0ZXJXaWR0aCArIFwiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIiArIGNvbnZJbmZvLm91dENoYW5uZWxzICsgXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlcklucHV0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlcklucHV0UHJvZ3JhbSA9IENvbnYyRERlcklucHV0UHJvZ3JhbTtcbnZhciBDb252MkREZXJCaWFzUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyQmlhc1Byb2dyYW0oeVNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknXTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHlTaGFwZVswXSwgeU51bVJvd3MgPSB5U2hhcGVbMV0sIHlOdW1Db2xzID0geVNoYXBlWzJdLCBvdXRwdXREZXB0aCA9IHlTaGFwZVszXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRwdXREZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGludCBkMiA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgZmxvYXQgZGVyQmlhcyA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIgKyBiYXRjaFNpemUgKyBcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIHlOdW1Sb3dzICsgXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyB5TnVtQ29scyArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBkZXJCaWFzICs9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRlckJpYXMpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkREZXJCaWFzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlckJpYXNQcm9ncmFtID0gQ29udjJERGVyQmlhc1Byb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkRQcm9ncmFtKGNvbnZJbmZvLCBoYXNCaWFzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGJpYXNTbmlwcGV0ID0gaGFzQmlhcyA/ICdkb3RQcm9kICs9IGdldEJpYXMoZDIpOycgOiAnJztcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihjb252SW5mby5pbkNoYW5uZWxzIC8gNCkgKiA0O1xuICAgICAgICB2YXIgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBjb252SW5mby5pbkNoYW5uZWxzICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIikgKlxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIFwiICsgYmlhc1NuaXBwZXQgKyBcIlxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJEUHJvZ3JhbSA9IENvbnYyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZXB0aHdpc2VDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0gY29udkluZm8uaW5IZWlnaHQ7XG4gICAgICAgIHZhciB4TnVtQ29scyA9IGNvbnZJbmZvLmluV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGNoYW5uZWxNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMiAvIFwiICsgY2hhbm5lbE11bCArIFwiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuXFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0Vyh3Uiwgd0MsIGQxLCBxKTtcXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlcHRod2lzZUNvbnYyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5EZXB0aHdpc2VDb252MkRQcm9ncmFtID0gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfZ3B1X2RlcHRod2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb3B5MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3B5MkRQcm9ncmFtKHNyY051bUNvbHMsIGRlc3ROdW1Db2xzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGl2ZWMyIHNvdXJjZVN0YXJ0O1xcbiAgICAgIHVuaWZvcm0gaXZlYzIgZGVzdFN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGRlc3RDb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKSAtIGRlc3RTdGFydDtcXG4gICAgICAgIGludCBpbmRleCA9IGRlc3RDb29yZHMueCAqIFwiICsgZGVzdE51bUNvbHMgKyBcIiArIGRlc3RDb29yZHMueTtcXG4gICAgICAgIGludCByID0gaW5kZXggLyBcIiArIHNyY051bUNvbHMgKyBcIjtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNvb3JkcyA9IHNvdXJjZVN0YXJ0ICsgaXZlYzIociwgaW5kZXggLSByICogXCIgKyBzcmNOdW1Db2xzICsgXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShzb3VyY2VDb29yZHMueCwgc291cmNlQ29vcmRzLnkpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBDb3B5MkRQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc291cmNlU3RhcnQsIGRlc3RTdGFydCwgZGVzdFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBncGdwdS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbihkZXN0U3RhcnRbMF0sIGRlc3RTaXplWzBdLCBkZXN0U3RhcnRbMV0sIGRlc3RTaXplWzFdKTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NvdXJjZVN0YXJ0Jyk7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMmkoc291cmNlU3RhcnRDUkxvYywgc291cmNlU3RhcnRbMF0sIHNvdXJjZVN0YXJ0WzFdKTtcbiAgICAgICAgICAgIHZhciBkZXN0U3RhcnRDUkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdkZXN0U3RhcnQnKTtcbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShkZXN0U3RhcnRDUkxvYywgZGVzdFN0YXJ0WzBdLCBkZXN0U3RhcnRbMV0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvcHkyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db3B5MkRQcm9ncmFtID0gQ29weTJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHlfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZyb21QaXhlbHNQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tUGl4ZWxzUHJvZ3JhbShvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG91dHB1dFNoYXBlWzBdLCB3aWR0aCA9IG91dHB1dFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgd2lkdGggKyBcIi4wLCBcIiArIGhlaWdodCArIFwiLjApO1xcblxcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSB0ZXh0dXJlMkQoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRnJvbVBpeGVsc1Byb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Gcm9tUGl4ZWxzUHJvZ3JhbSA9IEZyb21QaXhlbHNQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbV9waXhlbHNfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIEdhdGhlclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdGhlclByb2dyYW0oYVNoYXBlLCBpbmRpY2VzTGVuZ3RoLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdpbmRpY2VzJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGFTaGFwZS5zbGljZSgpO1xuICAgICAgICBvdXRwdXRTaGFwZVtheGlzXSA9IGluZGljZXNMZW5ndGg7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSwgYXhpcyk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBHYXRoZXJQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuR2F0aGVyUHJvZ3JhbSA9IEdhdGhlclByb2dyYW07XG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMoYVNoYXBlLCBheGlzKSB7XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdhdGhlciBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50KGdldEluZGljZXMocmVzUkMpKVwiO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzb3VyY2VDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIiArIGN1cnJlbnRDb29yZHNbaV0gKyBcIikpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2F0aGVyX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9ncGdwdV91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG52YXIgR1BHUFVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHUEdQVUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbiA9XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uJyArXG4gICAgICAgICAgICAgICAgJyBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ0dQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggJyArXG4gICAgICAgICAgICAgICAgJ3RleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgJyArXG4gICAgICAgICAgICAgICAgJ21hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICdkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlRnJhbWVidWZmZXIoX3RoaXMuZnJhbWVidWZmZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMudmVydGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMuaW5kZXhCdWZmZXIpOyB9KTtcbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlQXV0b21hdGljRGVidWdWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSA9IGVuYWJsZWQ7XG4gICAgICAgIHdlYmdsX3V0aWwuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGdwZ3B1X3V0aWwudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHBpeGVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZG93bmxvYWQgbWF0cml4IGZyb20gb3V0cHV0IHRleHR1cmUgYXN5bmNocm9ub3VzbHksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYyBpcyBub3QgZW5hYmxlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jKF90aGlzLmdsLCBfdGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24sIHJvd3MsIGNvbHVtbnMpOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscyk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHdlYmdsX3V0aWwuY3JlYXRlUHJvZ3JhbShnbCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5saW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlbGV0ZVByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAocHJvZ3JhbSA9PT0gdGhpcy5wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldFByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICBpZiAoKHRoaXMucHJvZ3JhbSAhPSBudWxsKSAmJiB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZ3JhbSwgdW5pZm9ybU5hbWUsIHNob3VsZFRocm93KSB7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdyA9PT0gdm9pZCAwKSB7IHNob3VsZFRocm93ID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KHRoaXMuZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24odGhpcy5nbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKHByb2dyYW0sIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cgPSBmdW5jdGlvbiAocHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRNYXRyaXhUZXh0dXJlLCBjb2x1bW5zLCByb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihzdGFydENvbHVtbiwgc3RhcnRSb3csIG51bUNvbHVtbnMsIG51bVJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtID0gZnVuY3Rpb24gKGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ3BncHVfdXRpbC5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhCdWZmZXIsIGF0dHJpYkxvY2F0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5maW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5Rm4pIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMihxdWVyeUZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMShxdWVyeUZuKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnlXZWJHTDIgPSBmdW5jdGlvbiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHQgPSB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5nbC5jcmVhdGVRdWVyeSgpO1xuICAgICAgICB0aGlzLmdsLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgYmVuY2htYXJrKCk7XG4gICAgICAgIHRoaXMuZ2wuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBfdGhpcy5nbFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIF90aGlzLmdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IF90aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFRpbWVFbGFwc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gX3RoaXMuZ2xcbiAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBfdGhpcy5nbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNqb2ludCBxdWVyeSB0aW1lciBuZXZlciBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShxdWVyeUdQVSkudGhlbihnZXRUaW1lRWxhcHNlZCkuY2F0Y2gocmVzb2x2ZVdpdGhXYXJuaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5V2ViR0wxID0gZnVuY3Rpb24gKGJlbmNobWFyaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXh0ID0gd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gZXh0LmNyZWF0ZVF1ZXJ5RVhUKCk7XG4gICAgICAgIGV4dC5iZWdpblF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhULCBxdWVyeSk7XG4gICAgICAgIGJlbmNobWFyaygpO1xuICAgICAgICBleHQuZW5kUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2pvaW50ID0gX3RoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICFkaXNqb2ludDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VGltZUVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzam9pbnQgcXVlcnkgdGltZXIgbmV2ZXIgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHV0aWwucmVwZWF0ZWRUcnkocXVlcnlHUFUpLnRoZW4oZ2V0VGltZUVsYXBzZWQpLmNhdGNoKHJlc29sdmVXaXRoV2FybmluZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0ZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5vdXRwdXRUZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwKHRleHR1cmUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZG93bmxvYWRBbmREZWNvZGUoKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyQXN5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZG93bmxvYWRBbmREZWNvZGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlciA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHUEdQVUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBHUEdQVUNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV9jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIHNoYWRlcl9jb21waWxlciA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBBVFRSSUJVVEVfTkFNRVMgPSBbJ3V2JywgJ2NsaXBTcGFjZVBvcyddO1xudmFyIE5BTl9VTklGT1JNX05BTUUgPSAnTmFOJztcbmZ1bmN0aW9uIHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSB7XG4gICAgcmV0dXJuICFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xufVxuZnVuY3Rpb24gY29tcGlsZVByb2dyYW0oZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIgaW5wdXRJbmZvcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUluZm8gPSB7XG4gICAgICAgICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LmFycmF5LnNoYXBlLFxuICAgICAgICAgICAgdGV4U2hhcGU6IGlucHV0LnRleERhdGEudGV4U2hhcGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBzaGFwZUluZm86IHNoYXBlSW5mbyB9O1xuICAgIH0pO1xuICAgIHZhciBpblNoYXBlSW5mb3MgPSBpbnB1dEluZm9zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZUluZm87IH0pO1xuICAgIHZhciBvdXRTaGFwZUluZm8gPSB7XG4gICAgICAgIGxvZ2ljYWxTaGFwZTogb3V0cHV0LmFycmF5LnNoYXBlLFxuICAgICAgICB0ZXhTaGFwZTogb3V0cHV0LnRleERhdGEudGV4U2hhcGVcbiAgICB9O1xuICAgIHZhciBzb3VyY2UgPSBzaGFkZXJfY29tcGlsZXIubWFrZVNoYWRlcihpbnB1dEluZm9zLCBvdXRTaGFwZUluZm8sIHVzZXJDb2RlLCBwcm9ncmFtLnN1cHBvcnRzQnJvYWRjYXN0aW5nID09PSB0cnVlKTtcbiAgICB2YXIgd2ViR0xQcm9ncmFtID0gZ3BncHUuY3JlYXRlUHJvZ3JhbShzb3VyY2UpO1xuICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtLnZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lID0gcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW3VuaWZvcm1OYW1lXSA9XG4gICAgICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfVxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB7fTtcbiAgICBBVFRSSUJVVEVfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldEF0dHJpYnV0ZUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIHZhciB0aHJvd0lmTmFOVW5pZm9ybUlzTm90VXNlZCA9IGZhbHNlO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgTkFOX1VOSUZPUk1fTkFNRSwgdGhyb3dJZk5hTlVuaWZvcm1Jc05vdFVzZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgd2ViR0xQcm9ncmFtOiB3ZWJHTFByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uczogYXR0cmlidXRlTG9jYXRpb25zLFxuICAgICAgICBncGdwdTogZ3BncHUsXG4gICAgICAgIGluU2hhcGVJbmZvczogaW5TaGFwZUluZm9zLFxuICAgICAgICBvdXRTaGFwZUluZm86IG91dFNoYXBlSW5mb1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVQcm9ncmFtID0gY29tcGlsZVByb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oc2hhcGVJbmZvcywgaW5wdXRzKSB7XG4gICAgaWYgKHNoYXBlSW5mb3MubGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiICsgc2hhcGVJbmZvcy5sZW5ndGggKyBcIiBpbnB1dHMsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJ3YXMgZXhlY3V0ZWQgd2l0aCBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dHNcIikpO1xuICAgIH1cbiAgICBzaGFwZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlQSA9IHMubG9naWNhbFNoYXBlO1xuICAgICAgICB2YXIgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IGlucHV0c1tpXS5hcnJheS5zaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQiA9IGlucHV0c1tpXS50ZXhEYXRhLnRleFNoYXBlO1xuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIiArIHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh0ZXhTaGFwZUEsIHRleFNoYXBlQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZVwiICtcbiAgICAgICAgICAgICAgICAoXCIgY3VycmVudCBhcmdzLiBTaGFwZSBcIiArIHRleFNoYXBlQSArIFwiIGFuZCBcIiArIHRleFNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKSB7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGJpbmFyeS5pblNoYXBlSW5mb3MsIGlucHV0cyk7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKFtiaW5hcnkub3V0U2hhcGVJbmZvXSwgW291dHB1dF0pO1xuICAgIHZhciBvdXRUZXggPSBvdXRwdXQudGV4RGF0YS50ZXh0dXJlO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dC50ZXhEYXRhLnRleFNoYXBlO1xuICAgIHZhciBncGdwdSA9IGJpbmFyeS5ncGdwdTtcbiAgICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKG91dFRleCwgb3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKTtcbiAgICBncGdwdS5zZXRQcm9ncmFtKGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICB2YXIgdGV4ID0gaW5wdXQudGV4RGF0YS50ZXh0dXJlO1xuICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gYmluYXJ5LnByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICAgICAgdmFyIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uID0gYmluYXJ5LnVuaWZvcm1Mb2NhdGlvbnNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHRleCwgdmFyaWFibGVVbmlmb3JtTG9jYXRpb24sIGkpO1xuICAgIH0pO1xuICAgIGlmIChzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdLCBOYU4pO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICBjdXN0b21TZXR1cChncGdwdSwgYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgfVxuICAgIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKGJpbmFyeS5hdHRyaWJ1dGVMb2NhdGlvbnMpO1xufVxuZXhwb3J0cy5ydW5Qcm9ncmFtID0gcnVuUHJvZ3JhbTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIga2V5SW5wdXRzID0gJyc7XG4gICAgaW5wdXRzLmNvbmNhdChvdXRwdXQpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAga2V5SW5wdXRzICs9IHguYXJyYXkuc2hhcGUgKyBcIl9cIiArIHgudGV4RGF0YS50ZXhTaGFwZTtcbiAgICB9KTtcbiAgICB2YXIga2V5VXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBrZXlCcm9hZGNhc3QgPSAocHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSkudG9TdHJpbmcoKTtcbiAgICB2YXIga2V5ID0gcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGtleSArPSAnXycgKyBrZXlCcm9hZGNhc3QgKyAnXycgKyBrZXlJbnB1dHMgKyAnXycgKyBrZXlVc2VyQ29kZTtcbiAgICByZXR1cm4ga2V5O1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyS2V5ID0gbWFrZVNoYWRlcktleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X21hdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxuICAgIH07XG59XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzO1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNhbnZhcykge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHZhciBnbDtcbiAgICBpZiAoY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5CTEVORCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRJVEhFUik7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmN1bGxGYWNlKGdsLkJBQ0spOyB9KTtcbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XFxuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xcbiAgICAgIHJlc3VsdFVWID0gdXY7XFxuICAgIH1cIjtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAwLCAwLCAxLCAtMSwgLTEsIDAsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDEsIC0xLCAwLCAxLCAwXSk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCB2ZXJ0ZXhBcnJheSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleEJ1ZmZlciA9IGNyZWF0ZVZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4QnVmZmVyKGdsKSB7XG4gICAgdmFyIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMiwgMSwgM10pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCB0cmlhbmdsZVZlcnRleEluZGljZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVJbmRleEJ1ZmZlciA9IGNyZWF0ZUluZGV4QnVmZmVyO1xuZnVuY3Rpb24gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscykge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGUoZ2wpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgfVxuICAgIHJldHVybiBnbC5GTE9BVDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgdGV4dHVyZSA9IHdlYmdsX3V0aWwuY3JlYXRlVGV4dHVyZShnbCk7XG4gICAgdmFyIHRleDJkID0gZ2wuVEVYVFVSRV8yRDtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB2YXIgZm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZSh0ZXgyZCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleEltYWdlMkQodGV4MmQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgbnVsbCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gMTtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVNYXRyaXhUZXh0dXJlID0gY3JlYXRlTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlID0gY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhCdWZmZXIsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgIHZhciBwb3NPZmZzZXQgPSAwO1xuICAgIHZhciB1dk9mZnNldCA9IDMgKiA0O1xuICAgIHZhciBzdHJpZGUgPSAoMyAqIDQpICsgKDIgKiA0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcik7IH0pO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ2NsaXBTcGFjZVBvcycsIHZlcnRleEJ1ZmZlciwgMywgc3RyaWRlLCBwb3NPZmZzZXQsIGF0dHJpYkxvY2F0aW9ucyk7XG4gICAgd2ViZ2xfdXRpbC5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCAndXYnLCB2ZXJ0ZXhCdWZmZXIsIDIsIHN0cmlkZSwgdXZPZmZzZXQsIGF0dHJpYkxvY2F0aW9ucyk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyA9IGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcztcbmZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCBudW1DaGFubmVscykge1xuICAgIHZhciB0ZXh0dXJlRm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlRm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIGRhdGEpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHVucGFja2VkQXJyYXk7XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxzUGVyVGV4dHVyZSA9IG51bUNoYW5uZWxzID09PSAxID8gd2ViZ2xfdXRpbC5nZXRDaGFubmVsc1BlclRleHR1cmUoKSA6IG51bUNoYW5uZWxzO1xuICAgICAgICBpZiAoY2hhbm5lbHNQZXJUZXh0dXJlID09PSAxKSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5wYWNrZWRBcnJheSA9XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgICAgICAgICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheSA9IHRleF91dGlsLmVuY29kZUZsb2F0QXJyYXkobWF0cml4KTtcbiAgICB9XG4gICAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgdW5wYWNrZWRBcnJheSwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSB1cGxvYWRNYXRyaXhUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSk7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCBwYWNrZWRSR0JBLCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIGlzRmxvYXRUZXh0dXJlID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKTtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQ7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIGRvd25sb2FkVGFyZ2V0ID1cbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShyb3dzICogY29sdW1ucywgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb3dubG9hZFRhcmdldCA9IG5ldyBVaW50OEFycmF5KHJvd3MgKiBjb2x1bW5zICogY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvd25sb2FkVGFyZ2V0O1xufVxuZnVuY3Rpb24gZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCkge1xuICAgIHZhciBpc0Zsb2F0VGV4dHVyZSA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICAgICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoZG93bmxvYWRUYXJnZXQsIG1hdHJpeCwgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4X3V0aWwuZGVjb2RlVG9GbG9hdEFycmF5KGRvd25sb2FkVGFyZ2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMoZ2wsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiwgcm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsMiwgY2hhbm5lbHNQZXJQaXhlbCwgZG93bmxvYWRUYXJnZXQsIGJ1ZmZlclNpemVCeXRlcywgYnVmZmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBnbDIgPSBnbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU2l6ZUJ5dGVzID0gZG93bmxvYWRUYXJnZXQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQubGVuZ3RoICogNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyU2l6ZUJ5dGVzLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsMi5yZWFkUGl4ZWxzKDAsIDAsIGNvbHVtbnMsIHJvd3MsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbi5nZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBkb3dubG9hZFRhcmdldCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYztcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgcmV0dXJuIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHNpemUgPSByb3dzICogY29sdW1ucyAqIDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZG93bmxvYWRUYXJnZXQpOyB9KTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3dubG9hZFRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWNrZWRSR0JBW2ldID0gZG93bmxvYWRUYXJnZXRbaV07XG4gICAgfVxuICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zICogY2hhbm5lbHMpO1xuICAgIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5KHBhY2tlZFJHQkEsIG1hdHJpeCwgY2hhbm5lbHMpO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBwYWNrZWRSR0JBKTsgfSk7XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgV2hlcmVQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaGVyZVByb2dyYW0oY1JhbmssIHNoYXBlLCByYW5rKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnYycsICdhJywgJ2InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlO1xuICAgICAgICB2YXIgY0Nvb3JkcztcbiAgICAgICAgdmFyIGFiQ29vcmRzO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gXCJyZXNSQ1wiO1xuICAgICAgICAgICAgY0Nvb3JkcyA9IFwicmVzUkNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgICAgICAgICB2YXIgY0Nvb3JkVmFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFiQ29vcmRWYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWJDb29yZFZhcnMucHVzaChcIlwiICsgY3VycmVudENvb3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjUmFuaykge1xuICAgICAgICAgICAgICAgICAgICBjQ29vcmRWYXJzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNDb29yZHMgPSBjQ29vcmRWYXJzLmpvaW4oKTtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gYWJDb29yZFZhcnMuam9pbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiICsgY0Nvb3JkcyArIFwiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIGFiQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiICsgYWJDb29yZHMgKyBcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBXaGVyZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5XaGVyZVByb2dyYW0gPSBXaGVyZVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dpY2FsX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMUk5Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUk5Qcm9ncmFtKHhTaGFwZSwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgcmFkID0gcmFkaXVzO1xuICAgICAgICB2YXIgbWF4VyA9IHhTaGFwZVsxXSAtIDE7XG4gICAgICAgIHZhciBtYXhIID0geFNoYXBlWzJdIC0gMTtcbiAgICAgICAgdmFyIG1heEQgPSB4U2hhcGVbM10gLSAxO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB2YXIgcG93T3BlcmF0b3I7XG4gICAgICAgIHZhciBiYXNpcyA9IFwiZmxvYXQoXCIgKyBiaWFzICsgXCIpICsgZmxvYXQoXCIgKyBhbHBoYSArIFwiKSAqIHN1bVwiO1xuICAgICAgICBpZiAoYmV0YSA9PT0gMC41KSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiaW52ZXJzZXNxcnQoXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJldGEgPT09IDEuMCkge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcIjEuMC8oXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcImV4cChsb2coXCIgKyBiYXNpcyArIFwiKSAqIGZsb2F0KC1cIiArIGJldGEgKyBcIikpO1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtUmVnaW9uID09PSAnd2l0aGluQ2hhbm5lbCcpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IHUgPSAtXCIgKyByYWQgKyBcIjsgdSA8PSBcIiArIHJhZCArIFwiOyB1KyspIHtcXG4gICAgICAgICAgICBmb3IgKGludCB2ID0gLVwiICsgcmFkICsgXCI7IHYgPD0gXCIgKyByYWQgKyBcIjsgdisrKSB7XFxuICAgICAgICAgICAgICBpbnQgaWR4ID0gciArIHU7XFxuICAgICAgICAgICAgICBpbnQgaWR5ID0gYyArIHY7XFxuICAgICAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9IFwiICsgbWF4VyArIFwiICYmIGlkeSA+PSAwICYmIGlkeSA8PSBcIiArIG1heEggKyBcIikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCBpZHgsIGlkeSwgZCk7XFxuICAgICAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZmxvYXQgdmFsID0geCAqIFwiICsgcG93T3BlcmF0b3IgKyBcIjtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZ2V0WChiLCByLCBjLCBkKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBqID0gLVwiICsgcmFkICsgXCI7IGogPD0gXCIgKyByYWQgKyBcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGlkeCA9IGQgKyBqO1xcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiICsgbWF4RCArIFwiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xcbiAgICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIgKyBwb3dPcGVyYXRvciArIFwiO1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTFJOUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkxSTlByb2dyYW0gPSBMUk5Qcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJuX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ21heFBvcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoIC0gMTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiICsgbGFzdEluZGV4ICsgXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1heFBvb2wyREJhY2twcm9wUHJvZ3JhbSA9IE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heF9wb29sX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy9tYXRtdWxcIik7XG52YXIgTWF0TXVsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TXVsUHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgYU9yaWVudCwgYk9yaWVudCkge1xuICAgICAgICBpZiAoYU9yaWVudCA9PT0gdm9pZCAwKSB7IGFPcmllbnQgPSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50ID09PSB2b2lkIDApIHsgYk9yaWVudCA9IG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydtYXRyaXhBJywgJ21hdHJpeEInXTtcbiAgICAgICAgdmFyIG91dGVyU2hhcGVBID0gKGFPcmllbnQgPT09IG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYVNoYXBlWzBdIDogYVNoYXBlWzFdO1xuICAgICAgICB2YXIgb3V0ZXJTaGFwZUIgPSAoYk9yaWVudCA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiU2hhcGVbMV0gOiBiU2hhcGVbMF07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbb3V0ZXJTaGFwZUEsIG91dGVyU2hhcGVCXTtcbiAgICAgICAgdmFyIHNoYXJlZERpbSA9IChhT3JpZW50ID09PSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSID8gYVNoYXBlWzFdIDogYVNoYXBlWzBdKTtcbiAgICAgICAgdmFyIGFTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIChhT3JpZW50ID09PSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICAgICAgXCJhUm93LCBcIiArIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgOlxuICAgICAgICAgICAgICAgIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgKyBcIiwgYVJvd1wiO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYlNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGJPcmllbnQgPT09IG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGJDb2xcIiA6XG4gICAgICAgICAgICAgICAgXCJiQ29sLCBcIiArIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzaGFyZWREaW1OZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Ioc2hhcmVkRGltIC8gNCkgKiA0O1xuICAgICAgICB2YXIgc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9IHNoYXJlZERpbSAlIDQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIiBmbG9hdCBkb3RBUm93QkNvbChpbnQgYVJvdywgaW50IGJDb2wpIHtcXG4gICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHNoYXJlZERpbU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgdmVjNCBhID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjNCBiID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgIHJlc3VsdCArPSBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSAqXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgdmVjMiBhID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjMiBiID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgIHZlYzMgYSA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMzIGIgPSB2ZWMzKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZG90QVJvd0JDb2wocmVzUkMueCwgcmVzUkMueSkpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF0TXVsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1hdE11bFByb2dyYW0gPSBNYXRNdWxQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsbWF0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNdWx0aW5vbWlhbFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncHJvYnMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bVNhbXBsZXNdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBNdWx0aW5vbWlhbFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpbm9taWFsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk11bHRpbm9taWFsUHJvZ3JhbSA9IE11bHRpbm9taWFsUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpbm9taWFsX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPbmVIb3RQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVIb3RQcm9ncmFtKG51bUluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2luZGljZXMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1JbmRpY2VzLCBkZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIiArIG9mZlZhbHVlICsgXCIpLCBmbG9hdChcIiArIG9uVmFsdWUgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBPbmVIb3RQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuT25lSG90UHJvZ3JhbSA9IE9uZUhvdFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVob3RfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhZDFEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFkMURQcm9ncmFtKHhTaGFwZSwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmdzWzBdO1xuICAgICAgICB2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZ3NbMV07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbbGVmdFBhZGRpbmcgKyB4U2hhcGVbMF0gKyByaWdodFBhZGRpbmddO1xuICAgICAgICB0aGlzLnJhbmsgPSAxO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpbnQgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChyZXNSQyA8IFwiICsgbGVmdFBhZGRpbmcgKyBcIiB8fCByZXNSQyA+PSBcIiArIGxlZnRQYWRkaW5nICsgXCIgKyBcIiArIHhTaGFwZVswXSArIFwiKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIGNvbnN0YW50VmFsdWUgKyBcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgocmVzUkMgLSBcIiArIGxlZnRQYWRkaW5nICsgXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUGFkMURQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUGFkMURQcm9ncmFtID0gUGFkMURQcm9ncmFtO1xudmFyIFBhZDJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFkMkRQcm9ncmFtKHhTaGFwZSwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHZhciB0b3BQYWRkaW5nID0gcGFkZGluZ3NbMF1bMF07XG4gICAgICAgIHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZ3NbMF1bMV07XG4gICAgICAgIHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmdzWzFdWzBdO1xuICAgICAgICB2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZ3NbMV1bMV07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXG4gICAgICAgICAgICB0b3BQYWRkaW5nICsgeFNoYXBlWzBdICsgYm90dG9tUGFkZGluZyxcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nICsgeFNoYXBlWzFdICsgcmlnaHRQYWRkaW5nXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMucmFuayA9IDI7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBcInJlc1JDLnggLSBcIiArIHRvcFBhZGRpbmcgKyBcIiwgcmVzUkMueSAtIFwiICsgbGVmdFBhZGRpbmc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdG9wU2hhcGUgPSBcIiArIHRvcFBhZGRpbmcgKyBcIiArIFwiICsgeFNoYXBlWzBdICsgXCI7XFxuICAgICAgICBpbnQgbGVmdFNoYXBlID0gXCIgKyBsZWZ0UGFkZGluZyArIFwiICsgXCIgKyB4U2hhcGVbMV0gKyBcIjtcXG4gICAgICAgIGlmIChyZXNSQy54IDwgXCIgKyB0b3BQYWRkaW5nICsgXCIgfHwgcmVzUkMueCA+PSB0b3BTaGFwZSB8fFxcbiAgICAgICAgICAgIHJlc1JDLnkgPCBcIiArIGxlZnRQYWRkaW5nICsgXCIgfHwgcmVzUkMueSA+PSBsZWZ0U2hhcGUpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgY29uc3RhbnRWYWx1ZSArIFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFBhZDJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBhZDJEUHJvZ3JhbSA9IFBhZDJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUG9vbDJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9vbDJEUHJvZ3JhbShjb252SW5mbywgcG9vbFR5cGUsIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZU9wXzEgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnPD0nIDogJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgXCIgKyBjb21wYXJlT3BfMSArIFwiIGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImF2Z1ZhbHVlIC8gXCIgKyBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCArIFwiLjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoaGFzTmFOKHZhbHVlcykpIHtcXG4gICAgICAgIHNldE91dHB1dChnZXROYU4odmFsdWVzKSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMywgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgICAgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUG9vbDJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBvb2wyRFByb2dyYW0gPSBQb29sMkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9vbF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVkdWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplO1xuICAgICAgICB2YXIgaW5TaXplID0gcmVkdWNlSW5mby5pblNpemU7XG4gICAgICAgIHZhciBvdXRTaXplID0gTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBpc1JlZHVjZVN1bSA9IHJlZHVjZVR5cGUgPT09ICdzdW0nO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzUmVkdWNlU3VtKSB7XG4gICAgICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSByZWR1Y2VUeXBlID09PSAnbWluJyA/ICdtaW4nIDogJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJzdW1WYWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dTaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHdpbmRvd1NpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciB3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9IHdpbmRvd1NpemUgJSA0O1xuICAgICAgICB2YXIgdXBkYXRlU25pcHBldCA9IFwiXFxuICAgICAgaWYgKFwiICsgaXNSZWR1Y2VTdW0gKyBcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChoYXNOYU4odmFsdWVzKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0TmFOKHZhbHVlcykpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja091dE9mQm91bmRzID0gXCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIgKyBpblNpemUgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIiArIGNoZWNrT3V0T2ZCb3VuZHMgKyBcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlZHVjZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VQcm9ncmFtID0gUmVkdWNlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRSZW5kZXJSR0JTaGFkZXIoZ3BncHUsIGRlc3RpbmF0aW9uV2lkdGgpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHNvdXJjZTtcXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICBjb25zdCBmbG9hdCBkZXN0aW5hdGlvbldpZHRoID0gXCIgKyBkZXN0aW5hdGlvbldpZHRoICsgXCIuMDtcXG4gICAgY29uc3QgZmxvYXQgYSA9IDEuMDtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGZsb2F0IHhyID0gZmxvb3IocmVzdWx0VVYucyAqIGRlc3RpbmF0aW9uV2lkdGgpICogMy4wO1xcbiAgICAgIHZlYzMgeCA9IHhyICsgdmVjMygwLCAxLCAyKTtcXG5cXG4gICAgICBmbG9hdCBzb3VyY2VXaWR0aCA9IGRlc3RpbmF0aW9uV2lkdGggKiAzLjA7XFxuICAgICAgdmVjMyB1ID0gKHggKyAwLjUpIC8gc291cmNlV2lkdGg7XFxuICAgICAgZmxvYXQgdiA9IDEuMCAtIHJlc3VsdFVWLnQ7XFxuXFxuICAgICAgZmxvYXQgciA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVswXSwgdikpLnI7XFxuICAgICAgZmxvYXQgZyA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVsxXSwgdikpLnI7XFxuICAgICAgZmxvYXQgYiA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVsyXSwgdikpLnI7XFxuXFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyLCBnLCBiLCBhKTtcXG4gICAgfVwiO1xuICAgIHJldHVybiBncGdwdS5jcmVhdGVQcm9ncmFtKGZyYWdtZW50U2hhZGVyU291cmNlKTtcbn1cbmV4cG9ydHMuZ2V0UmVuZGVyUkdCU2hhZGVyID0gZ2V0UmVuZGVyUkdCU2hhZGVyO1xuZnVuY3Rpb24gcmVuZGVyVG9DYW52YXMoZ3BncHUsIHJlbmRlclNoYWRlciwgc291cmNlVGV4KSB7XG4gICAgd2ViZ2xfdXRpbC5iaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihncGdwdS5nbCk7XG4gICAgcmVuZGVyVG9GcmFtZWJ1ZmZlcihncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpO1xufVxuZXhwb3J0cy5yZW5kZXJUb0NhbnZhcyA9IHJlbmRlclRvQ2FudmFzO1xuZnVuY3Rpb24gcmVuZGVyVG9GcmFtZWJ1ZmZlcihncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpIHtcbiAgICBncGdwdS5zZXRQcm9ncmFtKHJlbmRlclNoYWRlcik7XG4gICAgdmFyIHNvdXJjZVNhbXBsZXJMb2NhdGlvbiA9IHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZ3BncHUuZ2wsIHJlbmRlclNoYWRlciwgJ3NvdXJjZScpO1xuICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShzb3VyY2VUZXgsIHNvdXJjZVNhbXBsZXJMb2NhdGlvbiwgMCk7XG4gICAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbmV4cG9ydHMucmVuZGVyVG9GcmFtZWJ1ZmZlciA9IHJlbmRlclRvRnJhbWVidWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXJfbmRhcnJheV9ncHVfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXNpemVCaWxpbmVhclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyUHJvZ3JhbShpbnB1dFNoYXBlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW5wdXRTaGFwZVswXSwgb2xkSGVpZ2h0ID0gaW5wdXRTaGFwZVsxXSwgb2xkV2lkdGggPSBpbnB1dFNoYXBlWzJdLCBkZXB0aCA9IGlucHV0U2hhcGVbM107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUluU2l6ZSA9IGFsaWduQ29ybmVycyA/IFtvbGRIZWlnaHQgLSAxLCBvbGRXaWR0aCAtIDFdIDogW29sZEhlaWdodCwgb2xkV2lkdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtuZXdIZWlnaHQgLSAxLCBuZXdXaWR0aCAtIDFdIDogW25ld0hlaWdodCwgbmV3V2lkdGhdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVswXSAvIGVmZmVjdGl2ZU91dFNpemVbMF0gKyBcIixcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMV0gLyBlZmZlY3RpdmVPdXRTaXplWzFdICsgXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIiArIG9sZEhlaWdodCArIFwiLjAsIFwiICsgb2xkV2lkdGggKyBcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVzaXplQmlsaW5lYXJQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVzaXplQmlsaW5lYXJQcm9ncmFtID0gUmVzaXplQmlsaW5lYXJQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplX2JpbGluZWFyX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXZlcnNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZVByb2dyYW0oeFNoYXBlLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB2YXIgZ2V0UmV2VmFyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChheGlzLmluZGV4T2YoaSkgIT09IC0xICYmIHhTaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4U2hhcGVbaV0gKyBcIiAtIGNvb3Jkc1tcIiArIGkgKyBcIl0gLSAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJjb29yZHNbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiID0gZ2V0UmV2VmFyKDApO1xuICAgICAgICB2YXIgciA9IGdldFJldlZhcigxKTtcbiAgICAgICAgdmFyIGMgPSBnZXRSZXZWYXIoMik7XG4gICAgICAgIHZhciBkID0gZ2V0UmV2VmFyKDMpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhbCA9IGdldFgoXCIgKyBiICsgXCIsIFwiICsgciArIFwiLCBcIiArIGMgKyBcIiwgXCIgKyBkICsgXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJldmVyc2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmV2ZXJzZVByb2dyYW0gPSBSZXZlcnNlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldmVyc2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG5mdW5jdGlvbiBtYWtlU2hhZGVyKGlucHV0c0luZm8sIG91dHB1dFNoYXBlLCB1c2VyQ29kZSwgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHNhbXBsZVNuaXBwZXQgPSBnZXRTYW1wbGVTbmlwcGV0KCk7XG4gICAgdmFyIHNldE91dHB1dFNuaXBwZXQgPSBnZXRTZXRPdXRwdXRTbmlwcGV0KCk7XG4gICAgdmFyIGlucHV0UHJlZml4U25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBcInVuaWZvcm0gc2FtcGxlcjJEIFwiICsgeC5uYW1lICsgXCI7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIHZhciBpbnB1dFNhbXBsaW5nU25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldCh4LCBvdXRwdXRTaGFwZSwgYnJvYWRjYXN0KTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dFNoYXBlLnRleFNoYXBlO1xuICAgIHZhciBvdXRwdXRTYW1wbGluZ1NuaXBwZXQgPSBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgdmFyIHNvdXJjZSA9IFtcbiAgICAgICAgU0hBREVSX1BSRUZJWCwgc2FtcGxlU25pcHBldCwgc2V0T3V0cHV0U25pcHBldCwgaW5wdXRQcmVmaXhTbmlwcGV0LFxuICAgICAgICBvdXRwdXRTYW1wbGluZ1NuaXBwZXQsIGlucHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICAgIF0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlciA9IG1ha2VTaGFkZXI7XG5mdW5jdGlvbiBnZXRTYW1wbGVTbmlwcGV0KCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpID9cbiAgICAgICAgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA6XG4gICAgICAgIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVDtcbn1cbmZ1bmN0aW9uIGdldFNldE91dHB1dFNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZyb21JbkluZm8oaW5JbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5JbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXJTY2FsYXIoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIxRChpbkluZm8pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjJEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyM0QoaW5JbmZvKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXI0RChpbkluZm8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNoYXBlLmxlbmd0aCArIFwiLUQgaW5wdXQgc2FtcGxpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoaW5JbmZvLCBvdXRTaGFwZUluZm8sIGJyb2FkY2FzdCkge1xuICAgIHZhciByZXMgPSBnZXRTYW1wbGVyRmxhdChpbkluZm8pO1xuICAgIHJlcyArPSBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pO1xuICAgIGlmIChicm9hZGNhc3QgfHxcbiAgICAgICAgdXRpbC5hcnJheXNFcXVhbChpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSkpIHtcbiAgICAgICAgcmVzICs9IGdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbkluZm8sIG91dFNoYXBlSW5mbywgYnJvYWRjYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRTaGFwZSwgb3V0VGV4U2hhcGUpIHtcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQxRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0MkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDNEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQ0RENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG91dFNoYXBlLmxlbmd0aCArIFwiLUQgb3V0cHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbnZhciBTQU1QTEVfMURfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzJEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgbnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gcm93ICogbnVtQyArIGNvbDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8zRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGg7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfNERfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb200RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMikge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDI7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgdW5pZm9ybSBmbG9hdCBOYU47XFxuXFxuICBjb25zdCB2ZWM0IGZsb2F0RGVsdGFzID0gdmVjNChcXG4gICAgICAxLjAsXFxuICAgICAgMS4wIC8gMjU1LjAsXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjApLFxcbiAgICAgIDEuMCAvICgyNTUuMCAqIDI1NS4wICogMjU1LjApXFxuICApO1xcbiAgY29uc3QgZmxvYXQgbWluVmFsdWUgPSBcIiArIHRleF91dGlsLkZMT0FUX01JTiArIFwiLjA7XFxuICBjb25zdCBmbG9hdCBtYXhWYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUFYICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IHJhbmdlID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMjU1LjA7XFxuICBjb25zdCB2ZWMyIGRvdFJhbmdlID0gdmVjMigxLjAsIHJhbmdlKTtcXG5cXG4gIGZsb2F0IHNhbXBsZShzYW1wbGVyMkQgdGV4dHVyZSwgdmVjMiB1dikge1xcbiAgICB2ZWM0IHNhbXBsZVZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KTtcXG4gICAgaWYgKGFsbChlcXVhbChzYW1wbGVWYWx1ZSwgdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpKSkpIHtcXG4gICAgICByZXR1cm4gTmFOO1xcbiAgICB9XFxuXFxuICAgIHZlYzQgZW5jVmFsdWUgPSBmbG9vcihzYW1wbGVWYWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gICAgZmxvYXQgZGVjb2RlZFZhbHVlID0gZG90KGVuY1ZhbHVlLCBmbG9hdERlbHRhcyk7XFxuICAgIHJldHVybiBkb3QodmVjMihtaW5WYWx1ZSwgZGVjb2RlZFZhbHVlKSwgZG90UmFuZ2UpO1xcbiAgfVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICBjb25zdCB2ZWM0IGZsb2F0UG93ZXJzID0gdmVjNChcXG4gICAgMS4wLFxcbiAgICAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCAqIDI1NS4wXFxuICApO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlID0gdmVjMigxLjAvcmFuZ2UpO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlMjU1ID0gdmVjMigxLjAvKG1heFZhbHVlIC0gbWluVmFsdWUpKTtcXG5cXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IGRlY29kZWRWYWx1ZSkge1xcbiAgICBpZiAoaXNOYU4oZGVjb2RlZFZhbHVlKSkge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoXCIgKyB0ZXhfdXRpbC5CWVRFX05BTl9WQUxVRSArIFwiKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgYSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZSk7XFxuICAgIGZsb2F0IGIgPSBmcmFjdChhKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoYikgKiAyNTUuMDtcXG4gICAgZmxvYXQgZCA9IGZyYWN0KGMpICogMjU1LjA7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGZsb29yKHZlYzQoYSwgYiwgYywgZCkpIC8gMjU1LjA7XFxuXFxuICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBWZXJzaW9uIGFib3ZlIGdldHMgYmV0dGVyIGFjY3VyYWN5IGJ1dCBwcm9iYWJseSBzbG93ZXJcXG4gICAgLy8gdGhhbiB0aGUgdmVyc2lvbiBiZWxvdy4gQmVuY2htYXJrIHRvIGRldGVybWluZSBpZiB0aGUgYWNjdXJhY3kgaXMgd29ydGhcXG4gICAgLy8gdGhlIGNvc3QuXFxuXFxuICAgIC8vIGZsb2F0IG5vcm1WYWx1ZSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZTI1NSk7XFxuICAgIC8vIHZlYzQgZiA9IG5vcm1WYWx1ZSAqIGZsb2F0UG93ZXJzO1xcbiAgICAvLyBnbF9GcmFnQ29sb3IgPSBmbG9vcihmcmFjdChmKSAqIDI1NS4wKSAvIDI1NS4wO1xcbiAgfVxcblwiO1xudmFyIEZMT0FUX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgZmxvYXQgc2FtcGxlKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2KSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLnI7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgfVxcblwiO1xudmFyIFNIQURFUl9QUkVGSVggPSBcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG4gIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xcbiAgICBmbG9hdCB2MSA9IHZhbCAqIHZhbDtcXG4gICAgZmxvYXQgdjIgPSB2YWwgKiB2YWw7XFxuICAgIHJldHVybiB2MSA9PSB2MiA/IGZhbHNlIDogdHJ1ZTtcXG4gIH1cXG5cXG4gIGJvb2wgaGFzTmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHZlYzQgdjEgPSB2YWx1ZXMgKiB2YWx1ZXM7XFxuICAgIHZlYzQgdjIgPSB2YWx1ZXMgKiB2YWx1ZXM7XFxuICAgIHJldHVybiBhbnkobm90RXF1YWwodjEsIHYyKSk7XFxuICB9XFxuXFxuICBmbG9hdCBnZXROYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGRvdCh2ZWM0KDEpLCB2YWx1ZXMpO1xcbiAgfVxcblxcbiAgaW50IHJvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gIH1cXG5cXG4gIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgfVxcblxcbiAgY29uc3QgdmVjMiByYW5kb21Db25zdCA9IHZlYzIoXFxuICAgIDIzLjE0MDY5MjYzMjc3OTI2LCAvLyBlXnBpIChHZWxmb25kJ3MgY29uc3RhbnQpXFxuICAgICAyLjY2NTE0NDE0MjY5MDIyNSAvLyAyXnNxcnQoMikgKEdlbGZvbmRcXHUyMDEzU2NobmVpZGVyIGNvbnN0YW50KVxcbiAgKTtcXG5cXG4gIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKSB7XFxuICAgICAgcmV0dXJuIGZyYWN0KGNvcyhkb3QocmVzdWx0VVYgKiBzZWVkLCByYW5kb21Db25zdCkpICogMTIzNDUuNjc4OSk7XFxuICB9XFxuXFxuICBcIiArIFNBTVBMRV8xRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzJEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfM0RfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV80RF9TTklQUEVUICsgXCJcXG5cIjtcbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxhckNvb3JkcygpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiICsgdGV4U2hhcGVbMF0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0M0RDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbnQgZCA9IGluZGV4IC0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQ0RENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG5cXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW5kZXggLT0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcblxcbiAgICAgIGludCBkID0gaW5kZXggLyBcIiArIHN0cmlkZTIgKyBcIjtcXG4gICAgICBpbnQgZDIgPSBpbmRleCAtIGQgKiBcIiArIHN0cmlkZTIgKyBcIjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDJEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVswXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlclNjYWxhcihpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIxRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiRmxhdChpbmRleCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjJEKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRleE51bUMgKyBcIi4wLCAwLjUpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgdmVjMiB1diA9IFVWZnJvbTJEKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzaGFwZVsxXSArIFwiLCByb3csIGNvbCk7XFxuICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gIH1cXG5cIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIzRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIHZhciBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgaW50IHRleFIgPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgaW50IHRleEMgPSBkZXB0aDtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gVVZmcm9tM0QoXFxuICAgICAgICAgICAgXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsIHJvdywgY29sLCBkZXB0aCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNEQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoICogXCIgKyBzdHJpZGUyICsgXCIgKyBkZXB0aDI7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMikge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKiBzaGFwZVsyXSArIFwiICsgY29sICogXCIgKyBzaGFwZVsyXSArIFwiICsgZGVwdGg7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMjtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tNEQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsXFxuICAgICAgICAgIFwiICsgc3RyaWRlMiArIFwiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMik7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGbGF0KGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpICsgJ0ZsYXQnO1xuICAgIHZhciB0TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh0TnVtQyA9PT0gMSAmJiB0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdE51bUMgKyBcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTFEKFwiICsgdE51bVIgKyBcIiwgXCIgKyB0TnVtQyArIFwiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHRleEZ1bmNTbmlwcGV0LCBmdW5jTmFtZSkge1xuICAgIHZhciBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdHlwZSA9ICdpbnQnO1xuICAgIGlmIChvdXRSYW5rID09PSAyKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSAzKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSA0KSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzQnO1xuICAgIH1cbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgdmFyIGNvb3Jkc1NuaXBwZXQ7XG4gICAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICdjb29yZHMgPSAwOyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID1cbiAgICAgICAgICAgIGJyb2FkY2FzdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChkICsgcmFua0RpZmYpICsgXCJdID0gMDtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHZhciB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChpICsgcmFua0RpZmYpICsgXCJdXCI7IH0pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIiArIGNvb3Jkc1NuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBnZXRcIiArIHRleEZ1bmNTbmlwcGV0ICsgXCIoXCIgKyB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgKyBcIik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCBzdXBwb3J0c0Jyb2FkY2FzdGluZykge1xuICAgIHZhciBpblRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciB0ZXhGdW5jU25pcHBldCA9IHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4RnVuY1NuaXBwZXQgKyAnQXRPdXRDb29yZHMnO1xuICAgIHZhciBicm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBkb0Jyb2FkY2FzdCA9IHN1cHBvcnRzQnJvYWRjYXN0aW5nICYmICgob3V0UmFuayA+IGluUmFuaykgfHwgYnJvYWRjYXN0RGltcy5sZW5ndGggPiAwKTtcbiAgICB2YXIgYnJvYWRjYXN0T3Zlck91dGVyID0gYnJvYWRjYXN0X3V0aWwuYnJvYWRjYXN0RGltc0FyZU91dGVyKGJyb2FkY2FzdERpbXMpO1xuICAgIGlmIChkb0Jyb2FkY2FzdCAmJiAhYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCB0ZXhGdW5jU25pcHBldCwgZnVuY05hbWUpO1xuICAgIH1cbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRTaGFwZUluZm8udGV4U2hhcGU7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGluVGV4U2hhcGUpO1xuICAgIHZhciBicm9hZGNhc3RTbmlwcGV0ID0gJyc7XG4gICAgaWYgKGRvQnJvYWRjYXN0ICYmIGJyb2FkY2FzdE92ZXJPdXRlcikge1xuICAgICAgICBicm9hZGNhc3RTbmlwcGV0ID0gXCJcXG4gICAgICAgIGludCBtYWluUGFydCA9IGluZGV4IC8gXCIgKyBpblNpemUgKyBcIjtcXG4gICAgICAgIGluZGV4IC09IG1haW5QYXJ0ICogXCIgKyBpblNpemUgKyBcIjtcXG4gICAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyBvdXRUZXhTaGFwZVswXSArIFwiLCBcIiArIG91dFRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyBvdXRUZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIiArIGJyb2FkY2FzdFNuaXBwZXQgKyBcIlxcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIiArIGluVGV4U2hhcGVbMV0gKyBcIjtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIFwiICsgaW5UZXhTaGFwZVsxXSArIFwiO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgdmVjMihcIiArIGluVGV4U2hhcGVbMV0gKyBcIi4wLCBcIiArIGluVGV4U2hhcGVbMF0gKyBcIi4wKTtcXG5cXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0Q29vcmRzRGF0YVR5cGUocmFuaykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ2l2ZWMyJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2l2ZWMzJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ2l2ZWM0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiR1BVIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZTtcbmZ1bmN0aW9uIHNxdWVlemVJbnB1dEluZm8oaW5JbmZvLCBzcXVlZXplZFNoYXBlKSB7XG4gICAgdmFyIG5ld0lucHV0SW5mbyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5JbmZvKSk7XG4gICAgbmV3SW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUgPSBzcXVlZXplZFNoYXBlO1xuICAgIHJldHVybiBuZXdJbnB1dEluZm87XG59XG5mdW5jdGlvbiBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSB7XG4gICAgcmV0dXJuIGtlcHREaW1zLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyYW1zW2RdOyB9KS5qb2luKCcsICcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyX2NvbXBpbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFNsaWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VQcm9ncmFtKGRlc3RTaXplKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBkZXN0U2l6ZTtcbiAgICAgICAgdGhpcy5yYW5rID0gZGVzdFNpemUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMucmFuayk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gXCIgKyBkdHlwZSArIFwiIHN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2MgPSBzdGFydCArIGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgU2xpY2VQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gdGhpcy5yYW5rKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIiArIHRoaXMucmFuayArIFwiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHN0YXJ0IChcIiArIHN0YXJ0Lmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtM2koX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm00aShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSwgc3RhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgX3RoaXMucmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlNsaWNlUHJvZ3JhbSA9IFNsaWNlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnonO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueiwgc291cmNlTG9jLncnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZXh0dXJlVHlwZTtcbihmdW5jdGlvbiAoVGV4dHVyZVR5cGUpIHtcbiAgICBUZXh0dXJlVHlwZVtUZXh0dXJlVHlwZVtcIkZMT0FUXCJdID0gMF0gPSBcIkZMT0FUXCI7XG4gICAgVGV4dHVyZVR5cGVbVGV4dHVyZVR5cGVbXCJVTlNJR05FRF9CWVRFXCJdID0gMV0gPSBcIlVOU0lHTkVEX0JZVEVcIjtcbn0pKFRleHR1cmVUeXBlID0gZXhwb3J0cy5UZXh0dXJlVHlwZSB8fCAoZXhwb3J0cy5UZXh0dXJlVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMsIHJvd3NdO1xufVxuZXhwb3J0cy5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4U2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgcmV0dXJuIG1hdHJpeFNpemUgKiBjaGFubmVsc1BlclRleHR1cmU7XG59XG5leHBvcnRzLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUgPSBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplO1xuZnVuY3Rpb24gZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtjb2x1bW5zICogNCwgcm93c107XG59XG5leHBvcnRzLmdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSh1bnBhY2tlZFNpemUsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIGlmICh1bnBhY2tlZFNpemUgJSBjaGFubmVsc1BlclRleHR1cmUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRTaXplIChcIiArIHVucGFja2VkU2l6ZSArIFwiKSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVucGFja2VkU2l6ZSAvIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSA9IGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemU7XG5mdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobWF0cml4LCB1bnBhY2tlZEFycmF5LCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXgubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIGlmICh1bnBhY2tlZEFycmF5Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZEFycmF5IGxlbmd0aCAoXCIgKyB1bnBhY2tlZEFycmF5Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICtcbiAgICAgICAgICAgIChcIlwiICsgcmVxdWlyZWRTaXplKSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IG1hdHJpeC5sZW5ndGg7ICsrc3JjKSB7XG4gICAgICAgIHVucGFja2VkQXJyYXlbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICBkc3QgKz0gY2hhbm5lbHNQZXJUZXh0dXJlO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5ID0gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5O1xuZXhwb3J0cy5GTE9BVF9NQVggPSAyMDAwMDtcbmV4cG9ydHMuRkxPQVRfTUlOID0gLWV4cG9ydHMuRkxPQVRfTUFYO1xudmFyIEZMT0FUX1JBTkdFID0gKGV4cG9ydHMuRkxPQVRfTUFYIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gMjU1O1xudmFyIEZMT0FUX0RFTFRBUyA9IFsxLCAxIC8gMjU1LCAxIC8gKDI1NSAqIDI1NSksIDEgLyAoMjU1ICogMjU1ICogMjU1KV07XG52YXIgRkxPQVRfUE9XRVJTID0gWzEsIDI1NSwgMjU1ICogMjU1XTtcbmV4cG9ydHMuQllURV9OQU5fVkFMVUUgPSAwO1xuZnVuY3Rpb24gZW5jb2RlRmxvYXRBcnJheShmbG9hdEFycmF5KSB7XG4gICAgdmFyIHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGZsb2F0QXJyYXkubGVuZ3RoICogNCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBmbG9hdEFycmF5W2kgLyA0XTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdWludEFycmF5W2ldID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9ICh2YWx1ZSAtIGV4cG9ydHMuRkxPQVRfTUlOKSAvIEZMT0FUX1JBTkdFO1xuICAgICAgICB2YXIgZW5jID0gRkxPQVRfUE9XRVJTLm1hcChmdW5jdGlvbiAocG93KSB7IHJldHVybiBwb3cgKiBub3JtYWxpemVkVmFsdWU7IH0pO1xuICAgICAgICB2YXIgYnVja2V0cyA9IGVuYy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBNYXRoLmZsb29yKCh2YWx1ZSAlIDEpICogMjU1KTsgfSk7XG4gICAgICAgIHVpbnRBcnJheVtpXSA9IE1hdGguZmxvb3Iobm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGJ1Y2tldHNbMF07XG4gICAgICAgIHVpbnRBcnJheVtpICsgMl0gPSBidWNrZXRzWzFdO1xuICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gYnVja2V0c1syXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiB1aW50QXJyYXk7XG59XG5leHBvcnRzLmVuY29kZUZsb2F0QXJyYXkgPSBlbmNvZGVGbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlVG9GbG9hdEFycmF5KHVpbnRBcnJheSkge1xuICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh1aW50QXJyYXkubGVuZ3RoIC8gNCk7XG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAodWludEFycmF5W2ldID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDFdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFKSB7XG4gICAgICAgICAgICBmbG9hdEFycmF5W2kgLyA0XSA9IE5hTjtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvdCA9IDA7XG4gICAgICAgIEZMT0FUX0RFTFRBUy5mb3JFYWNoKGZ1bmN0aW9uIChkZWx0YSwgaikge1xuICAgICAgICAgICAgZG90ICs9IGRlbHRhICogdWludEFycmF5W2kgKyBqXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRvdCAqIEZMT0FUX1JBTkdFICsgZXhwb3J0cy5GTE9BVF9NSU47XG4gICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gdmFsdWU7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnRBcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBfbG9vcF8yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxvYXRBcnJheTtcbn1cbmV4cG9ydHMuZGVjb2RlVG9GbG9hdEFycmF5ID0gZGVjb2RlVG9GbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkodW5wYWNrZWRBcnJheSwgbWF0cml4LCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSh1bnBhY2tlZEFycmF5Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IHVucGFja2VkQXJyYXkubGVuZ3RoOyBzcmMgKz0gY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgICAgIG1hdHJpeFtkc3QrK10gPSB1bnBhY2tlZEFycmF5W3NyY107XG4gICAgfVxufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheSA9IGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkodW5wYWNrZWRBcnJheSwgbWF0cml4LCBjaGFubmVscykge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSB1bnBhY2tlZEFycmF5Lmxlbmd0aCAqIGNoYW5uZWxzIC8gNDtcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IHVucGFja2VkQXJyYXkubGVuZ3RoOyBzcmMgKz0gNCkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSB1bnBhY2tlZEFycmF5W3NyYyArIGNdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheSA9IGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5O1xuZnVuY3Rpb24gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSwgTWF0aC5jZWlsKHJvd3MgLyAyKV07XG59XG5leHBvcnRzLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgcmV0dXJuIHcgKiBoICogNDtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZSA9IGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGU7XG5mdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEobWF0cml4LCByb3dzLCBjb2x1bW5zLCBwYWNrZWRSR0JBKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucyk7XG4gICAgaWYgKHBhY2tlZFJHQkEubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhY2tlZFJHQkEgbGVuZ3RoIChcIiArIHBhY2tlZFJHQkEubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdGV4dHVyZVdpZHRoID0gX2FbMF0sIHRleHR1cmVIZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICAgIHZhciBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICAgIHZhciB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICAgIHZhciBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgICB7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSAob2RkV2lkdGggPyA0IDogMCk7XG4gICAgICAgIHZhciBvbmVSb3cgPSBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeFNyY1JvdyA9IChibG9ja1kgKiAyICogY29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0cml4U3JjQ29sID0gYmxvY2tYICogMjtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gbWF0cml4U3JjUm93ICsgbWF0cml4U3JjQ29sO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMV0gPSBtYXRyaXhbc3JjICsgMV07XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3ddO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgM10gPSBtYXRyaXhbc3JjICsgb25lUm93ICsgMV07XG4gICAgICAgICAgICAgICAgZHN0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCkge1xuICAgICAgICB2YXIgc3JjID0gY29sdW1ucyAtIDE7XG4gICAgICAgIHZhciBkc3QgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gMiAqIGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMl0gPSBtYXRyaXhbc3JjICsgY29sdW1uc107XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzcmMgPSAocm93cyAtIDEpICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgICAgICAgIGRzdCArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICAgICAgcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdID0gbWF0cml4W21hdHJpeC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tlZFJHQkE7XG59XG5leHBvcnRzLmVuY29kZU1hdHJpeFRvUGFja2VkUkdCQSA9IGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSByb3dzICogY29sdW1ucztcbiAgICBpZiAocmVxdWlyZWRTaXplIDwgbWF0cml4Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IG9kZFdpZHRoID8gNCA6IDA7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSBjb2x1bW5zICsgKG9kZFdpZHRoID8gMSA6IDApO1xuICAgICAgICB2YXIgc3JjID0gMDtcbiAgICAgICAgdmFyIGRzdFJvdzEgPSAwO1xuICAgICAgICB2YXIgZHN0Um93MiA9IGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzErK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0Um93MSArPSBkc3RTdHJpZGU7XG4gICAgICAgICAgICBkc3RSb3cyICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGgpIHtcbiAgICAgICAgdmFyIHNyYyA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBkc3QgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgbWF0cml4W2RzdF0gPSBwYWNrZWRSR0JBW3NyY107XG4gICAgICAgICAgICBtYXRyaXhbZHN0ICsgY29sdW1uc10gPSBwYWNrZWRSR0JBW3NyYyArIDJdO1xuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZEhlaWdodCkge1xuICAgICAgICB2YXIgc3JjID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIHZhciBkc3QgPSAocm93cyAtIDEpICogY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICBzcmMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGggJiYgb2RkSGVpZ2h0KSB7XG4gICAgICAgIG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV0gPSBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF07XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBID0gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXhfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZXhfdXRpbF8xID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgVGV4dHVyZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKGdwZ3B1KSB7XG4gICAgICAgIHRoaXMuZ3BncHUgPSBncGdwdTtcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzID0ge307XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFRleHR1cmVzID0gW107XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudCA9IHt9O1xuICAgIH1cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmUgPSBmdW5jdGlvbiAoc2hhcGVSQywgdGV4VHlwZSkge1xuICAgICAgICBpZiAodGV4VHlwZSA9PT0gdm9pZCAwKSB7IHRleFR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkZMT0FUOyB9XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSQywgdGV4VHlwZSk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy51c2VkVGV4dHVyZUNvdW50KSkge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSsrO1xuICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzLS07XG4gICAgICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICAgICAgdGhpcy5sb2coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICB2YXIgbmV3VGV4dHVyZSA9IHRoaXMuZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShzaGFwZVJDWzBdLCBzaGFwZVJDWzFdKTtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRUZXh0dXJlcy5wdXNoKG5ld1RleHR1cmUpO1xuICAgICAgICByZXR1cm4gbmV3VGV4dHVyZTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzaGFwZSwgdGV4VHlwZSkge1xuICAgICAgICBpZiAodGV4VHlwZSA9PT0gdm9pZCAwKSB7IHRleFR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkZMT0FUOyB9XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGUsIHRleFR5cGUpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKHRleHR1cmUpO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcy0tO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldLS07XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMubnVtRnJlZVRleHR1cmVzICsgdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmVlL1VzZWQnLCB0aGlzLm51bUZyZWVUZXh0dXJlcyArIFwiIC8gXCIgKyB0aGlzLm51bVVzZWRUZXh0dXJlcywgXCIoXCIgKyB0b3RhbCArIFwiKVwiKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5hbGxvY2F0ZWRUZXh0dXJlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRUZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcyA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dHVyZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5UZXh0dXJlTWFuYWdlciA9IFRleHR1cmVNYW5hZ2VyO1xuZnVuY3Rpb24gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJvd3NDb2wsIHRleFR5cGUpIHtcbiAgICByZXR1cm4gc2hhcGVSb3dzQ29sWzBdICsgXCJfXCIgKyBzaGFwZVJvd3NDb2xbMV0gKyBcIl9cIiArIHRleFR5cGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlX21hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVGlsZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQcm9ncmFtKGFTaGFwZSwgcmVwcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMoYVNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVGlsZVByb2dyYW0gPSBUaWxlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhhU2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiaW1vZChyZXNSQywgXCIgKyBhU2hhcGVbMF0gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDb29yZHMgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICB2YXIgc291cmNlQ29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJpbW9kKFwiICsgY3VycmVudENvb3Jkc1tpXSArIFwiLCBcIiArIGFTaGFwZVtpXSArIFwiKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUNvb3Jkcy5qb2luKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBUcmFuc3Bvc2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3Bvc2VQcm9ncmFtKGFTaGFwZSwgbmV3RGltKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2ldID0gYVNoYXBlW25ld0RpbVtpXV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzd2l0Y2hlZCA9IGdldFN3aXRjaGVkQ29vcmRzKG5ld0RpbSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzd2l0Y2hlZCArIFwiKSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3Bvc2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNwb3NlUHJvZ3JhbSA9IFRyYW5zcG9zZVByb2dyYW07XG5mdW5jdGlvbiBnZXRTd2l0Y2hlZENvb3JkcyhuZXdEaW0pIHtcbiAgICB2YXIgcmFuayA9IG5ld0RpbS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVHJhbnNwb3NlIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWxPcmRlciA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzd2l0Y2hlZENvb3JkcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RpbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2hlZENvb3Jkc1tuZXdEaW1baV1dID0gb3JpZ2luYWxPcmRlcltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXRjaGVkQ29vcmRzLmpvaW4oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVW5hcnlPcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuYXJ5T3BQcm9ncmFtKGFTaGFwZSwgb3BTbmlwcGV0KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIiArIG9wU25pcHBldCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlPcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5VbmFyeU9wUHJvZ3JhbSA9IFVuYXJ5T3BQcm9ncmFtO1xudmFyIENIRUNLX05BTl9TTklQUEVUID0gXCJcXG4gIGlmIChpc05hTih4KSkgcmV0dXJuIHg7XFxuXCI7XG5leHBvcnRzLkFCUyA9IFwiXFxuICByZXR1cm4gYWJzKHgpO1xcblwiO1xuZXhwb3J0cy5SRUxVID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCI7XG5leHBvcnRzLkVMVSA9IFwiXFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcXG5cIjtcbmV4cG9ydHMuRUxVX0RFUiA9IFwiXFxuICByZXR1cm4gKHggPj0gMC4wKSA/IDEuMCA6IGV4cCh4KTtcXG5cIjtcbmV4cG9ydHMuU0VMVSA9IFwiXFxuICAvLyBTdGFibGUgYW5kIEF0dHJhY3RpbmcgRml4ZWQgUG9pbnQgKDAsIDEpIGZvciBOb3JtYWxpemVkIFdlaWdodHMuXFxuICAvLyBzZWU6IGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA2LjAyNTE1XFxuICBmbG9hdCBzY2FsZUFscGhhID0gMS43NTgwOTkzNDA4NDczNzY4NTk5NDAyMTc1MjA4MTIzO1xcbiAgZmxvYXQgc2NhbGUgPSAxLjA1MDcwMDk4NzM1NTQ4MDQ5MzQxOTMzNDk4NTI5NDY7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjtcbmZ1bmN0aW9uIExFQUtZX1JFTFUoYWxwaGEpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgcmV0dXJuICh4ID49IDAuMCkgPyB4IDogXCIgKyBhbHBoYSArIFwiICogeDtcXG4gIFwiO1xufVxuZXhwb3J0cy5MRUFLWV9SRUxVID0gTEVBS1lfUkVMVTtcbmZ1bmN0aW9uIFNURVAoYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgIHJldHVybiBDSEVDS19OQU5fU05JUFBFVCArIChcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiICsgYWxwaGEgKyBcIik7XFxuICBcIik7XG59XG5leHBvcnRzLlNURVAgPSBTVEVQO1xuZXhwb3J0cy5ORUcgPSBcIlxcbiAgcmV0dXJuIC14O1xcblwiO1xuZXhwb3J0cy5DRUlMID0gXCJcXG4gIHJldHVybiBjZWlsKHgpO1xcblwiO1xuZXhwb3J0cy5GTE9PUiA9IFwiXFxuICByZXR1cm4gZmxvb3IoeCk7XFxuXCI7XG5leHBvcnRzLkVYUCA9IFwiXFxuICByZXR1cm4gZXhwKHgpO1xcblwiO1xuZXhwb3J0cy5MT0cgPSBcIlxcbiAgcmV0dXJuIGxvZyh4KTtcXG5cIjtcbmV4cG9ydHMuU1FSVCA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBzcXJ0KHgpO1xcblwiO1xuZXhwb3J0cy5TSUdNT0lEID0gXCJcXG4gIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XFxuXCI7XG5leHBvcnRzLlNJTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCI7XG5leHBvcnRzLkNPUyA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBjb3MoeCk7XFxuXCI7XG5leHBvcnRzLlRBTiA9IFwiXFxuICByZXR1cm4gdGFuKHgpO1xcblwiO1xuZXhwb3J0cy5BU0lOID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGFzaW4oeCk7XFxuXCI7XG5leHBvcnRzLkFDT1MgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYWNvcyh4KTtcXG5cIjtcbmV4cG9ydHMuQVRBTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiO1xuZXhwb3J0cy5TSU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuQ09TSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xuZXhwb3J0cy5UQU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIjtcbmV4cG9ydHMuU1FVQVJFID0gXCJcXG4gIHJldHVybiB4ICogeDtcXG5cIjtcbmV4cG9ydHMuVE9fSU5UID0gXCJcXG4gIHJldHVybiBmbG9hdChpbnQoeCkpO1xcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5hcnlvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTUFYX1RFWFRVUkVfU0laRSA9IG51bGw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZW52aXJvbm1lbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcykge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGdsO1xuICAgIHZhciB3ZWJnbFZlcnNpb24gPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJnbFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDAgfHwgZ2wgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLicpO1xuICAgIH1cbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzO1xuZnVuY3Rpb24gY2FsbEFuZENoZWNrKGdsLCBmdW5jKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZnVuYygpO1xuICAgIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZXhwb3J0cy5jYWxsQW5kQ2hlY2sgPSBjYWxsQW5kQ2hlY2s7XG52YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKSB7XG4gICAgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZW5hYmxlZDtcbn1cbmV4cG9ydHMuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcgPSBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZztcbmZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihnbCkge1xuICAgIGlmICh3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBFcnJvcjogJyArIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1dlYkdMRXJyb3IgPSBjaGVja1dlYkdMRXJyb3I7XG5mdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5OT19FUlJPUjpcbiAgICAgICAgICAgIHJldHVybiAnTk9fRVJST1InO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9FTlVNJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX1ZBTFVFJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICAgIHJldHVybiAnT1VUX09GX01FTU9SWSc7XG4gICAgICAgIGNhc2UgZ2wuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgICAgcmV0dXJuICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVW5rbm93biBlcnJvciBjb2RlIFwiICsgc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0V2ViR0xFcnJvck1lc3NhZ2UgPSBnZXRXZWJHTEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbk9yVGhyb3coZ2wsIGV4dGVuc2lvbk5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTsgfSwgJ0V4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpO1xufVxuZXhwb3J0cy5nZXRFeHRlbnNpb25PclRocm93ID0gZ2V0RXh0ZW5zaW9uT3JUaHJvdztcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKGZyYWdtZW50U2hhZGVyU291cmNlLCBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXI7XG52YXIgbGluZU51bWJlclJlZ2V4ID0gL0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7XG5mdW5jdGlvbiBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKHNoYWRlclNvdXJjZSwgc2hhZGVySW5mb0xvZykge1xuICAgIHZhciBsaW5lTnVtYmVyUmVnZXhSZXN1bHQgPSBsaW5lTnVtYmVyUmVnZXguZXhlYyhzaGFkZXJJbmZvTG9nKTtcbiAgICBpZiAobGluZU51bWJlclJlZ2V4UmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIgKyBzaGFkZXJJbmZvTG9nKTtcbiAgICAgICAgY29uc29sZS5sb2coc2hhZGVyU291cmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGluZU51bWJlciA9ICtsaW5lTnVtYmVyUmVnZXhSZXN1bHRbMV07XG4gICAgdmFyIHNoYWRlckxpbmVzID0gc2hhZGVyU291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgcGFkID0gc2hhZGVyTGluZXMubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoICsgMjtcbiAgICB2YXIgbGluZXNXaXRoTGluZU51bWJlcnMgPSBzaGFkZXJMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwucmlnaHRQYWQoKGxpbmVOdW1iZXIgKyAxKS50b1N0cmluZygpLCBwYWQpICsgbGluZTtcbiAgICB9KTtcbiAgICB2YXIgbWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc1dpdGhMaW5lTnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZXNXaXRoTGluZU51bWJlcnNbaV0ubGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGJlZm9yZUVycm9yTGluZXMgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZSgwLCBsaW5lTnVtYmVyIC0gMSk7XG4gICAgdmFyIGVycm9yTGluZSA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIgLSAxLCBsaW5lTnVtYmVyKTtcbiAgICB2YXIgYWZ0ZXJFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UobGluZU51bWJlcik7XG4gICAgY29uc29sZS5sb2coYmVmb3JlRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgY29uc29sZS5sb2coc2hhZGVySW5mb0xvZy5zcGxpdCgnXFxuJylbMF0pO1xuICAgIGNvbnNvbGUubG9nKFwiJWMgXCIgKyB1dGlsLnJpZ2h0UGFkKGVycm9yTGluZVswXSwgbWF4TGluZUxlbmd0aCksICdib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3Jyk7XG4gICAgY29uc29sZS5sb2coYWZ0ZXJFcnJvckxpbmVzLmpvaW4oJ1xcbicpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVByb2dyYW0oKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLicpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gY3JlYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMubGlua1Byb2dyYW0gPSBsaW5rUHJvZ3JhbTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmFsaWRhdGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb2dyYW0gPSB2YWxpZGF0ZVByb2dyYW07XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyID0gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyID0gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXI7XG5mdW5jdGlvbiBxdWVyeU1heFRleHR1cmVTaXplKGdsKSB7XG4gICAgaWYgKE1BWF9URVhUVVJFX1NJWkUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbiAgICB9XG4gICAgTUFYX1RFWFRVUkVfU0laRSA9XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpOyB9KTtcbiAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbn1cbmV4cG9ydHMucXVlcnlNYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemU7XG5mdW5jdGlvbiBnZXRDaGFubmVsc1BlclRleHR1cmUoKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiA0O1xufVxuZXhwb3J0cy5nZXRDaGFubmVsc1BlclRleHR1cmUgPSBnZXRDaGFubmVsc1BlclRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVUZXh0dXJlKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG5mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIG1heFRleHR1cmVTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gICAgaWYgKCh3aWR0aCA8PSAwKSB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWQgPSBcIltcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgfVxuICAgIGlmICgod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSkgfHwgKGhlaWdodCA+IG1heFRleHR1cmVTaXplKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHZhciBtYXggPSBcIltcIiArIG1heFRleHR1cmVTaXplICsgXCJ4XCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB0ZXh0dXJlIHNpemUgJyArIHJlcXVlc3RlZCArXG4gICAgICAgICAgICAnIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSAnICsgbWF4ICsgJy4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVGV4dHVyZVNpemUgPSB2YWxpZGF0ZVRleHR1cmVTaXplO1xuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuJyk7XG59XG5leHBvcnRzLmNyZWF0ZUZyYW1lYnVmZmVyID0gY3JlYXRlRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGUsIGJ1ZmZlciwgYXJyYXlFbnRyaWVzUGVySXRlbSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzLCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgbG9jID0gLTE7XG4gICAgaWYgKChhdHRyaWJMb2NhdGlvbnMgIT0gbnVsbCkgJiYgKGF0dHJpYnV0ZSBpbiBhdHRyaWJMb2NhdGlvbnMpKSB7XG4gICAgICAgIGxvYyA9IGF0dHJpYkxvY2F0aW9uc1thdHRyaWJ1dGVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICB9XG4gICAgaWYgKGxvYyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCBhcnJheUVudHJpZXNQZXJJdGVtLCBnbC5GTE9BVCwgZmFsc2UsIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcyk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKTsgfSk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUgPSBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlO1xuZnVuY3Rpb24gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVVuaXQgPSBiaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiB1bmJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kVGV4dHVyZVVuaXQgPSB1bmJpbmRUZXh0dXJlVW5pdDtcbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTsgfSwgJ3VuaWZvcm0gXCInICsgdW5pZm9ybU5hbWUgKyAnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3cgPSBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdztcbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24oZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG59XG5leHBvcnRzLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24gPSBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uO1xuZnVuY3Rpb24gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcihnbCwgcHJvZ3JhbSwgdGV4dHVyZSwgdW5pZm9ybVNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnVuaWZvcm0xaSh1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyID0gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcjtcbmZ1bmN0aW9uIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdsKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbn1cbmV4cG9ydHMuYmluZENhbnZhc1RvRnJhbWVidWZmZXIgPSBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKGdsLCB0ZXh0dXJlLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgfSk7XG59XG5leHBvcnRzLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyID0gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIoZ2wsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIG51bGwsIDApOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyID0gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCkge1xuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICBpZiAoc3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6ICcgKyBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUZyYW1lYnVmZmVyID0gdmFsaWRhdGVGcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93biBlcnJvciBcIiArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlID0gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmTnVsbChnbCwgcmV0dXJuVE9yTnVsbCwgZmFpbHVyZU1lc3NhZ2UpIHtcbiAgICB2YXIgdE9yTnVsbCA9IGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVE9yTnVsbCgpOyB9KTtcbiAgICBpZiAodE9yTnVsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0T3JOdWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVVuaXQgPSBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyAtIDE7XG4gICAgdmFyIGdsVGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdCArIGdsLlRFWFRVUkUwO1xuICAgIGlmIChnbFRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgZ2xUZXh0dXJlVW5pdCA+IG1heFRleHR1cmVVbml0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdFJhbmdlID0gXCJbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkVcIiArIG1heFRleHR1cmVVbml0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIgKyB0ZXh0dXJlVW5pdFJhbmdlICsgXCIuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoZ2wsIGxvZ1NoYXBlKSB7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB2YXIgc3F1ZWV6ZVJlc3VsdCA9IHV0aWwuc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgICAgbG9nU2hhcGUgPSBzcXVlZXplUmVzdWx0Lm5ld1NoYXBlO1xuICAgIH1cbiAgICB2YXIgbWF4VGV4U2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGxvZ1NoYXBlKTtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoIDw9IDEgJiYgc2l6ZSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbc2l6ZSwgMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGxvZ1NoYXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSA9IGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJnbF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5iYXRjaE5vcm1hbGl6YXRpb24yRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMiB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDIgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMiB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDIgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0JhdGNoTm9ybTJEJywge1xuICAgICAgICAgICAgaW5wdXRzOiB7IHg6IHgsIG1lYW46IG1lYW4sIHZhcmlhbmNlOiB2YXJpYW5jZSwgc2NhbGU6IHNjYWxlLCBvZmZzZXQ6IG9mZnNldCB9LFxuICAgICAgICAgICAgYXJnczogeyB2YXJpYW5jZUVwc2lsb246IHZhcmlhbmNlRXBzaWxvbiB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3BzLmJhdGNoTm9ybWFsaXphdGlvbjNEID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PT0gdm9pZCAwKSB7IHZhcmlhbmNlRXBzaWxvbiA9IC4wMDE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWVhbi5yYW5rID09PSAzIHx8IG1lYW4ucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgbWVhbi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFyaWFuY2UucmFuayA9PT0gMyB8fCB2YXJpYW5jZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgdmFyaWFuY2UucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChzY2FsZS5yYW5rID09PSAzIHx8IHNjYWxlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgc2NhbGUucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChvZmZzZXQucmFuayA9PT0gMyB8fCBvZmZzZXQucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgb2Zmc2V0LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQmF0Y2hOb3JtM0QnLCB7XG4gICAgICAgICAgICBpbnB1dHM6IHsgeDogeCwgbWVhbjogbWVhbiwgdmFyaWFuY2U6IHZhcmlhbmNlLCBzY2FsZTogc2NhbGUsIG9mZnNldDogb2Zmc2V0IH0sXG4gICAgICAgICAgICBhcmdzOiB7IHZhcmlhbmNlRXBzaWxvbjogdmFyaWFuY2VFcHNpbG9uIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMuYmF0Y2hOb3JtYWxpemF0aW9uNEQgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDQgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSA0IHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDQgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSA0IHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdCYXRjaE5vcm00RCcsIHtcbiAgICAgICAgICAgIGlucHV0czogeyB4OiB4LCBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UsIHNjYWxlOiBzY2FsZSwgb2Zmc2V0OiBvZmZzZXQgfSxcbiAgICAgICAgICAgIGFyZ3M6IHsgdmFyaWFuY2VFcHNpbG9uOiB2YXJpYW5jZUVwc2lsb24gfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICBpZiAoeC5yYW5rID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaG5vcm0gZm9yIHNjYWxhciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hub3JtIGZvciByYW5rIDEgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHMuYmF0Y2hOb3JtYWxpemF0aW9uMkQoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gT3BzLmJhdGNoTm9ybWFsaXphdGlvbjNEKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIE9wcy5iYXRjaE5vcm1hbGl6YXRpb240RCh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNobm9ybSBmb3IgcmFuayBcIiArIHgucmFuayArIFwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjJEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjNEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjREXCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaG5vcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQWRkJywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9IH0sIGRlcik7XG4gICAgfTtcbiAgICBPcHMuYWRkU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gYWRkU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuYWRkKGIpO1xuICAgIH07XG4gICAgT3BzLnN1YiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5uZWcoKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTdWInLCB7IGlucHV0czogeyBhOiBhLCBiOiBiIH0gfSwgZGVyKTtcbiAgICB9O1xuICAgIE9wcy5zdWJTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzdWJTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5zdWIoYik7XG4gICAgfTtcbiAgICBPcHMucG93ID0gZnVuY3Rpb24gKGJhc2UsIGV4cCkge1xuICAgICAgICB1dGlsLmFzc2VydChleHAuZHR5cGUgPT09ICdpbnQzMicsICdvbmx5IHN1cHBvcnRzIGludDMyIGRhdGEgdHlwZSBmb3IgdGhlIGV4cG9uZW50IHBhcmFtZXRlci4nKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYmFzZS5zaGFwZSwgZXhwLnNoYXBlKTtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYmFzZS5zaGFwZSwgZXhwLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IG9mIHBvdyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgYnJvYWRjYXN0ZWQgc2hhcGVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXJCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IGV4cC50b0Zsb2F0KCkubXVsKGJhc2UucG93KGV4cC5zdWIobmRhcnJheV8xLlNjYWxhci5uZXcoMSwgJ2ludDMyJykpKS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkeS5tdWwoZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJFeHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja3Byb3AgdGhyb3VnaCBleHBvbmVudCBvZiBtYXRoLnBvdyBub3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImltcGxlbWVudGVkIHlldC5cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYmFzZTogZGVyQmFzZSwgZXhwOiBkZXJFeHAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdQb3cnLCB7IGlucHV0czogeyBiYXNlOiBiYXNlLCBleHA6IGV4cCB9IH0sIGdyYWRpZW50KTtcbiAgICB9O1xuICAgIE9wcy5wb3dTdHJpY3QgPSBmdW5jdGlvbiAoYmFzZSwgZXhwKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYmFzZS5zaGFwZSwgZXhwLnNoYXBlLCAnRXJyb3IgaW4gcG93U3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGJhc2UucG93KGV4cCk7XG4gICAgfTtcbiAgICBPcHMubXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChiLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChhLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ011bCcsIHsgaW5wdXRzOiB7IGE6IGEsIGI6IGIgfSB9LCBkZXIpO1xuICAgIH07XG4gICAgT3BzLmVsZW1lbnRXaXNlTXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubXVsU3RyaWN0KGIpO1xuICAgIH07XG4gICAgT3BzLm11bFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG11bHRpcGx5U3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubXVsKGIpO1xuICAgIH07XG4gICAgT3BzLmRpdiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkuZGl2KGIudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gYi5zcXVhcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRpdih0bXAudG9GbG9hdCgpKS5uZWcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnRGl2JywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9IH0sIGRlcik7XG4gICAgfTtcbiAgICBPcHMuZGl2U3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZGl2KGIpO1xuICAgIH07XG4gICAgT3BzLnNjYWxhckRpdmlkZWRCeUFycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhckRpdmlkZWRCeUFycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCBOREFycmF5IG9mIHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gYy5kaXYoYSk7XG4gICAgfTtcbiAgICBPcHMuYXJyYXlEaXZpZGVkQnlTY2FsYXIgPSBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgXCIgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCBOREFycmF5IG9mIHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gYS5kaXYoYyk7XG4gICAgfTtcbiAgICBPcHMubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTWluaW11bScsIHsgaW5wdXRzOiB7IGE6IGEsIGI6IGIgfSB9KTtcbiAgICB9O1xuICAgIE9wcy5taW5pbXVtU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbWluaW11bVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm1pbmltdW0oYik7XG4gICAgfTtcbiAgICBPcHMubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTWF4aW11bScsIHsgaW5wdXRzOiB7IGE6IGEsIGI6IGIgfSB9KTtcbiAgICB9O1xuICAgIE9wcy5tYXhpbXVtU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbWluaW11bVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm1heGltdW0oYik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJhZGRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYWRkU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInN1YlwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzdWJTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicG93XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInBvd1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiZWxlbWVudFdpc2VNdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibXVsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImRpdlwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJkaXZTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic2NhbGFyRGl2aWRlZEJ5QXJyYXlcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYXJyYXlEaXZpZGVkQnlTY2FsYXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibWluaW11bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtaW5pbXVtU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm1heGltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibWF4aW11bVN0cmljdFwiLCBudWxsKTtcbiAgICByZXR1cm4gT3BzO1xufSgpKTtcbmV4cG9ydHMuT3BzID0gT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5X29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgICAgdmFyIGEgPSBpblNoYXBlW2RpbV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xufVxuZXhwb3J0cy5nZXRCcm9hZGNhc3REaW1zID0gZ2V0QnJvYWRjYXN0RGltcztcbmZ1bmN0aW9uIGdldFJlZHVjdGlvbkF4ZXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5EaW0gPSBpblNoYXBlW2luU2hhcGUubGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICB2YXIgb3V0QXhpcyA9IG91dFNoYXBlLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICB2YXIgb3V0RGltID0gb3V0U2hhcGVbb3V0QXhpc107XG4gICAgICAgIGlmIChpbkRpbSA9PSBudWxsIHx8IChpbkRpbSA9PT0gMSAmJiBvdXREaW0gPiAxKSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQob3V0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0UmVkdWN0aW9uQXhlcyA9IGdldFJlZHVjdGlvbkF4ZXM7XG5mdW5jdGlvbiBicm9hZGNhc3REaW1zQXJlT3V0ZXIoZGltcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGltc1tpXSAhPT0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5icm9hZGNhc3REaW1zQXJlT3V0ZXIgPSBicm9hZGNhc3REaW1zQXJlT3V0ZXI7XG5mdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzaGFwZUEsIHNoYXBlQikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZXJyTXNnID0gXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiICtcbiAgICAgICAgKHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiLlwiKTtcbiAgICB2YXIgbCA9IE1hdGgubWF4KHNoYXBlQS5sZW5ndGgsIHNoYXBlQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gc2hhcGVBW3NoYXBlQS5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIGkgLSAxXSB8fCAxO1xuICAgICAgICBpZiAoYSA+IDEgJiYgYiA+IDEgJiYgYSAhPT0gYikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zaGlmdChNYXRoLm1heChhLCBiKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlID0gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm9hZGNhc3RfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTm90RXF1YWwnLCB7IGlucHV0czogeyBhOiBhLCBiOiBiIH0gfSk7XG4gICAgfTtcbiAgICBPcHMubm90RXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBub3RFcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm5vdEVxdWFsKGIpO1xuICAgIH07XG4gICAgT3BzLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0xlc3MnLCB7IGlucHV0czogeyBhOiBhLCBiOiBiIH0gfSk7XG4gICAgfTtcbiAgICBPcHMubGVzc1N0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGxlc3NTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5sZXNzKGIpO1xuICAgIH07XG4gICAgT3BzLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdFcXVhbCcsIHsgaW5wdXRzOiB7IGE6IGEsIGI6IGIgfSB9KTtcbiAgICB9O1xuICAgIE9wcy5lcXVhbFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGVxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZXF1YWwoYik7XG4gICAgfTtcbiAgICBPcHMubGVzc0VxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdMZXNzRXF1YWwnLCB7IGlucHV0czogeyBhOiBhLCBiOiBiIH0gfSk7XG4gICAgfTtcbiAgICBPcHMubGVzc0VxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubGVzc0VxdWFsKGIpO1xuICAgIH07XG4gICAgT3BzLmdyZWF0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0dyZWF0ZXInLCB7IGlucHV0czogeyBhOiBhLCBiOiBiIH0gfSk7XG4gICAgfTtcbiAgICBPcHMuZ3JlYXRlclN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGdyZWF0ZXJTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpO1xuICAgIH07XG4gICAgT3BzLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnR3JlYXRlckVxdWFsJywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9IH0pO1xuICAgIH07XG4gICAgT3BzLmdyZWF0ZXJFcXVhbFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGdyZWF0ZXJFcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmdyZWF0ZXJFcXVhbChiKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm5vdEVxdWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm5vdEVxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImxlc3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibGVzc1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJlcXVhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJlcXVhbFN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJsZXNzRXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibGVzc0VxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImdyZWF0ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiZ3JlYXRlclN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJncmVhdGVyRXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wcygpIHtcbiAgICB9XG4gICAgT3BzLmNvbmNhdDFEID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9wcy5jb25jYXQoYSwgYiwgMCk7XG4gICAgfTtcbiAgICBPcHMuY29uY2F0MkQgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICByZXR1cm4gT3BzLmNvbmNhdChhLCBiLCBheGlzKTtcbiAgICB9O1xuICAgIE9wcy5jb25jYXQzRCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHJldHVybiBPcHMuY29uY2F0KGEsIGIsIGF4aXMpO1xuICAgIH07XG4gICAgT3BzLmNvbmNhdDREID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIE9wcy5jb25jYXQoYSwgYiwgYXhpcyk7XG4gICAgfTtcbiAgICBPcHMuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIHV0aWwuc2l6ZUZyb21TaGFwZShhLnNoYXBlLnNsaWNlKGF4aXMpKSk7XG4gICAgICAgIHZhciBiMkQgPSBiLmFzMkQoLTEsIHV0aWwuc2l6ZUZyb21TaGFwZShiLnNoYXBlLnNsaWNlKGF4aXMpKSk7XG4gICAgICAgIHZhciBfYSA9IGNvbmNhdF91dGlsLmNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzKGEyRC5zaGFwZSwgYjJELnNoYXBlKSwgYUJlZ2luID0gX2EuYUJlZ2luLCBhU2l6ZSA9IF9hLmFTaXplLCBiQmVnaW4gPSBfYS5iQmVnaW4sIGJTaXplID0gX2EuYlNpemU7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuc2xpY2UoYUJlZ2luLCBhU2l6ZSk7IH0sXG4gICAgICAgICAgICAgICAgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuc2xpY2UoYkJlZ2luLCBiU2l6ZSk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQ29uY2F0JywgeyBpbnB1dHM6IHsgYTogYTJELCBiOiBiMkQgfSB9LCBkZXIpO1xuICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29uY2F0MURcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29uY2F0MkRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29uY2F0M0RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29uY2F0NERcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29uY2F0XCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zKGFTaGFwZSwgYlNoYXBlLCBheGlzKSB7XG4gICAgdmFyIGFSYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICB2YXIgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuICAgIHV0aWwuYXNzZXJ0KGFTaGFwZS5sZW5ndGggPT09IGJTaGFwZS5sZW5ndGgsIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogcmFuayBvZiB4MSAoXCIgKyBhUmFuayArIFwiKSBhbmQgeDIgKFwiICsgYlJhbmsgKyBcIikgXCIgK1xuICAgICAgICBcIm11c3QgYmUgdGhlIHNhbWUuXCIpO1xuICAgIHV0aWwuYXNzZXJ0KGF4aXMgPj0gMCAmJiBheGlzIDwgYVJhbmssIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogYXhpcyBtdXN0IGJlIFwiICtcbiAgICAgICAgKFwiYmV0d2VlbiAwIGFuZCBcIiArIChhUmFuayAtIDEpICsgXCIuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSYW5rOyBpKyspIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoKGkgPT09IGF4aXMpIHx8IChhU2hhcGVbaV0gPT09IGJTaGFwZVtpXSksIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogU2hhcGUgKFwiICsgYVNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIGJTaGFwZSArIFwiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiICsgaSArIFwiLlwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXMgPSBhc3NlcnRQYXJhbXM7XG5mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUxRCh4MVNoYXBlLCB4MlNoYXBlKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEsICd4MSBhbmQgeDIgc2hvdWxkIGJlIDFkIGFycmF5LicpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHgxU2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVswXSArPSB4MlNoYXBlWzBdO1xuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dFNoYXBlMUQgPSBjb21wdXRlT3V0U2hhcGUxRDtcbmZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZSh4MVNoYXBlLCB4MlNoYXBlLCBheGlzKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IHgyU2hhcGUubGVuZ3RoLCAneDEgYW5kIHgyIHNob3VsZCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XG4gICAgdmFyIG91dHB1dFNoYXBlID0geDFTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IHgyU2hhcGVbYXhpc107XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0U2hhcGUgPSBjb21wdXRlT3V0U2hhcGU7XG5mdW5jdGlvbiBjb21wdXRlR3JhZGllbnRTbGljZVNoYXBlcyhhU2hhcGUsIGJTaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFCZWdpbjogWzAsIDBdLFxuICAgICAgICBhU2l6ZTogYVNoYXBlLFxuICAgICAgICBiQmVnaW46IFswLCBhU2hhcGVbMV1dLFxuICAgICAgICBiU2l6ZTogYlNoYXBlXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXMgPSBjb21wdXRlR3JhZGllbnRTbGljZVNoYXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMuY29udjFkID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXIsIGJpYXMsIHN0cmlkZSwgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdmFyIGlucHV0M0QgPSBpbnB1dDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG8zRCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5wdXQucmFuayA9PT0gMikge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzNEID0gdHJ1ZTtcbiAgICAgICAgICAgIGlucHV0M0QgPSBpbnB1dC5hczNEKDEsIGlucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQzRC5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYxZDogaW5wdXQgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArIGlucHV0M0QucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjFkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChiaWFzLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gY29udjFkOiBiaWFzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgICAgIChiaWFzLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0M0Quc2hhcGVbMl0gPT09IGZpbHRlci5zaGFwZVsxXSwgXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIiArIGlucHV0M0Quc2hhcGVbMl0gKyBcIikgbXVzdCBtYXRjaCAgXCIgK1xuICAgICAgICAgICAgKFwiaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsxXSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBmaWx0ZXI0RCA9IGZpbHRlci5hczREKDEsIGZpbHRlci5zaGFwZVswXSwgZmlsdGVyLnNoYXBlWzFdLCBmaWx0ZXIuc2hhcGVbMl0pO1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0M0QuYXM0RChpbnB1dDNELnNoYXBlWzBdLCAxLCBpbnB1dDNELnNoYXBlWzFdLCBpbnB1dDNELnNoYXBlWzJdKTtcbiAgICAgICAgdmFyIHN0cmlkZXMgPSBbMSwgc3RyaWRlXTtcbiAgICAgICAgdmFyIHJlcyA9IE9wcy5jb252MmQoaW5wdXQ0RCwgZmlsdGVyNEQsIGJpYXMsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG8zRCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczJEKHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgfTtcbiAgICBPcHMuY29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgYmlhcywgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChiaWFzLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gY29udjJkOiBiaWFzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgICAgIChiaWFzLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5zaGFwZVszXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiICsgeDRELnNoYXBlWzNdICsgXCIpIG11c3QgbWF0Y2ggIFwiICtcbiAgICAgICAgICAgIChcImlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPcHMuY29udjJkRGVySW5wdXQoeDRELnNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpOyB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3BzLmNvbnYyZERlckZpbHRlcih4NEQsIGR5LCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCk7IH0sXG4gICAgICAgICAgICAgICAgYmlhczogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3BzLmNvbnYyZERlckJpYXMoZHkpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0NvbnYyRCcsIHsgaW5wdXRzOiB7IHg6IHg0RCwgZmlsdGVyOiBmaWx0ZXIsIGJpYXM6IGJpYXMgfSwgYXJnczogeyBjb252SW5mbzogY29udkluZm8gfSB9LCBncmFkaWVudHMpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5jb252MmREZXJJbnB1dCA9IGZ1bmN0aW9uICh4U2hhcGUsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaGFwZS5sZW5ndGggPT09IGR5LnJhbmssIFwiTGVuZ3RoIG9mIGluU2hhcGUgXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgeFNoYXBlLmxlbmd0aCArIFwiKSBhbmQgcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB2YXIgeFNoYXBlNEQgPSB4U2hhcGU7XG4gICAgICAgIHZhciBkeTREID0gZHk7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGR5LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgICAgIHhTaGFwZTREID0gWzEsIHhTaGFwZVswXSwgeFNoYXBlWzFdLCB4U2hhcGVbMl1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbkRlcHRoID0geFNoYXBlNERbM107XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGR5NEQuc2hhcGVbM107XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaGFwZTRELmxlbmd0aCA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IGxlbmd0aCBcIiArXG4gICAgICAgICAgICAoeFNoYXBlNEQubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgZHk0RC5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGZpbHRlci5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluRGVwdGggPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiICsgaW5EZXB0aCArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChvdXREZXB0aCA9PT0gZmlsdGVyLnNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiICsgb3V0RGVwdGggKyBcIikgbXVzdFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzNdICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeFNoYXBlNEQsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0NvbnYyRERlcklucHV0JywgeyBpbnB1dHM6IHsgZHk6IGR5NEQsIGZpbHRlcjogZmlsdGVyIH0sIGFyZ3M6IHsgY29udkluZm86IGNvbnZJbmZvIH0gfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgT3BzLmNvbnYyZERlckJpYXMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgdmFyIGR5NEQgPSBkeTtcbiAgICAgICAgaWYgKGR5LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIGR5NEQgPSBkeS5hczREKDEsIGR5LnNoYXBlWzBdLCBkeS5zaGFwZVsxXSwgZHkuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQ29udjJERGVyQmlhcycsIHsgaW5wdXRzOiB7IGR5OiBkeTREIH0gfSk7XG4gICAgfTtcbiAgICBPcHMuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICBpZiAoZHk0RC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgICh4NEQuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeTRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoZHk0RC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlclNoYXBlLmxlbmd0aCA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKGZpbHRlclNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnNoYXBlWzNdID09PSBmaWx0ZXJTaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiICsgeDRELnNoYXBlWzNdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIiArIGZpbHRlclNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5zaGFwZVszXSA9PT0gZmlsdGVyU2hhcGVbM10sIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIgKyBkeTRELnNoYXBlWzNdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiICsgZmlsdGVyU2hhcGVbM10gKyBcIikuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdDb252MkREZXJGaWx0ZXInLCB7IGlucHV0czogeyB4OiB4NEQsIGR5OiBkeTREIH0sIGFyZ3M6IHsgY29udkluZm86IGNvbnZJbmZvIH0gfSk7XG4gICAgfTtcbiAgICBPcHMuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHJldHVybiBPcHMuY29udjJkRGVySW5wdXQob3V0cHV0U2hhcGUsIHgsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgT3BzLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIHJhdGVzLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKHJhdGVzID09PSB2b2lkIDApIHsgcmF0ZXMgPSBbMSwgMV07IH1cbiAgICAgICAgdmFyIGlucHV0NEQgPSBpbnB1dDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5wdXQucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGlucHV0NEQgPSBpbnB1dC5hczREKDEsIGlucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXSwgaW5wdXQuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBpbnB1dDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQuc2hhcGVbM10gPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyBpbnB1dDRELnNoYXBlWzNdICsgXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIFwiKSArXG4gICAgICAgICAgICAoXCJmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICByYXRlcyA9IHJhdGVzIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHJhdGVzKSwgcmF0ZUhlaWdodCA9IF9hWzBdLCByYXRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdXRpbC5hc3NlcnQocmF0ZUhlaWdodCA9PT0gMSAmJiByYXRlV2lkdGggPT09IDEsICdFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0ICcgK1xuICAgICAgICAgICAgKFwic3VwcG9ydGVkLiBHb3QgcmF0ZXMgJ1wiICsgcmF0ZXMgKyBcIidcIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oaW5wdXQ0RC5zaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgdHJ1ZSk7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnRGVwdGh3aXNlQ29udjJEJywgeyBpbnB1dHM6IHsgeDogaW5wdXQ0RCwgZmlsdGVyOiBmaWx0ZXIgfSwgYXJnczogeyBjb252SW5mbzogY29udkluZm8gfSB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJjb252MWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29udjJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNvbnYyZERlcklucHV0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNvbnYyZERlckJpYXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29udjJkRGVyRmlsdGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNvbnYyZFRyYW5zcG9zZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJkZXB0aHdpc2VDb252MkRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gY29tcHV0ZVBvb2wyREluZm8oaW5TaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCByb3VuZGluZ01vZGUsIGRhdGFGb3JtYXQpIHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnY2hhbm5lbHNMYXN0JzsgfVxuICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgdmFyIGZpbHRlclNoYXBlO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBmaWx0ZXJTaGFwZSA9IFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpblNoYXBlWzNdLCBpblNoYXBlWzNdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIGZpbHRlclNoYXBlID0gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluU2hhcGVbMV0sIGluU2hhcGVbMV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiICsgZGF0YUZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgcGFkLCByb3VuZGluZ01vZGUsIGZhbHNlLCBkYXRhRm9ybWF0KTtcbn1cbmV4cG9ydHMuY29tcHV0ZVBvb2wyREluZm8gPSBjb21wdXRlUG9vbDJESW5mbztcbmZ1bmN0aW9uIGNvbXB1dGVDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBwYWQsIHJvdW5kaW5nTW9kZSwgZGVwdGh3aXNlLCBkYXRhRm9ybWF0KSB7XG4gICAgaWYgKGRlcHRod2lzZSA9PT0gdm9pZCAwKSB7IGRlcHRod2lzZSA9IGZhbHNlOyB9XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ2NoYW5uZWxzTGFzdCc7IH1cbiAgICB2YXIgX2EgPSBbLTEsIC0xLCAtMSwgLTFdLCBiYXRjaFNpemUgPSBfYVswXSwgaW5IZWlnaHQgPSBfYVsxXSwgaW5XaWR0aCA9IF9hWzJdLCBpbkNoYW5uZWxzID0gX2FbM107XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGluU2hhcGVbMF0sIGluSGVpZ2h0ID0gaW5TaGFwZVsxXSwgaW5XaWR0aCA9IGluU2hhcGVbMl0sIGluQ2hhbm5lbHMgPSBpblNoYXBlWzNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgYmF0Y2hTaXplID0gaW5TaGFwZVswXSwgaW5DaGFubmVscyA9IGluU2hhcGVbMV0sIGluSGVpZ2h0ID0gaW5TaGFwZVsyXSwgaW5XaWR0aCA9IGluU2hhcGVbM107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIgKyBkYXRhRm9ybWF0KTtcbiAgICB9XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlclNoYXBlWzBdLCBmaWx0ZXJXaWR0aCA9IGZpbHRlclNoYXBlWzFdLCBmaWx0ZXJDaGFubmVscyA9IGZpbHRlclNoYXBlWzNdO1xuICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgdmFyIF9jID0gZ2V0UGFkQW5kT3V0SW5mbyhwYWQsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCByb3VuZGluZ01vZGUpLCBwYWRJbmZvID0gX2MucGFkSW5mbywgb3V0SGVpZ2h0ID0gX2Mub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IF9jLm91dFdpZHRoO1xuICAgIHZhciBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xuICAgIHZhciBvdXRTaGFwZTtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCwgb3V0V2lkdGhdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmF0Y2hTaXplOiBiYXRjaFNpemUsXG4gICAgICAgIGRhdGFGb3JtYXQ6IGRhdGFGb3JtYXQsXG4gICAgICAgIGluSGVpZ2h0OiBpbkhlaWdodCxcbiAgICAgICAgaW5XaWR0aDogaW5XaWR0aCxcbiAgICAgICAgaW5DaGFubmVsczogaW5DaGFubmVscyxcbiAgICAgICAgb3V0SGVpZ2h0OiBvdXRIZWlnaHQsXG4gICAgICAgIG91dFdpZHRoOiBvdXRXaWR0aCxcbiAgICAgICAgb3V0Q2hhbm5lbHM6IG91dENoYW5uZWxzLFxuICAgICAgICBwYWRJbmZvOiBwYWRJbmZvLFxuICAgICAgICBzdHJpZGVIZWlnaHQ6IHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGg6IHN0cmlkZVdpZHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgZmlsdGVyV2lkdGg6IGZpbHRlcldpZHRoLFxuICAgICAgICBpblNoYXBlOiBpblNoYXBlLFxuICAgICAgICBvdXRTaGFwZTogb3V0U2hhcGUsXG4gICAgICAgIGZpbHRlclNoYXBlOiBmaWx0ZXJTaGFwZVxuICAgIH07XG59XG5leHBvcnRzLmNvbXB1dGVDb252MkRJbmZvID0gY29tcHV0ZUNvbnYyREluZm87XG5mdW5jdGlvbiBjb21wdXRlT3V0cHV0U2hhcGUzRChpblNoYXBlLCBmaWVsZFNpemUsIG91dERlcHRoLCBzdHJpZGUsIHplcm9QYWQsIHJvdW5kaW5nTW9kZSkge1xuICAgIGlmICh6ZXJvUGFkID09IG51bGwpIHtcbiAgICAgICAgemVyb1BhZCA9IGNvbXB1dGVEZWZhdWx0UGFkKGluU2hhcGUsIGZpZWxkU2l6ZSwgc3RyaWRlKTtcbiAgICB9XG4gICAgdmFyIGlucHV0Um93cyA9IGluU2hhcGVbMF07XG4gICAgdmFyIGlucHV0Q29scyA9IGluU2hhcGVbMV07XG4gICAgdmFyIG91dHB1dFJvd3MgPSBjb25kaXRpb25hbFJvdW5kKChpbnB1dFJvd3MgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxLCByb3VuZGluZ01vZGUpO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Um93cyksIFwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiICsgb3V0cHV0Um93cyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICB2YXIgb3V0cHV0Q29scyA9IGNvbmRpdGlvbmFsUm91bmQoKGlucHV0Q29scyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDEsIHJvdW5kaW5nTW9kZSk7XG4gICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChvdXRwdXRDb2xzKSwgXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIgKyBvdXRwdXRDb2xzICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIFwiICtcbiAgICAgICAgXCJ0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgIHJldHVybiBbb3V0cHV0Um93cywgb3V0cHV0Q29scywgb3V0RGVwdGhdO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0cHV0U2hhcGUzRCA9IGNvbXB1dGVPdXRwdXRTaGFwZTNEO1xuZnVuY3Rpb24gY29tcHV0ZURlZmF1bHRQYWQoaW5wdXRTaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGZpZWxkU2l6ZSkgLyAyKTtcbn1cbmV4cG9ydHMuY29tcHV0ZURlZmF1bHRQYWQgPSBjb21wdXRlRGVmYXVsdFBhZDtcbmZ1bmN0aW9uIGNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCkge1xuICAgIHJldHVybiBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5wdXREZXB0aCwgb3V0cHV0RGVwdGhdO1xufVxuZXhwb3J0cy5jb21wdXRlV2VpZ2h0c1NoYXBlNEQgPSBjb21wdXRlV2VpZ2h0c1NoYXBlNEQ7XG5mdW5jdGlvbiBjb21wdXRlRGlsYXRlZFJDKHJjLCBvcmlnU3RyaWRlKSB7XG4gICAgdmFyIHJvd3NEaWxhdGVkID0gKHJjWzBdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICB2YXIgY29sc0RpbGF0ZWQgPSAocmNbMV0gLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIHJldHVybiBbcm93c0RpbGF0ZWQsIGNvbHNEaWxhdGVkXTtcbn1cbmV4cG9ydHMuY29tcHV0ZURpbGF0ZWRSQyA9IGNvbXB1dGVEaWxhdGVkUkM7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG5mdW5jdGlvbiBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIHJvdW5kaW5nTW9kZSkge1xuICAgIHZhciBwYWRJbmZvO1xuICAgIHZhciBvdXRIZWlnaHQ7XG4gICAgdmFyIG91dFdpZHRoO1xuICAgIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCB9O1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGUzRChbaW5IZWlnaHQsIGluV2lkdGgsIDFdLCBmaWx0ZXJIZWlnaHQsIDEsIHN0cmlkZUhlaWdodCwgcGFkLCByb3VuZGluZ01vZGUpO1xuICAgICAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVswXTtcbiAgICAgICAgb3V0V2lkdGggPSBvdXRTaGFwZVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAnc2FtZScpIHtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKGluSGVpZ2h0IC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgdmFyIHBhZEFsb25nSGVpZ2h0ID0gKG91dEhlaWdodCAtIDEpICogc3RyaWRlSGVpZ2h0ICsgZmlsdGVySGVpZ2h0IC0gaW5IZWlnaHQ7XG4gICAgICAgIHZhciBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICAgICAgdmFyIHRvcF8xID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tID0gcGFkQWxvbmdIZWlnaHQgLSB0b3BfMTtcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFkQWxvbmdXaWR0aCAtIGxlZnQ7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogdG9wXzEsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAndmFsaWQnKSB7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoKGluSGVpZ2h0IC0gZmlsdGVySGVpZ2h0ICsgMSkgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbCgoaW5XaWR0aCAtIGZpbHRlcldpZHRoICsgMSkgLyBzdHJpZGVXaWR0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiICsgcGFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGFkSW5mbzogcGFkSW5mbywgb3V0SGVpZ2h0OiBvdXRIZWlnaHQsIG91dFdpZHRoOiBvdXRXaWR0aCB9O1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxSb3VuZCh2YWx1ZSwgcm91bmRpbmdNb2RlKSB7XG4gICAgaWYgKCFyb3VuZGluZ01vZGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBjYXNlICdyb3VuZCc6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm91bmRpbmdNb2RlIFwiICsgcm91bmRpbmdNb2RlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIFNxdWFyZUNvc3RGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVDb3N0RnVuYygpIHtcbiAgICAgICAgdGhpcy5oYWxmT25lID0gZW52aXJvbm1lbnRfMS5FTlYubWF0aC5rZWVwKG5kYXJyYXlfMS5TY2FsYXIubmV3KDAuNSkpO1xuICAgIH1cbiAgICBTcXVhcmVDb3N0RnVuYy5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uIChtYXRoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgICAgICB2YXIgZGlmZlNxdWFyZWQgPSBtYXRoLm11bHRpcGx5U3RyaWN0KGRpZmYsIGRpZmYpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWF0aC5tdWx0aXBseSh0aGlzLmhhbGZPbmUsIGRpZmZTcXVhcmVkKTtcbiAgICAgICAgZGlmZi5kaXNwb3NlKCk7XG4gICAgICAgIGRpZmZTcXVhcmVkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgIH07XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlQ29zdEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TcXVhcmVDb3N0RnVuYyA9IFNxdWFyZUNvc3RGdW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zdF9mdW5jdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbmZ1bmN0aW9uIG9wZXJhdGlvbih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLm1hdGguc2NvcGUobmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkodm9pZCAwLCBhcmdzKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cbmV4cG9ydHMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb3JhdG9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoaW1hZ2VzLCBzaXplLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGltYWdlcy5yYW5rID09PSAzIHx8IGltYWdlcy5yYW5rID09PSA0LCBcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGltYWdlcy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoc2l6ZS5sZW5ndGggPT09IDIsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChzaXplICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGJhdGNoSW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbWFnZXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhdGNoSW1hZ2VzID1cbiAgICAgICAgICAgICAgICBpbWFnZXMuYXM0RCgxLCBpbWFnZXMuc2hhcGVbMF0sIGltYWdlcy5zaGFwZVsxXSwgaW1hZ2VzLnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2l6ZVswXSwgbmV3V2lkdGggPSBzaXplWzFdO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1Jlc2l6ZUJpbGluZWFyJywgeyBpbnB1dHM6IHsgeDogYmF0Y2hJbWFnZXMgfSwgYXJnczogeyBuZXdIZWlnaHQ6IG5ld0hlaWdodCwgbmV3V2lkdGg6IG5ld1dpZHRoLCBhbGlnbkNvcm5lcnM6IGFsaWduQ29ybmVycyB9IH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInJlc2l6ZUJpbGluZWFyXCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZV9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5kdHlwZSA9PT0gJ2Jvb2wnICYmIGIuZHR5cGUgPT09ICdib29sJywgJ0Vycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLicpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdMb2dpY2FsQW5kJywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9IH0pO1xuICAgIH07XG4gICAgT3BzLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEuZHR5cGUgPT09ICdib29sJyAmJiBiLmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTG9naWNhbE9yJywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9IH0pO1xuICAgIH07XG4gICAgT3BzLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uZHR5cGUgPT09ICdib29sJyB8fCBhLmR0eXBlID09PSAnYm9vbCcgfHwgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHdoZXJlOiAnKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uc2hhcGVbMF0gPT09IGEuc2hhcGVbMF0sICdUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGBhYCBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIGBjb25kaXRpb25gLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChjb25kaXRpb24uc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiB3aGVyZTogJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdXaGVyZScsIHsgaW5wdXRzOiB7IGNvbmRpdGlvbjogY29uZGl0aW9uLCBhOiBhLCBiOiBiIH0sIGFyZ3M6IHsgZHR5cGU6IGR0eXBlIH0gfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJsb2dpY2FsQW5kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImxvZ2ljYWxPclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJ3aGVyZVwiLCBudWxsKTtcbiAgICByZXR1cm4gT3BzO1xufSgpKTtcbmV4cG9ydHMuT3BzID0gT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9naWNhbF9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wcygpIHtcbiAgICB9XG4gICAgT3BzLm11bHRpUk5OQ2VsbCA9IGZ1bmN0aW9uIChsc3RtQ2VsbHMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZGF0YTtcbiAgICAgICAgdmFyIG5ld1N0YXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdG1DZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGxzdG1DZWxsc1tpXShpbnB1dCwgY1tpXSwgaFtpXSk7XG4gICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMF0pO1xuICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzFdKTtcbiAgICAgICAgICAgIGlucHV0ID0gb3V0cHV0WzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDID0gW107XG4gICAgICAgIHZhciBuZXdIID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBuZXdDLnB1c2gobmV3U3RhdGVzW2ldKTtcbiAgICAgICAgICAgIG5ld0gucHVzaChuZXdTdGF0ZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgIH07XG4gICAgT3BzLmJhc2ljTFNUTUNlbGwgPSBmdW5jdGlvbiAoZm9yZ2V0QmlhcywgbHN0bUtlcm5lbCwgbHN0bUJpYXMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gZGF0YS5jb25jYXQoaCwgMSk7XG4gICAgICAgIHZhciB3ZWlnaHRlZCA9IGNvbWJpbmVkLm1hdE11bChsc3RtS2VybmVsKTtcbiAgICAgICAgdmFyIHJlcyA9IHdlaWdodGVkLmFkZChsc3RtQmlhcyk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZXMuc2hhcGVbMF07XG4gICAgICAgIHZhciBzbGljZUNvbHMgPSByZXMuc2hhcGVbMV0gLyA0O1xuICAgICAgICB2YXIgc2xpY2VTaXplID0gW2JhdGNoU2l6ZSwgc2xpY2VDb2xzXTtcbiAgICAgICAgdmFyIGkgPSByZXMuc2xpY2UoWzAsIDBdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgaiA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgdmFyIGYgPSByZXMuc2xpY2UoWzAsIHNsaWNlQ29scyAqIDJdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgbyA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzICogM10sIHNsaWNlU2l6ZSk7XG4gICAgICAgIHZhciBuZXdDID0gaS5zaWdtb2lkKCkubXVsU3RyaWN0KGoudGFuaCgpKS5hZGRTdHJpY3QoYy5tdWxTdHJpY3QoZm9yZ2V0Qmlhcy5hZGQoZikuc2lnbW9pZCgpKSk7XG4gICAgICAgIHZhciBuZXdIID0gbmV3Qy50YW5oKCkubXVsU3RyaWN0KG8uc2lnbW9pZCgpKTtcbiAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm11bHRpUk5OQ2VsbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJiYXNpY0xTVE1DZWxsXCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sc3RtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGFycmF5X29wcyA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBiYWNrZW5kX2VuZ2luZV8xID0gcmVxdWlyZShcIi4vYmFja2VuZHMvYmFja2VuZF9lbmdpbmVcIik7XG52YXIgYmF0Y2hub3JtID0gcmVxdWlyZShcIi4vYmF0Y2hub3JtXCIpO1xudmFyIGJpbmFyeV9vcHMgPSByZXF1aXJlKFwiLi9iaW5hcnlfb3BzXCIpO1xudmFyIGNvbXBhcmUgPSByZXF1aXJlKFwiLi9jb21wYXJlXCIpO1xudmFyIGNvbmNhdCA9IHJlcXVpcmUoXCIuL2NvbmNhdFwiKTtcbnZhciBjb252ID0gcmVxdWlyZShcIi4vY29udlwiKTtcbnZhciBpbWFnZV9vcHMgPSByZXF1aXJlKFwiLi9pbWFnZV9vcHNcIik7XG52YXIgbG9naWNhbCA9IHJlcXVpcmUoXCIuL2xvZ2ljYWxfb3BzXCIpO1xudmFyIGxzdG1fb3BzID0gcmVxdWlyZShcIi4vbHN0bVwiKTtcbnZhciBtYXRtdWwgPSByZXF1aXJlKFwiLi9tYXRtdWxcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBub3JtID0gcmVxdWlyZShcIi4vbm9ybVwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgcG9vbCA9IHJlcXVpcmUoXCIuL3Bvb2xcIik7XG52YXIgcmVkdWN0aW9uX29wcyA9IHJlcXVpcmUoXCIuL3JlZHVjdGlvbl9vcHNcIik7XG52YXIgcmV2ZXJzZSA9IHJlcXVpcmUoXCIuL3JldmVyc2VcIik7XG52YXIgc2xpY2UgPSByZXF1aXJlKFwiLi9zbGljZVwiKTtcbnZhciBzb2Z0bWF4X29wcyA9IHJlcXVpcmUoXCIuL3NvZnRtYXhcIik7XG52YXIgdHJhbnNwb3NlID0gcmVxdWlyZShcIi4vdHJhbnNwb3NlXCIpO1xudmFyIHVuYXJ5X29wcyA9IHJlcXVpcmUoXCIuL3VuYXJ5X29wc1wiKTtcbnZhciBOREFycmF5TWF0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGgoYmFja2VuZCwgc2FmZU1vZGUpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkQXJyYXlzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1c3RvbUJhY2tlbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRNdWwgPSBtYXRtdWwuT3BzLm1hdE11bDtcbiAgICAgICAgdGhpcy52ZWN0b3JUaW1lc01hdHJpeCA9IG1hdG11bC5PcHMudmVjdG9yVGltZXNNYXRyaXg7XG4gICAgICAgIHRoaXMub3V0ZXJQcm9kdWN0ID0gbWF0bXVsLk9wcy5vdXRlclByb2R1Y3Q7XG4gICAgICAgIHRoaXMubWF0cml4VGltZXNWZWN0b3IgPSBtYXRtdWwuT3BzLm1hdHJpeFRpbWVzVmVjdG9yO1xuICAgICAgICB0aGlzLmRvdFByb2R1Y3QgPSBtYXRtdWwuT3BzLmRvdFByb2R1Y3Q7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZS5PcHMuc2xpY2U7XG4gICAgICAgIHRoaXMuc2xpY2UxRCA9IHNsaWNlLk9wcy5zbGljZTFEO1xuICAgICAgICB0aGlzLnNsaWNlMkQgPSBzbGljZS5PcHMuc2xpY2UyRDtcbiAgICAgICAgdGhpcy5zbGljZTNEID0gc2xpY2UuT3BzLnNsaWNlM0Q7XG4gICAgICAgIHRoaXMuc2xpY2U0RCA9IHNsaWNlLk9wcy5zbGljZTREO1xuICAgICAgICB0aGlzLnJldmVyc2UgPSByZXZlcnNlLk9wcy5yZXZlcnNlO1xuICAgICAgICB0aGlzLnJldmVyc2UxRCA9IHJldmVyc2UuT3BzLnJldmVyc2UxRDtcbiAgICAgICAgdGhpcy5yZXZlcnNlMkQgPSByZXZlcnNlLk9wcy5yZXZlcnNlMkQ7XG4gICAgICAgIHRoaXMucmV2ZXJzZTNEID0gcmV2ZXJzZS5PcHMucmV2ZXJzZTNEO1xuICAgICAgICB0aGlzLnJldmVyc2U0RCA9IHJldmVyc2UuT3BzLnJldmVyc2U0RDtcbiAgICAgICAgdGhpcy5jb25jYXQgPSBjb25jYXQuT3BzLmNvbmNhdDtcbiAgICAgICAgdGhpcy5jb25jYXQxRCA9IGNvbmNhdC5PcHMuY29uY2F0MUQ7XG4gICAgICAgIHRoaXMuY29uY2F0MkQgPSBjb25jYXQuT3BzLmNvbmNhdDJEO1xuICAgICAgICB0aGlzLmNvbmNhdDNEID0gY29uY2F0Lk9wcy5jb25jYXQzRDtcbiAgICAgICAgdGhpcy5jb25jYXQ0RCA9IGNvbmNhdC5PcHMuY29uY2F0NEQ7XG4gICAgICAgIHRoaXMuYmF0Y2hOb3JtYWxpemF0aW9uID0gYmF0Y2hub3JtLk9wcy5iYXRjaE5vcm1hbGl6YXRpb247XG4gICAgICAgIHRoaXMuYmF0Y2hOb3JtYWxpemF0aW9uMkQgPSBiYXRjaG5vcm0uT3BzLmJhdGNoTm9ybWFsaXphdGlvbjJEO1xuICAgICAgICB0aGlzLmJhdGNoTm9ybWFsaXphdGlvbjNEID0gYmF0Y2hub3JtLk9wcy5iYXRjaE5vcm1hbGl6YXRpb24zRDtcbiAgICAgICAgdGhpcy5iYXRjaE5vcm1hbGl6YXRpb240RCA9IGJhdGNobm9ybS5PcHMuYmF0Y2hOb3JtYWxpemF0aW9uNEQ7XG4gICAgICAgIHRoaXMuYXZnUG9vbCA9IHBvb2wuT3BzLmF2Z1Bvb2w7XG4gICAgICAgIHRoaXMubWF4UG9vbCA9IHBvb2wuT3BzLm1heFBvb2w7XG4gICAgICAgIHRoaXMubWluUG9vbCA9IHBvb2wuT3BzLm1pblBvb2w7XG4gICAgICAgIHRoaXMubWF4UG9vbEJhY2twcm9wID0gcG9vbC5PcHMubWF4UG9vbEJhY2twcm9wO1xuICAgICAgICB0aGlzLmNvbnYxZCA9IGNvbnYuT3BzLmNvbnYxZDtcbiAgICAgICAgdGhpcy5jb252MmQgPSBjb252Lk9wcy5jb252MmQ7XG4gICAgICAgIHRoaXMuY29udjJkVHJhbnNwb3NlID0gY29udi5PcHMuY29udjJkVHJhbnNwb3NlO1xuICAgICAgICB0aGlzLmRlcHRod2lzZUNvbnYyRCA9IGNvbnYuT3BzLmRlcHRod2lzZUNvbnYyRDtcbiAgICAgICAgdGhpcy5jb252MmREZXJCaWFzID0gY29udi5PcHMuY29udjJkRGVyQmlhcztcbiAgICAgICAgdGhpcy5jb252MmREZXJGaWx0ZXIgPSBjb252Lk9wcy5jb252MmREZXJGaWx0ZXI7XG4gICAgICAgIHRoaXMuY29udjJkRGVySW5wdXQgPSBjb252Lk9wcy5jb252MmREZXJJbnB1dDtcbiAgICAgICAgdGhpcy5hcmdNYXggPSByZWR1Y3Rpb25fb3BzLk9wcy5hcmdNYXg7XG4gICAgICAgIHRoaXMuYXJnTWF4RXF1YWxzID0gcmVkdWN0aW9uX29wcy5PcHMuYXJnTWF4RXF1YWxzO1xuICAgICAgICB0aGlzLmFyZ01pbiA9IHJlZHVjdGlvbl9vcHMuT3BzLmFyZ01pbjtcbiAgICAgICAgdGhpcy5sb2dTdW1FeHAgPSByZWR1Y3Rpb25fb3BzLk9wcy5sb2dTdW1FeHA7XG4gICAgICAgIHRoaXMubWF4ID0gcmVkdWN0aW9uX29wcy5PcHMubWF4O1xuICAgICAgICB0aGlzLm1lYW4gPSByZWR1Y3Rpb25fb3BzLk9wcy5tZWFuO1xuICAgICAgICB0aGlzLm1pbiA9IHJlZHVjdGlvbl9vcHMuT3BzLm1pbjtcbiAgICAgICAgdGhpcy5tb21lbnRzID0gcmVkdWN0aW9uX29wcy5PcHMubW9tZW50cztcbiAgICAgICAgdGhpcy5zdW0gPSByZWR1Y3Rpb25fb3BzLk9wcy5zdW07XG4gICAgICAgIHRoaXMuYWRkID0gYmluYXJ5X29wcy5PcHMuYWRkO1xuICAgICAgICB0aGlzLmFkZFN0cmljdCA9IGJpbmFyeV9vcHMuT3BzLmFkZFN0cmljdDtcbiAgICAgICAgdGhpcy5hcnJheURpdmlkZWRCeVNjYWxhciA9IGJpbmFyeV9vcHMuT3BzLmFycmF5RGl2aWRlZEJ5U2NhbGFyO1xuICAgICAgICB0aGlzLmRpdiA9IGJpbmFyeV9vcHMuT3BzLmRpdjtcbiAgICAgICAgdGhpcy5kaXZpZGUgPSB0aGlzLmRpdjtcbiAgICAgICAgdGhpcy5kaXZTdHJpY3QgPSBiaW5hcnlfb3BzLk9wcy5kaXZTdHJpY3Q7XG4gICAgICAgIHRoaXMuZGl2aWRlU3RyaWN0ID0gdGhpcy5kaXZTdHJpY3Q7XG4gICAgICAgIHRoaXMuZWxlbWVudFdpc2VNdWwgPSBiaW5hcnlfb3BzLk9wcy5lbGVtZW50V2lzZU11bDtcbiAgICAgICAgdGhpcy5tYXhpbXVtID0gYmluYXJ5X29wcy5PcHMubWF4aW11bTtcbiAgICAgICAgdGhpcy5tYXhpbXVtU3RyaWN0ID0gYmluYXJ5X29wcy5PcHMubWF4aW11bVN0cmljdDtcbiAgICAgICAgdGhpcy5taW5pbXVtID0gYmluYXJ5X29wcy5PcHMubWluaW11bTtcbiAgICAgICAgdGhpcy5taW5pbXVtU3RyaWN0ID0gYmluYXJ5X29wcy5PcHMubWluaW11bVN0cmljdDtcbiAgICAgICAgdGhpcy5tdWwgPSBiaW5hcnlfb3BzLk9wcy5tdWw7XG4gICAgICAgIHRoaXMubXVsdGlwbHkgPSB0aGlzLm11bDtcbiAgICAgICAgdGhpcy5tdWxTdHJpY3QgPSBiaW5hcnlfb3BzLk9wcy5tdWxTdHJpY3Q7XG4gICAgICAgIHRoaXMubXVsdGlwbHlTdHJpY3QgPSB0aGlzLm11bFN0cmljdDtcbiAgICAgICAgdGhpcy5wb3cgPSBiaW5hcnlfb3BzLk9wcy5wb3c7XG4gICAgICAgIHRoaXMucG93U3RyaWN0ID0gYmluYXJ5X29wcy5PcHMucG93U3RyaWN0O1xuICAgICAgICB0aGlzLnNjYWxhckRpdmlkZWRCeUFycmF5ID0gYmluYXJ5X29wcy5PcHMuc2NhbGFyRGl2aWRlZEJ5QXJyYXk7XG4gICAgICAgIHRoaXMuc3ViID0gYmluYXJ5X29wcy5PcHMuc3ViO1xuICAgICAgICB0aGlzLnN1YnRyYWN0ID0gdGhpcy5zdWI7XG4gICAgICAgIHRoaXMuc3ViU3RyaWN0ID0gYmluYXJ5X29wcy5PcHMuc3ViU3RyaWN0O1xuICAgICAgICB0aGlzLmxvZ2ljYWxBbmQgPSBsb2dpY2FsLk9wcy5sb2dpY2FsQW5kO1xuICAgICAgICB0aGlzLmxvZ2ljYWxPciA9IGxvZ2ljYWwuT3BzLmxvZ2ljYWxPcjtcbiAgICAgICAgdGhpcy53aGVyZSA9IGxvZ2ljYWwuT3BzLndoZXJlO1xuICAgICAgICB0aGlzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZS5PcHMudHJhbnNwb3NlO1xuICAgICAgICB0aGlzLmVxdWFsID0gY29tcGFyZS5PcHMuZXF1YWw7XG4gICAgICAgIHRoaXMuZXF1YWxTdHJpY3QgPSBjb21wYXJlLk9wcy5lcXVhbFN0cmljdDtcbiAgICAgICAgdGhpcy5ncmVhdGVyID0gY29tcGFyZS5PcHMuZ3JlYXRlcjtcbiAgICAgICAgdGhpcy5ncmVhdGVyU3RyaWN0ID0gY29tcGFyZS5PcHMuZ3JlYXRlclN0cmljdDtcbiAgICAgICAgdGhpcy5ncmVhdGVyRXF1YWwgPSBjb21wYXJlLk9wcy5ncmVhdGVyRXF1YWw7XG4gICAgICAgIHRoaXMuZ3JlYXRlckVxdWFsU3RyaWN0ID0gY29tcGFyZS5PcHMuZ3JlYXRlckVxdWFsU3RyaWN0O1xuICAgICAgICB0aGlzLmxlc3MgPSBjb21wYXJlLk9wcy5sZXNzO1xuICAgICAgICB0aGlzLmxlc3NTdHJpY3QgPSBjb21wYXJlLk9wcy5sZXNzU3RyaWN0O1xuICAgICAgICB0aGlzLmxlc3NFcXVhbCA9IGNvbXBhcmUuT3BzLmxlc3NFcXVhbDtcbiAgICAgICAgdGhpcy5sZXNzRXF1YWxTdHJpY3QgPSBjb21wYXJlLk9wcy5sZXNzRXF1YWxTdHJpY3Q7XG4gICAgICAgIHRoaXMubm90RXF1YWwgPSBjb21wYXJlLk9wcy5ub3RFcXVhbDtcbiAgICAgICAgdGhpcy5ub3RFcXVhbFN0cmljdCA9IGNvbXBhcmUuT3BzLm5vdEVxdWFsU3RyaWN0O1xuICAgICAgICB0aGlzLmFicyA9IHVuYXJ5X29wcy5PcHMuYWJzO1xuICAgICAgICB0aGlzLmFjb3MgPSB1bmFyeV9vcHMuT3BzLmFjb3M7XG4gICAgICAgIHRoaXMuYXNpbiA9IHVuYXJ5X29wcy5PcHMuYXNpbjtcbiAgICAgICAgdGhpcy5hdGFuID0gdW5hcnlfb3BzLk9wcy5hdGFuO1xuICAgICAgICB0aGlzLmNlaWwgPSB1bmFyeV9vcHMuT3BzLmNlaWw7XG4gICAgICAgIHRoaXMuY2xpcCA9IHVuYXJ5X29wcy5PcHMuY2xpcDtcbiAgICAgICAgdGhpcy5jb3MgPSB1bmFyeV9vcHMuT3BzLmNvcztcbiAgICAgICAgdGhpcy5jb3NoID0gdW5hcnlfb3BzLk9wcy5jb3NoO1xuICAgICAgICB0aGlzLmVsdSA9IHVuYXJ5X29wcy5PcHMuZWx1O1xuICAgICAgICB0aGlzLmV4cCA9IHVuYXJ5X29wcy5PcHMuZXhwO1xuICAgICAgICB0aGlzLmZsb29yID0gdW5hcnlfb3BzLk9wcy5mbG9vcjtcbiAgICAgICAgdGhpcy5sZWFreVJlbHUgPSB1bmFyeV9vcHMuT3BzLmxlYWt5UmVsdTtcbiAgICAgICAgdGhpcy5sb2cgPSB1bmFyeV9vcHMuT3BzLmxvZztcbiAgICAgICAgdGhpcy5uZWcgPSB1bmFyeV9vcHMuT3BzLm5lZztcbiAgICAgICAgdGhpcy5wcmVsdSA9IHVuYXJ5X29wcy5PcHMucHJlbHU7XG4gICAgICAgIHRoaXMucmVsdSA9IHVuYXJ5X29wcy5PcHMucmVsdTtcbiAgICAgICAgdGhpcy5zZWx1ID0gdW5hcnlfb3BzLk9wcy5zZWx1O1xuICAgICAgICB0aGlzLnNpZ21vaWQgPSB1bmFyeV9vcHMuT3BzLnNpZ21vaWQ7XG4gICAgICAgIHRoaXMuc2luID0gdW5hcnlfb3BzLk9wcy5zaW47XG4gICAgICAgIHRoaXMuc2luaCA9IHVuYXJ5X29wcy5PcHMuc2luaDtcbiAgICAgICAgdGhpcy5zcXJ0ID0gdW5hcnlfb3BzLk9wcy5zcXJ0O1xuICAgICAgICB0aGlzLnNxdWFyZSA9IHVuYXJ5X29wcy5PcHMuc3F1YXJlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB1bmFyeV9vcHMuT3BzLnN0ZXA7XG4gICAgICAgIHRoaXMudGFuID0gdW5hcnlfb3BzLk9wcy50YW47XG4gICAgICAgIHRoaXMudGFuaCA9IHVuYXJ5X29wcy5PcHMudGFuaDtcbiAgICAgICAgdGhpcy5ub3JtID0gbm9ybS5PcHMubm9ybTtcbiAgICAgICAgdGhpcy5iYXNpY0xTVE1DZWxsID0gbHN0bV9vcHMuT3BzLmJhc2ljTFNUTUNlbGw7XG4gICAgICAgIHRoaXMubXVsdGlSTk5DZWxsID0gbHN0bV9vcHMuT3BzLm11bHRpUk5OQ2VsbDtcbiAgICAgICAgdGhpcy5zb2Z0bWF4ID0gc29mdG1heF9vcHMuT3BzLnNvZnRtYXg7XG4gICAgICAgIHRoaXMuc29mdG1heENyb3NzRW50cm9weSA9IHNvZnRtYXhfb3BzLk9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5O1xuICAgICAgICB0aGlzLmNhc3QgPSBhcnJheV9vcHMuT3BzLmNhc3Q7XG4gICAgICAgIHRoaXMuY2xvbmUgPSBhcnJheV9vcHMuT3BzLmNsb25lO1xuICAgICAgICB0aGlzLmdhdGhlciA9IGFycmF5X29wcy5PcHMuZ2F0aGVyO1xuICAgICAgICB0aGlzLnJlc2hhcGUgPSBhcnJheV9vcHMuT3BzLnJlc2hhcGU7XG4gICAgICAgIHRoaXMudGlsZSA9IGFycmF5X29wcy5PcHMudGlsZTtcbiAgICAgICAgdGhpcy5vbmVIb3QgPSBhcnJheV9vcHMuT3BzLm9uZUhvdDtcbiAgICAgICAgdGhpcy5tdWx0aW5vbWlhbCA9IGFycmF5X29wcy5PcHMubXVsdGlub21pYWw7XG4gICAgICAgIHRoaXMucGFkMUQgPSBhcnJheV9vcHMuT3BzLnBhZDFEO1xuICAgICAgICB0aGlzLnBhZDJEID0gYXJyYXlfb3BzLk9wcy5wYWQyRDtcbiAgICAgICAgdGhpcy5yZXNpemVCaWxpbmVhcjNEID0gaW1hZ2Vfb3BzLk9wcy5yZXNpemVCaWxpbmVhcjtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYmFja2VuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZCA9IGVudmlyb25tZW50XzEuRU5WLmdldEJhY2tlbmQoYmFja2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUJhY2tlbmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBiYWNrZW5kX2VuZ2luZV8xLkJhY2tlbmRFbmdpbmUodGhpcy5iYWNrZW5kLCBzYWZlTW9kZSk7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLnNldE1hdGgodGhpcyk7XG4gICAgfVxuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQudGltZShxdWVyeSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZ2V0TnVtQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkQXJyYXlzLnNpemU7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcmVmQ291bnQgPSB0aGlzLnJlZ2lzdGVyZWRBcnJheXMuaGFzKGEuZGF0YUlkKSA/XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRBcnJheXMuZ2V0KGEuZGF0YUlkKSA6XG4gICAgICAgICAgICAwO1xuICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZC5yZWdpc3RlcihhLmRhdGFJZCwgYS5zaGFwZSwgYS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkQXJyYXlzLnNldChhLmRhdGFJZCwgcmVmQ291bnQgKyAxKTtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5WYXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnRyYWNrKGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVnaXN0ZXJWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdi5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSB3aXRoIG5hbWUgXCIgKyB2Lm5hbWUgKyBcIiB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t2Lm5hbWVdID0gdjtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5mcm9tUGl4ZWxzKHBpeGVscywgbnVtQ2hhbm5lbHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGFJZCwgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC53cml0ZShkYXRhSWQsIHZhbHVlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQucmVhZFN5bmMoZGF0YUlkKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnJlYWQoZGF0YUlkKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbmFibGVEZWJ1Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmVuYWJsZURlYnVnTW9kZSgpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsICcgK1xuICAgICAgICAgICAgJ2JlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiAnICtcbiAgICAgICAgICAgICdUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS4nKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChuYW1lT3JTY29wZUZuLCBzY29wZUZuLCBncmFkaWVudHNNb2RlKSB7XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlID09PSB2b2lkIDApIHsgZ3JhZGllbnRzTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChzY29wZUZuID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZU9yU2NvcGVGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBtYXRoLnNjb3BlKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlRm4gPSBuYW1lT3JTY29wZUZuO1xuICAgICAgICAgICAgbmFtZU9yU2NvcGVGbiA9ICdzY29wZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVPclNjb3BlRm4gIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgIShuYW1lT3JTY29wZUZuIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIGZpcnN0IGFyZ3VtZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAndG8gbWF0aC5zY29wZSgpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NvcGVGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIDJuZCBhcmd1bWVudCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIG1hdGguc2NvcGUoKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuc2NvcGUobmFtZU9yU2NvcGVGbiwgc2NvcGVGbiwgZ3JhZGllbnRzTW9kZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZ3JhZGllbnRzU2NvcGUgPSBmdW5jdGlvbiAobmFtZU9yU2NvcGVGbiwgc2NvcGVGbikge1xuICAgICAgICB2YXIgZ3JhZGllbnRzTW9kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlKG5hbWVPclNjb3BlRm4sIHNjb3BlRm4sIGdyYWRpZW50c01vZGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN0YXJ0U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncmFkaWVudHNNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5naW5lLnN0YXJ0U2NvcGUoZ3JhZGllbnRzTW9kZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZW5kU2NvcGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBncmFkaWVudHNNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5naW5lLmVuZFNjb3BlKHJlc3VsdCwgZ3JhZGllbnRzTW9kZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUua2VlcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmtlZXAocmVzdWx0KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21CYWNrZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudG9wSyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGsgPD0geC5zaXplLCBcIkVycm9yIGluIHRvcEs6IGsgdmFsdWUgKFwiICsgayArIFwiKSBtdXN0IGJlIGxlc3MgdGhhbiBzaXplIG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgIChcIm5kYXJyYXksIGdvdCBzaGFwZSBcIiArIHguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB2YXIgdmFsdWVzO1xuICAgICAgICB2YXIgaW5kaWNlcztcbiAgICAgICAgdGhpcy5zY29wZSgndG9wSycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1RvcEtWYWx1ZXMnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgazogayB9IH0pO1xuICAgICAgICAgICAgaW5kaWNlcyA9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1RvcEtJbmRpY2VzJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IGs6IGsgfSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0geyB2YWx1ZXM6IHZhbHVlcywgaW5kaWNlczogaW5kaWNlcyB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN3aXRjaERpbSA9IGZ1bmN0aW9uICh4LCBwZXJtKSB7XG4gICAgICAgIHJldHVybiBvcHMudHJhbnNwb3NlKHgsIHBlcm0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhclBsdXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsYXJQbHVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyTWludXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsYXJNaW51c0FycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJyYXlNaW51c1NjYWxhciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheU1pbnVzU2NhbGFyOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KGEsIGMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxlZEFycmF5QWRkID0gZnVuY3Rpb24gKGMxLCBhLCBjMiwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChjMS5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxlZEFycmF5QWRkOiBmaXJzdCBhcmd1bWVudCBtdXN0IHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCIgcmFuayBcIiArIGMxLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChjMi5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxlZEFycmF5QWRkOiB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJOREFycmF5IG9mIHJhbmsgXCIgKyBjMi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZSgnc2NhbGVkQXJyYXlBZGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkKF90aGlzLm11bHRpcGx5KGMxLCBhKSwgX3RoaXMubXVsdGlwbHkoYzIsIGIpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyVGltZXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uM0QgPSBmdW5jdGlvbiAoeCwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbikge1xuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHsgcmFkaXVzID0gNTsgfVxuICAgICAgICBpZiAoYmlhcyA9PT0gdm9pZCAwKSB7IGJpYXMgPSAxOyB9XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMTsgfVxuICAgICAgICBpZiAoYmV0YSA9PT0gdm9pZCAwKSB7IGJldGEgPSAwLjU7IH1cbiAgICAgICAgaWYgKG5vcm1SZWdpb24gPT09IHZvaWQgMCkgeyBub3JtUmVnaW9uID0gJ2Fjcm9zc0NoYW5uZWxzJzsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290XFxuICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChyYWRpdXMpLCBcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uM0Q6IHJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXJcXG4gICAgICAgICBidXQgZ290IHJhZGl1cyBcIiArIHJhZGl1cyArIFwiLlwiKTtcbiAgICAgICAgdmFyIGlucHV0NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaW5wdXQ0RCwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbik7XG4gICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREID0gZnVuY3Rpb24gKHgsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEsIG5vcm1SZWdpb24pIHtcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7IHJhZGl1cyA9IDU7IH1cbiAgICAgICAgaWYgKGJpYXMgPT09IHZvaWQgMCkgeyBiaWFzID0gMTsgfVxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDE7IH1cbiAgICAgICAgaWYgKGJldGEgPT09IHZvaWQgMCkgeyBiZXRhID0gMC41OyB9XG4gICAgICAgIGlmIChub3JtUmVnaW9uID09PSB2b2lkIDApIHsgbm9ybVJlZ2lvbiA9ICdhY3Jvc3NDaGFubmVscyc7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSA0LCBcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdFxcbiAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocmFkaXVzKSwgXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjNEOiByYWRpdXMgbXVzdCBiZSBhbiBpbnRlZ2VyXFxuICAgICAgICAgYnV0IGdvdCByYWRpdXMgXCIgKyByYWRpdXMgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5leGVjdXRlS2VybmVsKCdMUk40RCcsIHsgaW5wdXRzOiB7IHg6IHggfSwgYXJnczogeyByYWRpdXM6IHJhZGl1cywgYmlhczogYmlhcywgYWxwaGE6IGFscGhhLCBiZXRhOiBiZXRhLCBub3JtUmVnaW9uOiBub3JtUmVnaW9uIH0gfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudmpwID0gZnVuY3Rpb24gKGYsIHgsIGR5KSB7XG4gICAgICAgIHZhciBrZXlzID0geCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5ID8gbnVsbCA6IE9iamVjdC5rZXlzKHgpO1xuICAgICAgICB2YXIgeHMgPSB1dGlsLmZsYXR0ZW5OYW1lQXJyYXlNYXAoeCwga2V5cyk7XG4gICAgICAgIHZhciB2anAgPSB0aGlzLmVuZ2luZS52anAoZiwgeHMsIGR5KTtcbiAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZqcFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLnVuZmxhdHRlblRvTmFtZUFycmF5TWFwKGtleXMsIHZqcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5ncmFkaWVudHMgPSBmdW5jdGlvbiAoZiwgeCkge1xuICAgICAgICB2YXIga2V5cyA9IHggaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSA/IG51bGwgOiBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgdmFyIHhzID0gdXRpbC5mbGF0dGVuTmFtZUFycmF5TWFwKHgsIGtleXMpO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHRoaXMuZW5naW5lLmdyYWRpZW50cyhmLCB4cywgcmV0dXJuVmFsdWUpO1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWwudW5mbGF0dGVuVG9OYW1lQXJyYXlNYXAoa2V5cywgZ3JhZGllbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnZhcmlhYmxlR3JhZGllbnRzID0gZnVuY3Rpb24gKGYsIHZhckxpc3QpIHtcbiAgICAgICAgaWYgKHZhckxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyTGlzdC5wdXNoKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJMaXN0ID0gdmFyTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHZhcmlhYmxlKSB7IHJldHVybiB2YXJpYWJsZS50cmFpbmFibGU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS52YXJpYWJsZUdyYWRpZW50c0FuZFZhbHVlKGYsIHZhckxpc3QpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnZhbHVlQW5kR3JhZGllbnRzID0gZnVuY3Rpb24gKGYsIHgpIHtcbiAgICAgICAgdmFyIGtleXMgPSB4IGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkgPyBudWxsIDogT2JqZWN0LmtleXMoeCk7XG4gICAgICAgIHZhciB4cyA9IHV0aWwuZmxhdHRlbk5hbWVBcnJheU1hcCh4LCBrZXlzKTtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHZhbHVlQW5kR3JhZGllbnRzID0gdGhpcy5lbmdpbmUuZ3JhZGllbnRzKGYsIHhzLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIHZhciBncmFkaWVudHM7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGdyYWRpZW50cyA9IHZhbHVlQW5kR3JhZGllbnRzLmdyYWRpZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyYWRpZW50cyA9XG4gICAgICAgICAgICAgICAgdXRpbC51bmZsYXR0ZW5Ub05hbWVBcnJheU1hcChrZXlzLCB2YWx1ZUFuZEdyYWRpZW50cy5ncmFkaWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZUFuZEdyYWRpZW50cy52YWx1ZSwgZ3JhZGllbnRzOiBncmFkaWVudHMgfTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jdXN0b21HcmFkaWVudCA9IGZ1bmN0aW9uIChuYW1lLCBmLCBpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmN1c3RvbUdyYWRpZW50KGYsIGlucHV0cywgbmFtZSA9PSBudWxsID8gJycgOiBuYW1lKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXNwb3NlRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyZWRBcnJheXMuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmQ291bnQgPSB0aGlzLnJlZ2lzdGVyZWRBcnJheXMuZ2V0KGRhdGFJZCk7XG4gICAgICAgIGlmIChyZWZDb3VudCA8PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRBcnJheXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmQuZGlzcG9zZURhdGEoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEFycmF5cy5zZXQoZGF0YUlkLCByZWZDb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGg7XG59KCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IE5EQXJyYXlNYXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL2JhY2tlbmRzL3R5cGVzL21hdG11bFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChhT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBhT3JpZW50YXRpb24gPSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBiT3JpZW50YXRpb24gPSBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIHZhciBpbm5lclNoYXBlQSA9IChhT3JpZW50YXRpb24gPT09IG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBpbm5lclNoYXBlQiA9IChiT3JpZW50YXRpb24gPT09IG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYi5zaGFwZVswXSA6IGIuc2hhcGVbMV07XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gMiAmJiBiLnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBiZSByYW5rIDIsIGdvdCByYW5rcyBcIiArIGEucmFuayArXG4gICAgICAgICAgICAoXCIgYW5kIFwiICsgYi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLCBcIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIiArIGlubmVyU2hhcGVBICsgXCIpIGFuZCAoXCIgK1xuICAgICAgICAgICAgKGlubmVyU2hhcGVCICsgXCIpIG9mIE5EQXJyYXlzIHdpdGggc2hhcGVzIFwiICsgYS5zaGFwZSArIFwiIGFuZCBcIikgK1xuICAgICAgICAgICAgKGIuc2hhcGUgKyBcIiBhbmQgb3JpZW50YXRpb25zIFwiICsgbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb25bYU9yaWVudGF0aW9uXSkgK1xuICAgICAgICAgICAgKFwiIGFuZCBcIiArIG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uW2JPcmllbnRhdGlvbl0gKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTWF0TXVsJywgeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9LCBhcmdzOiB7IGFPcmllbnRhdGlvbjogYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb246IGJPcmllbnRhdGlvbiB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgaWYgKGFPcmllbnRhdGlvbiA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCB8fFxuICAgICAgICAgICAgICAgIGJPcmllbnRhdGlvbiA9PT0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2twcm9wIGZvciB0cmFuc3Bvc2VkIE1hdE11bCBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubWF0TXVsKGIudG9GbG9hdCgpLCBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSLCBtYXRtdWxfMS5NYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VEKTsgfSxcbiAgICAgICAgICAgICAgICBiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhLnRvRmxvYXQoKS5tYXRNdWwoZHksIG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQsIG1hdG11bF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy52ZWN0b3JUaW1lc01hdHJpeCA9IGZ1bmN0aW9uICh2LCBtYXRyaXgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgdi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWF0cml4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNlY29uZCBpbnB1dCBtdXN0IGJlIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVswXSwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2l6ZSBvZiB2ZWN0b3IgKFwiICsgdi5zaXplICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCAoXCIgKyBtYXRyaXguc2hhcGVbMF0gKyBcIilcIikpO1xuICAgICAgICByZXR1cm4gdi5hczJEKDEsIC0xKS5tYXRNdWwobWF0cml4KS5hczFEKCk7XG4gICAgfTtcbiAgICBPcHMubWF0cml4VGltZXNWZWN0b3IgPSBmdW5jdGlvbiAobWF0cml4LCB2KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYucmFuayA9PT0gMSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2Vjb25kIGlucHV0IG11c3QgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3RvcjogZmlyc3QgaW5wdXQgbXVzdCBiZSBhIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVsxXSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2l6ZSBvZiBmaXJzdCByYW5rIDEgaW5wdXQgXCIgKyB2LnNpemUgKyBcIiBcIiArXG4gICAgICAgICAgICBcIm11c3QgbWF0Y2ggaW5uZXIgZGltZW5zaW9uIG9mIHNlY29uZCByYW5rIDIgaW5wdXQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwic2hhcGUgXCIgKyBtYXRyaXguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gbWF0cml4Lm1hdE11bCh2LmFzMkQoLTEsIDEpKS5hczFEKCk7XG4gICAgfTtcbiAgICBPcHMuZG90UHJvZHVjdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodjEucmFuayA9PT0gMSAmJiB2Mi5yYW5rID09PSAxLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5zaXplID09PSB2Mi5zaXplLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IHNpemUgb2YgaW5wdXRzIChcIiArIHYxLnNpemUgKyBcIikgYW5kIChcIiArXG4gICAgICAgICAgICAodjIuc2l6ZSArIFwiKSBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHJldHVybiB2MS5hczJEKDEsIC0xKS5tYXRNdWwodjIuYXMyRCgtMSwgMSkpLmFzU2NhbGFyKCk7XG4gICAgfTtcbiAgICBPcHMub3V0ZXJQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIgK1xuICAgICAgICAgICAgKHYxLnJhbmsgKyBcIiBhbmQgXCIgKyB2Mi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHYxLmFzMkQoLTEsIDEpLm1hdE11bCh2Mi5hczJEKDEsIC0xKSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtYXRNdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwidmVjdG9yVGltZXNNYXRyaXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibWF0cml4VGltZXNWZWN0b3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiZG90UHJvZHVjdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJvdXRlclByb2R1Y3RcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdG11bC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgbWF0bXVsXzEgPSByZXF1aXJlKFwiLi9iYWNrZW5kcy90eXBlcy9tYXRtdWxcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIE5EQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXkoc2hhcGUsIGR0eXBlLCB2YWx1ZXMsIGRhdGFJZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IHZhbHVlcy5sZW5ndGgsIFwiQ29uc3RydWN0aW5nIG5kYXJyYXkgb2Ygc2hhcGUgKFwiICsgdGhpcy5zaXplICsgXCIpIHNob3VsZCBtYXRjaCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImxlbmd0aCBvZiB2YWx1ZXMgKFwiICsgdmFsdWVzLmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGUgfHwgJ2Zsb2F0MzInO1xuICAgICAgICB2YXIgZGltID0gdGhpcy5zaGFwZS5sZW5ndGg7XG4gICAgICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlcyA9IG5ldyBBcnJheShkaW0gLSAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlc1tkaW0gLSAyXSA9IHRoaXMuc2hhcGVbZGltIC0gMV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGltIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZXNbaV0gPSB0aGlzLnN0cmlkZXNbaSArIDFdICogdGhpcy5zaGFwZVtpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhSWQgPSBkYXRhSWQgIT0gbnVsbCA/IGRhdGFJZCA6IE5EQXJyYXkubmV4dERhdGFJZCsrO1xuICAgICAgICB0aGlzLmlkID0gTkRBcnJheS5uZXh0SWQrKztcbiAgICAgICAgdGhpcy5yYW5rVHlwZSA9ICh0aGlzLnJhbmsgPCA1ID8gdGhpcy5yYW5rLnRvU3RyaW5nKCkgOiAnaGlnaGVyJyk7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLm1hdGgucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYubWF0aC53cml0ZSh0aGlzLmRhdGFJZCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBOREFycmF5Lm9uZXMgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBvcHMub25lcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9wcy56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5vbmVzTGlrZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBvcHMub25lc0xpa2UoeCk7XG4gICAgfTtcbiAgICBOREFycmF5Lnplcm9zTGlrZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBvcHMuemVyb3NMaWtlKHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5saWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jbG9uZSh4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkubWFrZSA9IGZ1bmN0aW9uIChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOREFycmF5KHNoYXBlLCBkdHlwZSwgZGF0YS52YWx1ZXMsIGRhdGEuZGF0YUlkKTtcbiAgICB9O1xuICAgIE5EQXJyYXkuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gdm9pZCAwKSB7IG51bUNoYW5uZWxzID0gMzsgfVxuICAgICAgICByZXR1cm4gb3BzLmZyb21QaXhlbHMocGl4ZWxzLCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmQgPSBmdW5jdGlvbiAoc2hhcGUsIHJhbmRGdW5jdGlvbiwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5yYW5kKHNoYXBlLCByYW5kRnVuY3Rpb24sIGR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBvcHMucmFuZE5vcm1hbChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldiwgZHR5cGUsIHNlZWQpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gb3BzLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gb3BzLnJhbmRVbmlmb3JtKHNoYXBlLCBhLCBiLCBkdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5zcXVlZXplID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZSh1dGlsLnNxdWVlemVTaGFwZSh0aGlzLnNoYXBlLCBheGlzKS5uZXdTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5hczFEKCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczFEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzMkQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczNEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczREID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDIpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMl0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY2FzdCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTkRBcnJheS5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKGxvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2NzID0gWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3luYygpW2luZGV4XTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY3MgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobG9jcy5sZW5ndGggPT09IHRoaXMucmFuaywgXCJUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIChcIiArIGxvY3MubGVuZ3RoICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpXCIpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jcy5sZW5ndGggPiAwID8gbG9jc1tsb2NzLmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFscyA9IHRoaXMuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFsc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYubWF0aC53cml0ZSh0aGlzLmRhdGFJZCwgdmFscyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jcyA9IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldC5hcHBseSh0aGlzLCBsb2NzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY3MgPSBuZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBsb2NzW2ldID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlc1tpXSk7XG4gICAgICAgICAgICBpbmRleCAtPSBsb2NzW2ldICogdGhpcy5zdHJpZGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvY3NbbG9jcy5sZW5ndGggLSAxXSA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbG9jcztcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIHZhbHMgPSB0aGlzLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhbHMuZmlsbCh2YWx1ZSk7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLm1hdGgud3JpdGUodGhpcy5kYXRhSWQsIHZhbHMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3luYygpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWVzQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZW52aXJvbm1lbnRfMS5FTlYubWF0aC5yZWFkKHRoaXMuZGF0YUlkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kYXRhU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLm1hdGgucmVhZFN5bmModGhpcy5kYXRhSWQpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLm1hdGguZGlzcG9zZURhdGEodGhpcy5kYXRhSWQpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREFycmF5IGlzIGRpc3Bvc2VkLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdmbG9hdDMyJyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdpbnQzMicpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudG9Cb29sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1R5cGUoJ2Jvb2wnKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAobmV3U2hhcGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZXNoYXBlKHRoaXMsIG5ld1NoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnJlc2hhcGVBcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoeC5zaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHJlcHMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50aWxlKHRoaXMsIHJlcHMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdhdGhlcih0aGlzLCBpbmRpY2VzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1hdE11bCA9IGZ1bmN0aW9uIChiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikge1xuICAgICAgICBpZiAoYU9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYU9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYk9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1hdE11bCh0aGlzLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbik7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChiZWdpbiwgc2l6ZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNsaWNlKHRoaXMsIGJlZ2luLCBzaXplKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJldmVyc2UodGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvbmNhdCh0aGlzLCB4LCBheGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYmF0Y2hOb3JtYWxpemF0aW9uKHRoaXMsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY2xvbmUodGhpcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sb2dTdW1FeHAgPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nU3VtRXhwKHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdW0odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubWVhbiA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tZWFuKHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW4odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heCh0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hcmdNaW4gPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXJnTWluKHRoaXMsIGF4aXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXJnTWF4ID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFyZ01heCh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFyZ01heEVxdWFscyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXJnTWF4RXF1YWxzKHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hZGQodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hZGRTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFkZFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3ViKHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuc3ViU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdWJTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAoZXhwKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucG93KHRoaXMsIGV4cCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5wb3dTdHJpY3QgPSBmdW5jdGlvbiAoZXhwKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucG93U3RyaWN0KHRoaXMsIGV4cCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm11bCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm11bFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubXVsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5kaXYodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kaXZTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmRpdlN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1pbmltdW0odGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5taW5pbXVtU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW5pbXVtU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4aW11bSh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1heGltdW1TdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heGltdW1TdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAocGVybSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnRyYW5zcG9zZSh0aGlzLCBwZXJtKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ub3RFcXVhbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm5vdEVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ub3RFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3ModGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sZXNzU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVxdWFsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVxdWFsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubGVzc0VxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzRXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sZXNzRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3NFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXIodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyRXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXJFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ2ljYWxBbmQodGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sb2dpY2FsT3IgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ2ljYWxPcih0aGlzLCB4KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLndoZXJlKGNvbmRpdGlvbiwgdGhpcywgeCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubmVnKHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jZWlsKHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZmxvb3IodGhpcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXhwKHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZyh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3FydCh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zcXVhcmUodGhpcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWJzKHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNsaXAodGhpcywgbWluLCBtYXgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZWx1KHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVsdSh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNlbHUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2VsdSh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmxlYWt5UmVsdSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMjsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlYWt5UmVsdSh0aGlzLCBhbHBoYSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5wcmVsdSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnByZWx1KHRoaXMsIGFscGhhKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2lnbW9pZCh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zaW4odGhpcyk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29zKHRoaXMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnRhbih0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXNpbih0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWNvcyh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXRhbih0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNpbmggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2luaCh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29zaCh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudGFuaCh0aGlzKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdGVwKHRoaXMsIGFscGhhKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNvZnRtYXggPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGlmIChkaW0gPT09IHZvaWQgMCkgeyBkaW0gPSAtMTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNvZnRtYXgodGhpcywgZGltKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyID0gZnVuY3Rpb24gKG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5pbWFnZS5yZXNpemVCaWxpbmVhcih0aGlzLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuY29udjFkID0gZnVuY3Rpb24gKGZpbHRlciwgYmlhcywgc3RyaWRlLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvbnYxZCh0aGlzLCBmaWx0ZXIsIGJpYXMsIHN0cmlkZSwgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKGZpbHRlciwgYmlhcywgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MmQodGhpcywgZmlsdGVyLCBiaWFzLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2UgPSBmdW5jdGlvbiAoZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MmRUcmFuc3Bvc2UodGhpcywgZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEID0gZnVuY3Rpb24gKGZpbHRlciwgc3RyaWRlcywgcGFkLCByYXRlcywgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChyYXRlcyA9PT0gdm9pZCAwKSB7IHJhdGVzID0gWzEsIDFdOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZGVwdGh3aXNlQ29udjJEKHRoaXMsIGZpbHRlciwgc3RyaWRlcywgcGFkLCByYXRlcywgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hdmdQb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tYXhQb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLm1pblBvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW5Qb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkubmV4dElkID0gMDtcbiAgICBOREFycmF5Lm5leHREYXRhSWQgPSAwO1xuICAgIHJldHVybiBOREFycmF5O1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheSA9IE5EQXJyYXk7XG52YXIgU2NhbGFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTY2FsYXIubmV3ID0gZnVuY3Rpb24gKHZhbHVlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW3ZhbHVlXTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIoW10sIGR0eXBlLCB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYWxhcjtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG52YXIgQXJyYXkxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5MUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkxRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcnJheTFELm5ldyA9IGZ1bmN0aW9uICh2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VvZlR5cGVkQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGluZmVycmVkU2hhcGUubGVuZ3RoID09PSAxLCBcIkVycm9yIGNvbnN0cnVjdGluZyBBcnJheTFELiBTaGFwZSBvZiB2YWx1ZXMgXCIgKyBpbmZlcnJlZFNoYXBlICsgXCIgaXMgXCIgK1xuICAgICAgICAgICAgICAgIFwibm90IDEgZGltZW5zaW9uYWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkxRChbdmFsdWVzLmxlbmd0aF0sIGR0eXBlLCB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5MUQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkxRCA9IEFycmF5MUQ7XG52YXIgQXJyYXkyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5MkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkyRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcnJheTJELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTJELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUsIGR0eXBlLCB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5MkQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkyRCA9IEFycmF5MkQ7XG52YXIgQXJyYXkzRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5M0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkzRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcnJheTNELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTNELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5M0Qoc2hhcGUsIGR0eXBlLCB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5M0Q7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkzRCA9IEFycmF5M0Q7XG52YXIgQXJyYXk0RCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5NEQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXk0RCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcnJheTRELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTRELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5NEQoc2hhcGUsIGR0eXBlLCB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5NEQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXk0RCA9IEFycmF5NEQ7XG52YXIgVmFyaWFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYXJpYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYXJpYWJsZShpbml0aWFsVmFsdWUsIHRyYWluYWJsZSwgbmFtZSkge1xuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsVmFsdWUuc2hhcGUsIGluaXRpYWxWYWx1ZS5kdHlwZSwgbnVsbCwgaW5pdGlhbFZhbHVlLmRhdGFJZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHJhaW5hYmxlID0gdHJhaW5hYmxlO1xuICAgICAgICBpbml0aWFsVmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKF90aGlzLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IFZhcmlhYmxlLm5leHRWYXJJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgVmFyaWFibGUubmV4dFZhcklkKys7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYubWF0aC5yZWdpc3RlclZhcmlhYmxlKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWYXJpYWJsZS52YXJpYWJsZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUsIHRyYWluYWJsZSwgbmFtZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKHRyYWluYWJsZSA9PT0gdm9pZCAwKSB7IHRyYWluYWJsZSA9IHRydWU7IH1cbiAgICAgICAgaWYgKGR0eXBlICE9IG51bGwgJiYgZHR5cGUgIT09IGluaXRpYWxWYWx1ZS5kdHlwZSkge1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlLmFzVHlwZShkdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZShpbml0aWFsVmFsdWUsIHRyYWluYWJsZSwgbmFtZSk7XG4gICAgfTtcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZS5kdHlwZSAhPT0gdGhpcy5kdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIgKyBuZXdWYWx1ZS5kdHlwZSArIFwiKSBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIChcInByZXZpb3VzIHZhbHVlIChcIiArIHRoaXMuZHR5cGUgKyBcIikgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKG5ld1ZhbHVlLnNoYXBlLCB0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIgKyBuZXdWYWx1ZS5zaGFwZSArIFwiKSBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIChcInByZXZpb3VzIHZhbHVlIChcIiArIHRoaXMuc2hhcGUgKyBcIikgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYubWF0aC5kaXNwb3NlRGF0YSh0aGlzLmRhdGFJZCk7XG4gICAgICAgIHRoaXMuZGF0YUlkID0gbmV3VmFsdWUuZGF0YUlkO1xuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5tYXRoLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICBuZXdWYWx1ZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBWYXJpYWJsZS5uZXh0VmFySWQgPSAwO1xuICAgIHJldHVybiBWYXJpYWJsZTtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5WYXJpYWJsZSA9IFZhcmlhYmxlO1xudmFyIHZhcmlhYmxlID0gVmFyaWFibGUudmFyaWFibGU7XG5leHBvcnRzLnZhcmlhYmxlID0gdmFyaWFibGU7XG5mdW5jdGlvbiBpbnN0YW5jZW9mVHlwZWRBcnJheShhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBub0NvbnZlcnNpb25OZWVkZWQoYSwgZHR5cGUpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiYgZHR5cGUgPT09ICdmbG9hdDMyJykgfHxcbiAgICAgICAgKGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICYmIGR0eXBlID09PSAnaW50MzInKSB8fFxuICAgICAgICAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgZHR5cGUgPT09ICdib29sJyk7XG59XG5mdW5jdGlvbiB0b1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAobm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgYSA9IHV0aWwuZmxhdHRlbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWwuY29weVR5cGVkQXJyYXkoYSwgZHR5cGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmRhcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMubm9ybSA9IGZ1bmN0aW9uICh4LCBvcmQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChvcmQgPT09IHZvaWQgMCkgeyBvcmQgPSAnZXVjbGlkZWFuJzsgfVxuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5vcm0gPSBub3JtSW50ZXJuYWwoeCwgb3JkLCBheGlzKTtcbiAgICAgICAgdmFyIGtlZXBEaW1zU2hhcGUgPSBub3JtLnNoYXBlO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShub3JtLnNoYXBlLCBheGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybS5yZXNoYXBlKGtlZXBEaW1zU2hhcGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibm9ybVwiLCBudWxsKTtcbiAgICByZXR1cm4gT3BzO1xufSgpKTtcbmV4cG9ydHMuT3BzID0gT3BzO1xuZnVuY3Rpb24gbm9ybUludGVybmFsKHgsIHAsIGF4aXMpIHtcbiAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4geC5hYnMoKTtcbiAgICB9XG4gICAgaWYgKHgucmFuayAhPT0gMSAmJiBheGlzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub3JtSW50ZXJuYWwoeC5yZXNoYXBlKFstMV0pLCBwLCBheGlzKTtcbiAgICB9XG4gICAgaWYgKHgucmFuayA9PT0gMSB8fCB0eXBlb2YgYXhpcyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgYXhpcyBpbnN0YW5jZW9mIEFycmF5ICYmIGF4aXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5tYXgoYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkubWluKGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZXVjbGlkZWFuJyB8fCBwID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5wb3cobmRhcnJheV8xLlNjYWxhci5uZXcoMiwgJ2ludDMyJykpLnN1bShheGlzKS5zcXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiICsgcCk7XG4gICAgfVxuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQXJyYXkgJiYgYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLnN1bShheGlzWzBdKS5tYXgoYXhpc1sxXSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXNbMV0pLm1heChheGlzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpc1sxXSkubWluKGF4aXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZnJvJyB8fCBwID09PSAnZXVjbGlkZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHgucG93KG5kYXJyYXlfMS5TY2FsYXIubmV3KDIsICdpbnQzMicpKS5zdW0oYXhpcykuc3FydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIiArIHApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIGF4aXM6IFwiICsgYXhpcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFycmF5X29wcyA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBiYXRjaG5vcm1fb3BzID0gcmVxdWlyZShcIi4vYmF0Y2hub3JtXCIpO1xudmFyIGJpbmFyeV9vcHMgPSByZXF1aXJlKFwiLi9iaW5hcnlfb3BzXCIpO1xudmFyIGNvbXBhcmVfb3BzID0gcmVxdWlyZShcIi4vY29tcGFyZVwiKTtcbnZhciBjb25jYXRfb3BzID0gcmVxdWlyZShcIi4vY29uY2F0XCIpO1xudmFyIGNvbnZfb3BzID0gcmVxdWlyZShcIi4vY29udlwiKTtcbnZhciBpbWFnZV9vcHMgPSByZXF1aXJlKFwiLi9pbWFnZV9vcHNcIik7XG52YXIgbG9naWNhbF9vcHMgPSByZXF1aXJlKFwiLi9sb2dpY2FsX29wc1wiKTtcbnZhciBsc3RtX29wcyA9IHJlcXVpcmUoXCIuL2xzdG1cIik7XG52YXIgbWF0bXVsX29wcyA9IHJlcXVpcmUoXCIuL21hdG11bFwiKTtcbnZhciBub3JtX29wcyA9IHJlcXVpcmUoXCIuL25vcm1cIik7XG52YXIgcG9vbF9vcHMgPSByZXF1aXJlKFwiLi9wb29sXCIpO1xudmFyIHJlZHVjdGlvbl9vcHMgPSByZXF1aXJlKFwiLi9yZWR1Y3Rpb25fb3BzXCIpO1xudmFyIHJldmVyc2Vfb3BzID0gcmVxdWlyZShcIi4vcmV2ZXJzZVwiKTtcbnZhciBzbGljZV9vcHMgPSByZXF1aXJlKFwiLi9zbGljZVwiKTtcbnZhciBzb2Z0bWF4X29wcyA9IHJlcXVpcmUoXCIuL3NvZnRtYXhcIik7XG52YXIgdHJhbnNwb3NlX29wcyA9IHJlcXVpcmUoXCIuL3RyYW5zcG9zZVwiKTtcbnZhciB1bmFyeV9vcHMgPSByZXF1aXJlKFwiLi91bmFyeV9vcHNcIik7XG5leHBvcnRzLmJhdGNoTm9ybWFsaXphdGlvbiA9IGJhdGNobm9ybV9vcHMuT3BzLmJhdGNoTm9ybWFsaXphdGlvbjtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uMkQgPSBiYXRjaG5vcm1fb3BzLk9wcy5iYXRjaE5vcm1hbGl6YXRpb24yRDtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uM0QgPSBiYXRjaG5vcm1fb3BzLk9wcy5iYXRjaE5vcm1hbGl6YXRpb24zRDtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uNEQgPSBiYXRjaG5vcm1fb3BzLk9wcy5iYXRjaE5vcm1hbGl6YXRpb240RDtcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0X29wcy5PcHMuY29uY2F0O1xuZXhwb3J0cy5jb25jYXQxRCA9IGNvbmNhdF9vcHMuT3BzLmNvbmNhdDFEO1xuZXhwb3J0cy5jb25jYXQyRCA9IGNvbmNhdF9vcHMuT3BzLmNvbmNhdDJEO1xuZXhwb3J0cy5jb25jYXQzRCA9IGNvbmNhdF9vcHMuT3BzLmNvbmNhdDNEO1xuZXhwb3J0cy5jb25jYXQ0RCA9IGNvbmNhdF9vcHMuT3BzLmNvbmNhdDREO1xuZXhwb3J0cy5jb252MWQgPSBjb252X29wcy5PcHMuY29udjFkO1xuZXhwb3J0cy5jb252MmQgPSBjb252X29wcy5PcHMuY29udjJkO1xuZXhwb3J0cy5jb252MmRUcmFuc3Bvc2UgPSBjb252X29wcy5PcHMuY29udjJkVHJhbnNwb3NlO1xuZXhwb3J0cy5kZXB0aHdpc2VDb252MkQgPSBjb252X29wcy5PcHMuZGVwdGh3aXNlQ29udjJEO1xuZXhwb3J0cy5kb3RQcm9kdWN0ID0gbWF0bXVsX29wcy5PcHMuZG90UHJvZHVjdDtcbmV4cG9ydHMubWF0TXVsID0gbWF0bXVsX29wcy5PcHMubWF0TXVsO1xuZXhwb3J0cy5tYXRyaXhUaW1lc1ZlY3RvciA9IG1hdG11bF9vcHMuT3BzLm1hdHJpeFRpbWVzVmVjdG9yO1xuZXhwb3J0cy5vdXRlclByb2R1Y3QgPSBtYXRtdWxfb3BzLk9wcy5vdXRlclByb2R1Y3Q7XG5leHBvcnRzLnZlY3RvclRpbWVzTWF0cml4ID0gbWF0bXVsX29wcy5PcHMudmVjdG9yVGltZXNNYXRyaXg7XG5leHBvcnRzLmF2Z1Bvb2wgPSBwb29sX29wcy5PcHMuYXZnUG9vbDtcbmV4cG9ydHMubWF4UG9vbCA9IHBvb2xfb3BzLk9wcy5tYXhQb29sO1xuZXhwb3J0cy5taW5Qb29sID0gcG9vbF9vcHMuT3BzLm1pblBvb2w7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZV9vcHMuT3BzLnRyYW5zcG9zZTtcbmV4cG9ydHMucmV2ZXJzZSA9IHJldmVyc2Vfb3BzLk9wcy5yZXZlcnNlO1xuZXhwb3J0cy5yZXZlcnNlMUQgPSByZXZlcnNlX29wcy5PcHMucmV2ZXJzZTFEO1xuZXhwb3J0cy5yZXZlcnNlMkQgPSByZXZlcnNlX29wcy5PcHMucmV2ZXJzZTJEO1xuZXhwb3J0cy5yZXZlcnNlM0QgPSByZXZlcnNlX29wcy5PcHMucmV2ZXJzZTNEO1xuZXhwb3J0cy5yZXZlcnNlNEQgPSByZXZlcnNlX29wcy5PcHMucmV2ZXJzZTREO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlX29wcy5PcHMuc2xpY2U7XG5leHBvcnRzLnNsaWNlMUQgPSBzbGljZV9vcHMuT3BzLnNsaWNlMUQ7XG5leHBvcnRzLnNsaWNlMkQgPSBzbGljZV9vcHMuT3BzLnNsaWNlMkQ7XG5leHBvcnRzLnNsaWNlM0QgPSBzbGljZV9vcHMuT3BzLnNsaWNlM0Q7XG5leHBvcnRzLnNsaWNlNEQgPSBzbGljZV9vcHMuT3BzLnNsaWNlNEQ7XG5leHBvcnRzLmFyZ01heCA9IHJlZHVjdGlvbl9vcHMuT3BzLmFyZ01heDtcbmV4cG9ydHMuYXJnTWF4RXF1YWxzID0gcmVkdWN0aW9uX29wcy5PcHMuYXJnTWF4RXF1YWxzO1xuZXhwb3J0cy5hcmdNaW4gPSByZWR1Y3Rpb25fb3BzLk9wcy5hcmdNaW47XG5leHBvcnRzLmxvZ1N1bUV4cCA9IHJlZHVjdGlvbl9vcHMuT3BzLmxvZ1N1bUV4cDtcbmV4cG9ydHMubWF4ID0gcmVkdWN0aW9uX29wcy5PcHMubWF4O1xuZXhwb3J0cy5tZWFuID0gcmVkdWN0aW9uX29wcy5PcHMubWVhbjtcbmV4cG9ydHMubWluID0gcmVkdWN0aW9uX29wcy5PcHMubWluO1xuZXhwb3J0cy5tb21lbnRzID0gcmVkdWN0aW9uX29wcy5PcHMubW9tZW50cztcbmV4cG9ydHMuc3VtID0gcmVkdWN0aW9uX29wcy5PcHMuc3VtO1xuZXhwb3J0cy5lcXVhbCA9IGNvbXBhcmVfb3BzLk9wcy5lcXVhbDtcbmV4cG9ydHMuZXF1YWxTdHJpY3QgPSBjb21wYXJlX29wcy5PcHMuZXF1YWxTdHJpY3Q7XG5leHBvcnRzLmdyZWF0ZXIgPSBjb21wYXJlX29wcy5PcHMuZ3JlYXRlcjtcbmV4cG9ydHMuZ3JlYXRlclN0cmljdCA9IGNvbXBhcmVfb3BzLk9wcy5ncmVhdGVyU3RyaWN0O1xuZXhwb3J0cy5ncmVhdGVyRXF1YWwgPSBjb21wYXJlX29wcy5PcHMuZ3JlYXRlckVxdWFsO1xuZXhwb3J0cy5ncmVhdGVyRXF1YWxTdHJpY3QgPSBjb21wYXJlX29wcy5PcHMuZ3JlYXRlckVxdWFsU3RyaWN0O1xuZXhwb3J0cy5sZXNzID0gY29tcGFyZV9vcHMuT3BzLmxlc3M7XG5leHBvcnRzLmxlc3NTdHJpY3QgPSBjb21wYXJlX29wcy5PcHMubGVzc1N0cmljdDtcbmV4cG9ydHMubGVzc0VxdWFsID0gY29tcGFyZV9vcHMuT3BzLmxlc3NFcXVhbDtcbmV4cG9ydHMubGVzc0VxdWFsU3RyaWN0ID0gY29tcGFyZV9vcHMuT3BzLmxlc3NFcXVhbFN0cmljdDtcbmV4cG9ydHMubm90RXF1YWwgPSBjb21wYXJlX29wcy5PcHMubm90RXF1YWw7XG5leHBvcnRzLm5vdEVxdWFsU3RyaWN0ID0gY29tcGFyZV9vcHMuT3BzLm5vdEVxdWFsU3RyaWN0O1xuZXhwb3J0cy5sb2dpY2FsQW5kID0gbG9naWNhbF9vcHMuT3BzLmxvZ2ljYWxBbmQ7XG5leHBvcnRzLmxvZ2ljYWxPciA9IGxvZ2ljYWxfb3BzLk9wcy5sb2dpY2FsT3I7XG5leHBvcnRzLndoZXJlID0gbG9naWNhbF9vcHMuT3BzLndoZXJlO1xuZXhwb3J0cy5hYnMgPSB1bmFyeV9vcHMuT3BzLmFicztcbmV4cG9ydHMuYWNvcyA9IHVuYXJ5X29wcy5PcHMuYWNvcztcbmV4cG9ydHMuYXNpbiA9IHVuYXJ5X29wcy5PcHMuYXNpbjtcbmV4cG9ydHMuYXRhbiA9IHVuYXJ5X29wcy5PcHMuYXRhbjtcbmV4cG9ydHMuY2VpbCA9IHVuYXJ5X29wcy5PcHMuY2VpbDtcbmV4cG9ydHMuY2xpcCA9IHVuYXJ5X29wcy5PcHMuY2xpcDtcbmV4cG9ydHMuY29zID0gdW5hcnlfb3BzLk9wcy5jb3M7XG5leHBvcnRzLmNvc2ggPSB1bmFyeV9vcHMuT3BzLmNvc2g7XG5leHBvcnRzLmVsdSA9IHVuYXJ5X29wcy5PcHMuZWx1O1xuZXhwb3J0cy5leHAgPSB1bmFyeV9vcHMuT3BzLmV4cDtcbmV4cG9ydHMuZmxvb3IgPSB1bmFyeV9vcHMuT3BzLmZsb29yO1xuZXhwb3J0cy5sZWFreVJlbHUgPSB1bmFyeV9vcHMuT3BzLmxlYWt5UmVsdTtcbmV4cG9ydHMubG9nID0gdW5hcnlfb3BzLk9wcy5sb2c7XG5leHBvcnRzLm5lZyA9IHVuYXJ5X29wcy5PcHMubmVnO1xuZXhwb3J0cy5wcmVsdSA9IHVuYXJ5X29wcy5PcHMucHJlbHU7XG5leHBvcnRzLnJlbHUgPSB1bmFyeV9vcHMuT3BzLnJlbHU7XG5leHBvcnRzLnNlbHUgPSB1bmFyeV9vcHMuT3BzLnNlbHU7XG5leHBvcnRzLnNpZ21vaWQgPSB1bmFyeV9vcHMuT3BzLnNpZ21vaWQ7XG5leHBvcnRzLnNpbiA9IHVuYXJ5X29wcy5PcHMuc2luO1xuZXhwb3J0cy5zaW5oID0gdW5hcnlfb3BzLk9wcy5zaW5oO1xuZXhwb3J0cy5zcXJ0ID0gdW5hcnlfb3BzLk9wcy5zcXJ0O1xuZXhwb3J0cy5zcXVhcmUgPSB1bmFyeV9vcHMuT3BzLnNxdWFyZTtcbmV4cG9ydHMuc3RlcCA9IHVuYXJ5X29wcy5PcHMuc3RlcDtcbmV4cG9ydHMudGFuID0gdW5hcnlfb3BzLk9wcy50YW47XG5leHBvcnRzLnRhbmggPSB1bmFyeV9vcHMuT3BzLnRhbmg7XG5leHBvcnRzLmFkZCA9IGJpbmFyeV9vcHMuT3BzLmFkZDtcbmV4cG9ydHMuYWRkU3RyaWN0ID0gYmluYXJ5X29wcy5PcHMuYWRkU3RyaWN0O1xuZXhwb3J0cy5kaXYgPSBiaW5hcnlfb3BzLk9wcy5kaXY7XG5leHBvcnRzLmRpdlN0cmljdCA9IGJpbmFyeV9vcHMuT3BzLmRpdlN0cmljdDtcbmV4cG9ydHMubWF4aW11bSA9IGJpbmFyeV9vcHMuT3BzLm1heGltdW07XG5leHBvcnRzLm1heGltdW1TdHJpY3QgPSBiaW5hcnlfb3BzLk9wcy5tYXhpbXVtU3RyaWN0O1xuZXhwb3J0cy5taW5pbXVtID0gYmluYXJ5X29wcy5PcHMubWluaW11bTtcbmV4cG9ydHMubWluaW11bVN0cmljdCA9IGJpbmFyeV9vcHMuT3BzLm1pbmltdW1TdHJpY3Q7XG5leHBvcnRzLm11bCA9IGJpbmFyeV9vcHMuT3BzLm11bDtcbmV4cG9ydHMubXVsU3RyaWN0ID0gYmluYXJ5X29wcy5PcHMubXVsU3RyaWN0O1xuZXhwb3J0cy5wb3cgPSBiaW5hcnlfb3BzLk9wcy5wb3c7XG5leHBvcnRzLnBvd1N0cmljdCA9IGJpbmFyeV9vcHMuT3BzLnBvd1N0cmljdDtcbmV4cG9ydHMuc3ViID0gYmluYXJ5X29wcy5PcHMuc3ViO1xuZXhwb3J0cy5zdWJTdHJpY3QgPSBiaW5hcnlfb3BzLk9wcy5zdWJTdHJpY3Q7XG5leHBvcnRzLm5vcm0gPSBub3JtX29wcy5PcHMubm9ybTtcbmV4cG9ydHMuY2FzdCA9IGFycmF5X29wcy5PcHMuY2FzdDtcbmV4cG9ydHMuY2xvbmUgPSBhcnJheV9vcHMuT3BzLmNsb25lO1xuZXhwb3J0cy5mcm9tUGl4ZWxzID0gYXJyYXlfb3BzLk9wcy5mcm9tUGl4ZWxzO1xuZXhwb3J0cy5vbmVzID0gYXJyYXlfb3BzLk9wcy5vbmVzO1xuZXhwb3J0cy5vbmVzTGlrZSA9IGFycmF5X29wcy5PcHMub25lc0xpa2U7XG5leHBvcnRzLnplcm9zID0gYXJyYXlfb3BzLk9wcy56ZXJvcztcbmV4cG9ydHMuemVyb3NMaWtlID0gYXJyYXlfb3BzLk9wcy56ZXJvc0xpa2U7XG5leHBvcnRzLnJhbmQgPSBhcnJheV9vcHMuT3BzLnJhbmQ7XG5leHBvcnRzLnJhbmROb3JtYWwgPSBhcnJheV9vcHMuT3BzLnJhbmROb3JtYWw7XG5leHBvcnRzLnRydW5jYXRlZE5vcm1hbCA9IGFycmF5X29wcy5PcHMudHJ1bmNhdGVkTm9ybWFsO1xuZXhwb3J0cy5yYW5kVW5pZm9ybSA9IGFycmF5X29wcy5PcHMucmFuZFVuaWZvcm07XG5leHBvcnRzLnJlc2hhcGUgPSBhcnJheV9vcHMuT3BzLnJlc2hhcGU7XG5leHBvcnRzLnRpbGUgPSBhcnJheV9vcHMuT3BzLnRpbGU7XG5leHBvcnRzLmdhdGhlciA9IGFycmF5X29wcy5PcHMuZ2F0aGVyO1xuZXhwb3J0cy5tdWx0aW5vbWlhbCA9IGFycmF5X29wcy5PcHMubXVsdGlub21pYWw7XG5leHBvcnRzLm9uZUhvdCA9IGFycmF5X29wcy5PcHMub25lSG90O1xuZXhwb3J0cy5wYWQxRCA9IGFycmF5X29wcy5PcHMucGFkMUQ7XG5leHBvcnRzLnBhZDJEID0gYXJyYXlfb3BzLk9wcy5wYWQyRDtcbmV4cG9ydHMuYmFzaWNMU1RNQ2VsbCA9IGxzdG1fb3BzLk9wcy5iYXNpY0xTVE1DZWxsO1xuZXhwb3J0cy5tdWx0aVJOTkNlbGwgPSBsc3RtX29wcy5PcHMubXVsdGlSTk5DZWxsO1xuZXhwb3J0cy5zb2Z0bWF4ID0gc29mdG1heF9vcHMuT3BzLnNvZnRtYXg7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5bbmRhcnJheV8xLk5EQXJyYXksIHR5cGVzXzEuUmFuaywgbmRhcnJheV8xLkFycmF5M0QsIG5kYXJyYXlfMS5BcnJheTREXTtcbmV4cG9ydHMubG9zc2VzID0ge1xuICAgIHNvZnRtYXhDcm9zc0VudHJvcHk6IHNvZnRtYXhfb3BzLk9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5XG59O1xuZXhwb3J0cy5pbWFnZSA9IHtcbiAgICByZXNpemVCaWxpbmVhcjogaW1hZ2Vfb3BzLk9wcy5yZXNpemVCaWxpbmVhclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9ncmFwaC9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uLy4uL2dyYXBoL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgaWYgKHNwZWNpZmllZFZhcmlhYmxlTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgPSBzcGVjaWZpZWRWYXJpYWJsZUxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmUgPSBlbnZpcm9ubWVudF8xLkVOVi5tYXRoLmtlZXAobmRhcnJheV8xLlNjYWxhci5uZXcoMSkpO1xuICAgIH1cbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLm1pbmltaXplID0gZnVuY3Rpb24gKGYsIHJldHVybkNvc3QsIHZhckxpc3QpIHtcbiAgICAgICAgaWYgKHJldHVybkNvc3QgPT09IHZvaWQgMCkgeyByZXR1cm5Db3N0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb21wdXRlR3JhZGllbnRzKGYsIHZhckxpc3QpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkaWVudHMgPSBfYS5ncmFkaWVudHM7XG4gICAgICAgIHRoaXMuYXBwbHlHcmFkaWVudHMoZ3JhZGllbnRzKTtcbiAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXMoZ3JhZGllbnRzKTtcbiAgICAgICAgdmFyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gZ3JhZGllbnRzW3Zhck5hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIGlmIChyZXR1cm5Db3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5jb21wdXRlR3JhZGllbnRzID0gZnVuY3Rpb24gKGYsIHZhckxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLm1hdGgudmFyaWFibGVHcmFkaWVudHMoZiwgdmFyTGlzdCk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVOb2RlcyA9IHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9PSBudWxsID9cbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5nZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQocnVudGltZS5ub2RlcykgOlxuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzO1xuICAgICAgICBpZiAoYmF0Y2hTaXplICE9PSB0aGlzLnByZXZCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNHcmFwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jR3JhcGguZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5jR3JhcGggPSBtYXRoLmtlZXAobmRhcnJheV8xLlNjYWxhci5uZXcoLXRoaXMubGVhcm5pbmdSYXRlIC8gYmF0Y2hTaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbWF0aC5rZWVwKG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSkpOyB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJFeGFtcGxlID0gZnVuY3Rpb24gKG1hdGgsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBncmFkaWVudEFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkR3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChtYXRoLmFkZChncmFkaWVudCwgYWNjdW11bGF0ZWRHcmFkaWVudCkpKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY0dyYXBoLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uZS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9wdGltaXplcjtcbn0oKSk7XG5leHBvcnRzLk9wdGltaXplciA9IE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uLy4uL2dyYXBoL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL25kYXJyYXlcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgU0dET3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU0dET3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNHRE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5zZXRMZWFybmluZ1JhdGUobGVhcm5pbmdSYXRlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtYXRoID0gZW52aXJvbm1lbnRfMS5FTlYubWF0aDtcbiAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXModmFyaWFibGVHcmFkaWVudHMpO1xuICAgICAgICB2YXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJOYW1lXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGgucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJOYW1lXTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRoLmFkZChtYXRoLm11bHRpcGx5KF90aGlzLmMsIGdyYWRpZW50KSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuY0dyYXBoLCBncmFkaWVudCwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGUgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBpZiAodGhpcy5jICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jID0gZW52aXJvbm1lbnRfMS5FTlYubWF0aC5rZWVwKG5kYXJyYXlfMS5TY2FsYXIubmV3KC1sZWFybmluZ1JhdGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBTR0RPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBTR0RPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZ2Rfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArIHg0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBtYXhQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgZ3JhZGllbnRzID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPcHMubWF4UG9vbEJhY2twcm9wKGR5LCB4NEQsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdNYXhQb29sJywgeyBpbnB1dHM6IHsgeDogeDREIH0sIGFyZ3M6IHsgY29udkluZm86IGNvbnZJbmZvIH0gfSwgZ3JhZGllbnRzKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBPcHMubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCBpbnB1dCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gZHkucmFuaywgXCJSYW5rIG9mIGlucHV0IChcIiArIGlucHV0LnJhbmsgKyBcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpXCIpO1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChkeTRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoaW5wdXQ0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdNYXhQb29sQmFja3Byb3AnLCB7IGlucHV0czogeyBkeTogZHk0RCwgeDogaW5wdXQ0RCB9LCBhcmdzOiB7IGNvbnZJbmZvOiBjb252SW5mbyB9IH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5taW5Qb29sID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1pblBvb2w6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICsgaW5wdXQ0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBtaW5Qb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdNaW5Qb29sJywgeyBpbnB1dHM6IHsgeDogaW5wdXQ0RCB9LCBhcmdzOiB7IGNvbnZJbmZvOiBjb252SW5mbyB9IH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gYXZnUG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlUG9vbDJESW5mbyh4NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciBncmFkaWVudHMgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9wcy5hdmdQb29sQmFja3Byb3AoZHksIHg0RCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0F2Z1Bvb2wnLCB7IGlucHV0czogeyB4OiB4NEQgfSwgYXJnczogeyBjb252SW5mbzogY29udkluZm8gfSB9LCBncmFkaWVudHMpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gZHkucmFuaywgXCJSYW5rIG9mIGlucHV0IChcIiArIGlucHV0LnJhbmsgKyBcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpXCIpO1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChkeTRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoaW5wdXQ0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQXZnUG9vbEJhY2twcm9wJywgeyBpbnB1dHM6IHsgZHk6IGR5NEQsIHg6IGlucHV0NEQgfSwgYXJnczogeyBjb252SW5mbzogY29udkluZm8gfSB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtYXhQb29sXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm1heFBvb2xCYWNrcHJvcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtaW5Qb29sXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImF2Z1Bvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYXZnUG9vbEJhY2twcm9wXCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciBNUFJhbmRHYXVzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVBSYW5kR2F1c3MobWVhbiwgc3RkRGV2aWF0aW9uLCBkdHlwZSwgdHJ1bmNhdGVkLCBzZWVkKSB7XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkRGV2ID0gc3RkRGV2aWF0aW9uO1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGU7XG4gICAgICAgIHRoaXMubmV4dFZhbCA9IE5hTjtcbiAgICAgICAgdGhpcy50cnVuY2F0ZWQgPSB0cnVuY2F0ZWQ7XG4gICAgICAgIGlmICh0aGlzLnRydW5jYXRlZCkge1xuICAgICAgICAgICAgdGhpcy51cHBlciA9IHRoaXMubWVhbiArIHRoaXMuc3RkRGV2ICogMjtcbiAgICAgICAgICAgIHRoaXMubG93ZXIgPSB0aGlzLm1lYW4gLSB0aGlzLnN0ZERldiAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWRWYWx1ZSA9IHNlZWQgPyBzZWVkIDogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdGhpcy5yYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBNUFJhbmRHYXVzcy5wcm90b3R5cGUubmV4dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzTmFOKHRoaXMubmV4dFZhbCkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubmV4dFZhbDtcbiAgICAgICAgICAgIHRoaXMubmV4dFZhbCA9IE5hTjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0WCwgcmVzdWx0WTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgdjEgPSB2b2lkIDAsIHYyID0gdm9pZCAwLCBzID0gdm9pZCAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHYxID0gMiAqIHRoaXMucmFuZG9tKCkgLSAxO1xuICAgICAgICAgICAgICAgIHYyID0gMiAqIHRoaXMucmFuZG9tKCkgLSAxO1xuICAgICAgICAgICAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSB8fCBzID09PSAwKTtcbiAgICAgICAgICAgIHZhciBtdWwgPSBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKHMpIC8gcyk7XG4gICAgICAgICAgICByZXN1bHRYID0gdGhpcy5tZWFuICsgdGhpcy5zdGREZXYgKiB2MSAqIG11bDtcbiAgICAgICAgICAgIHJlc3VsdFkgPSB0aGlzLm1lYW4gKyB0aGlzLnN0ZERldiAqIHYyICogbXVsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRydW5jYXRlZCB8fCB0aGlzLmlzVmFsaWRUcnVuY2F0ZWQocmVzdWx0WCkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJ1bmNhdGVkIHx8IHRoaXMuaXNWYWxpZFRydW5jYXRlZChyZXN1bHRZKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0VmFsID0gdGhpcy5jb252ZXJ0VmFsdWUocmVzdWx0WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHJlc3VsdFgpO1xuICAgIH07XG4gICAgTVBSYW5kR2F1c3MucHJvdG90eXBlLmNvbnZlcnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kdHlwZSA9PSBudWxsIHx8IHRoaXMuZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9O1xuICAgIE1QUmFuZEdhdXNzLnByb3RvdHlwZS5pc1ZhbGlkVHJ1bmNhdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnVwcGVyICYmIHZhbHVlID49IHRoaXMubG93ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gTVBSYW5kR2F1c3M7XG59KCkpO1xuZXhwb3J0cy5NUFJhbmRHYXVzcyA9IE1QUmFuZEdhdXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFSQUxMRUxJWkVfVEhSRVNIT0xEID0gMzA7XG5mdW5jdGlvbiBjb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKSB7XG4gICAgaWYgKGluU2l6ZSA8PSBleHBvcnRzLlBBUkFMTEVMSVpFX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm4gaW5TaXplO1xuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdERpdmlzb3IoaW5TaXplLCBNYXRoLmZsb29yKE1hdGguc3FydChpblNpemUpKSk7XG59XG5leHBvcnRzLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZSA9IGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTtcbmZ1bmN0aW9uIG5lYXJlc3REaXZpc29yKHNpemUsIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgIGlmIChzaXplICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BzKCkge1xuICAgIH1cbiAgICBPcHMubG9nU3VtRXhwID0gZnVuY3Rpb24gKGlucHV0LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgeE1heCA9IGlucHV0Lm1heChheGVzLCB0cnVlKTtcbiAgICAgICAgdmFyIGEgPSBpbnB1dC5zdWIoeE1heCk7XG4gICAgICAgIHZhciBiID0gYS5leHAoKTtcbiAgICAgICAgdmFyIGMgPSBiLnN1bShheGVzKTtcbiAgICAgICAgdmFyIGQgPSBjLmxvZygpO1xuICAgICAgICB2YXIgcmVzID0geE1heC5yZXNoYXBlKGQuc2hhcGUpLmFkZChkKTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBheGVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5zdW0gPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYubWF0aC5jdXN0b21HcmFkaWVudCgnc3VtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBlcm11dGF0aW9uID0gYXhpc191dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCB4LnJhbmspO1xuICAgICAgICAgICAgdmFyIHJlZHVjdGlvbkF4ZXMgPSBheGVzO1xuICAgICAgICAgICAgdmFyIHBlcm11dGVkWCA9IHg7XG4gICAgICAgICAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBlcm11dGVkWCA9IHgudHJhbnNwb3NlKHBlcm11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZWR1Y3Rpb25BeGVzID1cbiAgICAgICAgICAgICAgICAgICAgYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMocmVkdWN0aW9uQXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnU3VtJywgeyBpbnB1dHM6IHsgeDogcGVybXV0ZWRYIH0sIGFyZ3M6IHsgYXhlczogcmVkdWN0aW9uQXhlcyB9IH0pO1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHZhbHVlLnNoYXBlLCBheGVzKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyYWRpZW50cyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkRHlTaGFwZVtheGlzXSA9IDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHkgPSBkeS5yZXNoYXBlKGV4cGFuZGVkRHlTaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBhbmRlZER5Lm11bChuZGFycmF5XzEuTkRBcnJheS5vbmVzKHguc2hhcGUsICdmbG9hdDMyJykpOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGRlclggfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRpZW50czogZ3JhZGllbnRzIH07XG4gICAgICAgIH0sIHsgeDogeCB9KTtcbiAgICB9O1xuICAgIE9wcy5tZWFuID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHNoYXBlcyA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpO1xuICAgICAgICB2YXIgcmVkdWNlU2hhcGUgPSBzaGFwZXNbMV07XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLm1hdGguY3VzdG9tR3JhZGllbnQoJ21lYW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVkdWNlU2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KHJlZHVjZVNpemUpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHguZGl2KHJlZHVjZVNpemVTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzLnN1bShheGlzLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRzID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHlTaGFwZSA9IHguc2hhcGUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBheGVzLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWREeVNoYXBlW2F4aXNdID0gMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWREeSA9IGR5LnJlc2hhcGUoZXhwYW5kZWREeVNoYXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVyWCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cGFuZGVkRHkubXVsKG5kYXJyYXlfMS5OREFycmF5Lm9uZXMoeC5zaGFwZSwgJ2Zsb2F0MzInKSlcbiAgICAgICAgICAgICAgICAgICAgLmRpdihyZWR1Y2VTaXplU2NhbGFyKTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBkZXJYIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkaWVudHM6IGdyYWRpZW50cyB9O1xuICAgICAgICB9LCB7IHg6IHggfSk7XG4gICAgfTtcbiAgICBPcHMubWluID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb3JpZ0F4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdNaW4nLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgYXhlczogYXhlcyB9IH0pO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE9wcy5tYXggPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ01heCcsIHsgaW5wdXRzOiB7IHg6IHggfSwgYXJnczogeyBheGVzOiBheGVzIH0gfSk7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgT3BzLmFyZ01pbiA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdBcmdNaW4nLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgYXhlczogYXhlcyB9IH0pO1xuICAgIH07XG4gICAgT3BzLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdBcmdNYXgnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgYXhlczogYXhlcyB9IH0pO1xuICAgIH07XG4gICAgT3BzLmFyZ01heEVxdWFscyA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh4MS5zaGFwZSwgeDIuc2hhcGUsICdFcnJvciBpbiBhcmdNYXhFcXVhbHM6ICcpO1xuICAgICAgICByZXR1cm4geDEuYXJnTWF4KCkuZXF1YWwoeDIuYXJnTWF4KCkpO1xuICAgIH07XG4gICAgT3BzLm1vbWVudHMgPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgbWVhbiA9IHgubWVhbihheGVzLCBrZWVwRGltcyk7XG4gICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbWVhbi5zaGFwZTtcbiAgICAgICAgaWYgKCFrZWVwRGltcykge1xuICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShtZWFuLnNoYXBlLCBheGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV2U3F1YXJlZCA9IHgudG9GbG9hdCgpLnN1YihtZWFuLnJlc2hhcGUoa2VlcERpbXNTaGFwZSkpLnNxdWFyZSgpO1xuICAgICAgICB2YXIgdmFyaWFuY2UgPSBkZXZTcXVhcmVkLm1lYW4oYXhlcywga2VlcERpbXMpO1xuICAgICAgICByZXR1cm4geyBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImxvZ1N1bUV4cFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibWVhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJtaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwibWF4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImFyZ01pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJhcmdNYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYXJnTWF4RXF1YWxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm1vbWVudHNcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjdGlvbl9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5yZXZlcnNlMUQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdmFyIGlucHV0NEQgPSB4LmFzNEQoMSwgMSwgMSwgeC5zaGFwZVswXSk7XG4gICAgICAgIHZhciByZXMgPSBPcHMucmV2ZXJzZTREKGlucHV0NEQsIFszXSk7XG4gICAgICAgIHJldHVybiByZXMuYXMxRCgpO1xuICAgIH07XG4gICAgT3BzLnJldmVyc2UyRCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJFcnJvciBpbiByZXZlcnNlMkQ6IHggbXVzdCBiZSByYW5rIDIgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB2YXIgYXhpc0NsZWFuZWQgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSkubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICsgMjsgfSk7XG4gICAgICAgIHZhciBpbnB1dDREID0geC5hczREKDEsIDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0pO1xuICAgICAgICB2YXIgcmVzID0gT3BzLnJldmVyc2U0RChpbnB1dDRELCBheGlzQ2xlYW5lZCk7XG4gICAgICAgIHJldHVybiByZXMuYXMyRChyZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgfTtcbiAgICBPcHMucmV2ZXJzZTNEID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHZhciBheGlzQ2xlYW5lZCA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKS5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgKyAxOyB9KTtcbiAgICAgICAgdmFyIGlucHV0NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIHZhciByZXMgPSBPcHMucmV2ZXJzZTREKGlucHV0NEQsIGF4aXNDbGVhbmVkKTtcbiAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgIH07XG4gICAgT3BzLnJldmVyc2U0RCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCwgXCJFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB2YXIgYXhpc0NsZWFuZWQgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnUmV2ZXJzZTREJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IGF4aXM6IGF4aXNDbGVhbmVkIH0gfSk7XG4gICAgfTtcbiAgICBPcHMucmV2ZXJzZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4LnJlc2hhcGUoeC5zaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gT3BzLnJldmVyc2UxRCh4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHMucmV2ZXJzZTJEKHgsIGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIE9wcy5yZXZlcnNlM0QoeCwgYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gT3BzLnJldmVyc2U0RCh4LCBheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJldmVyc2UgZm9yIHJhbmsgXCIgKyB4LnJhbmsgKyBcIiBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJyZXZlcnNlMURcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmV2ZXJzZTJEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInJldmVyc2UzRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJyZXZlcnNlNERcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmV2ZXJzZVwiLCBudWxsKTtcbiAgICByZXR1cm4gT3BzO1xufSgpKTtcbmV4cG9ydHMuT3BzID0gT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV2ZXJzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG52YXIgc2xpY2VfdXRpbCA9IHJlcXVpcmUoXCIuL3NsaWNlX3V0aWxcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5zbGljZTFEID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoeCwgW2JlZ2luXSwgW3NpemVdKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTbGljZTFEJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IGJlZ2luOiBiZWdpbiwgc2l6ZTogc2l6ZSB9IH0pO1xuICAgIH07XG4gICAgT3BzLnNsaWNlMkQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZCh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnU2xpY2UyRCcsIHsgaW5wdXRzOiB7IHg6IHggfSwgYXJnczogeyBiZWdpbjogYmVnaW4sIHNpemU6IHNpemUgfSB9KTtcbiAgICB9O1xuICAgIE9wcy5zbGljZTNEID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoeCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1NsaWNlM0QnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgYmVnaW46IGJlZ2luLCBzaXplOiBzaXplIH0gfSk7XG4gICAgfTtcbiAgICBPcHMuc2xpY2U0RCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKHgsIGJlZ2luLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTbGljZTREJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IGJlZ2luOiBiZWdpbiwgc2l6ZTogc2l6ZSB9IH0pO1xuICAgIH07XG4gICAgT3BzLnNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gT3BzLnNsaWNlMUQoeCwgYmVnaW5bMF0sIHNpemVbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIE9wcy5zbGljZTJEKHgsIGJlZ2luLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHMuc2xpY2UzRCh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gT3BzLnNsaWNlNEQoeCwgYmVnaW4sIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIiArIHgucmFuayArIFwiIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInNsaWNlMURcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic2xpY2UyRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzbGljZTNEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInNsaWNlNERcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic2xpY2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IGJlZ2luLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIGJlZ2luIFwiICsgYmVnaW4gKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBzaXplLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIHNpemUgXCIgKyBzaXplICsgXCIgbXVzdCBcIiArXG4gICAgICAgIChcIm1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIgKyBpbnB1dC5yYW5rICsgXCIpLlwiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5yYW5rOyArK2kpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYmVnaW5baV0gKyBzaXplW2ldIDw9IGlucHV0LnNoYXBlW2ldLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBiZWdpbltcIiArIGkgKyBcIl0gKyBzaXplW1wiICsgaSArIFwiXSBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyAoYmVnaW5baV0gKyBzaXplW2ldKSArIFwiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIiArIGkgKyBcIl0gKFwiICsgaW5wdXQuc2hhcGVbaV0gKyBcIilcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UGFyYW1zVmFsaWQgPSBhc3NlcnRQYXJhbXNWYWxpZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wcygpIHtcbiAgICB9XG4gICAgT3BzLnNvZnRtYXggPSBmdW5jdGlvbiAobG9naXRzLCBkaW0pIHtcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIGlmIChkaW0gPT09IC0xKSB7XG4gICAgICAgICAgICBkaW0gPSBsb2dpdHMucmFuayAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSAhPT0gbG9naXRzLnJhbmsgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gJyArXG4gICAgICAgICAgICAgICAgKFwiTG9naXRzIHdhcyByYW5rIFwiICsgbG9naXRzLnJhbmsgKyBcIiBhbmQgZGltIHdhcyBcIiArIGRpbSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFkaWVudHMgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9naXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzWSA9IGR5Lm11bCh5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5VGltZXNZLnN1YihkeVRpbWVzWS5zdW0oW2RpbV0sIGtlZXBEaW1zKS5tdWwoeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5tYXRoLmN1c3RvbUdyYWRpZW50KCdzb2Z0bWF4JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBsc2UgPSBsb2dpdHMubG9nU3VtRXhwKFtkaW1dLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIgbG9nUmVzdWx0ID0gbG9naXRzLnRvRmxvYXQoKS5zdWIobHNlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvZ1Jlc3VsdC5leHAoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZ3JhZGllbnRzOiBncmFkaWVudHMgfTtcbiAgICAgICAgfSwgeyBsb2dpdHM6IGxvZ2l0cyB9KTtcbiAgICB9O1xuICAgIE9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5ID0gZnVuY3Rpb24gKGxhYmVscywgbG9naXRzLCBkaW0pIHtcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBsb2dpdHMuc2hhcGUsICdFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiAnKTtcbiAgICAgICAgaWYgKGRpbSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRpbSA9IGxvZ2l0cy5yYW5rIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltICE9PSBsb2dpdHMucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU29mdG1heCBjcm9zcyBlbnRyb3B5IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgXCIgK1xuICAgICAgICAgICAgICAgIChcInN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rIFwiICsgbG9naXRzLnJhbmsgKyBcIiBcIikgK1xuICAgICAgICAgICAgICAgIChcImFuZCBkaW0gd2FzIFwiICsgZGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLm1hdGguY3VzdG9tR3JhZGllbnQoJ3NvZnRtYXhDcm9zc0VudHJvcHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29mdG1heExvZ2l0cyA9IGxvZ2l0cy5zb2Z0bWF4KGRpbSk7XG4gICAgICAgICAgICB2YXIgY29zdFZlY3RvciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTUpLmFkZChzb2Z0bWF4TG9naXRzKS5sb2coKS5tdWwobGFiZWxzKS5uZWcoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvc3RWZWN0b3Iuc3VtKFtkaW1dKTtcbiAgICAgICAgICAgIHZhciBncmFkaWVudHMgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHlTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShkeS5zaGFwZSwgW2RpbV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2l0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5LnJlc2hhcGUoZHlTaGFwZSkubXVsKHNvZnRtYXhMb2dpdHMuc3ViKGxhYmVscy50b0Zsb2F0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5yZXNoYXBlKGR5U2hhcGUpLm11bChsYWJlbHMuc3ViKHNvZnRtYXhMb2dpdHMpKTsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkaWVudHM6IGdyYWRpZW50cyB9O1xuICAgICAgICB9LCB7IGxhYmVsczogbGFiZWxzLCBsb2dpdHM6IGxvZ2l0cyB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInNvZnRtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic29mdG1heENyb3NzRW50cm9weVwiLCBudWxsKTtcbiAgICByZXR1cm4gT3BzO1xufSgpKTtcbmV4cG9ydHMuT3BzID0gT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29mdG1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbnZhciBPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wcygpIHtcbiAgICB9XG4gICAgT3BzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBwZXJtKSB7XG4gICAgICAgIGlmIChwZXJtID09IG51bGwpIHtcbiAgICAgICAgICAgIHBlcm0gPSB4LnNoYXBlLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gaTsgfSkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciB1bmRvUGVybSA9IGF4aXNfdXRpbC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKHBlcm0pO1xuICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS50cmFuc3Bvc2UodW5kb1Blcm0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZGVyWCB9O1xuICAgICAgICB9O1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IHBlcm0ubGVuZ3RoLCBcIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIiArIHgucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIgKyBwZXJtICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdUcmFuc3Bvc2UnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgcGVybTogcGVybSB9IH0sIGRlcik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJ0cmFuc3Bvc2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wcztcbn0oKSk7XG5leHBvcnRzLk9wcyA9IE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEVHlwZTtcbihmdW5jdGlvbiAoRFR5cGUpIHtcbiAgICBEVHlwZVtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBEVHlwZVtcImludDMyXCJdID0gXCJpbnQzMlwiO1xuICAgIERUeXBlW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xufSkoRFR5cGUgPSBleHBvcnRzLkRUeXBlIHx8IChleHBvcnRzLkRUeXBlID0ge30pKTtcbnZhciBSYW5rO1xuKGZ1bmN0aW9uIChSYW5rKSB7XG4gICAgUmFua1tcIlIwXCJdID0gXCJSMFwiO1xuICAgIFJhbmtbXCJSMVwiXSA9IFwiUjFcIjtcbiAgICBSYW5rW1wiUjJcIl0gPSBcIlIyXCI7XG4gICAgUmFua1tcIlIzXCJdID0gXCJSM1wiO1xuICAgIFJhbmtbXCJSNFwiXSA9IFwiUjRcIjtcbn0pKFJhbmsgPSBleHBvcnRzLlJhbmsgfHwgKGV4cG9ydHMuUmFuayA9IHt9KSk7XG52YXIgVXBjYXN0SW50MzJBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEludDMyQW5kTWFwKSB7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBVcGNhc3RJbnQzMkFuZE1hcFtcImJvb2xcIl0gPSBcImludDMyXCI7XG59KShVcGNhc3RJbnQzMkFuZE1hcCB8fCAoVXBjYXN0SW50MzJBbmRNYXAgPSB7fSkpO1xudmFyIFVwY2FzdEJvb2xBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEJvb2xBbmRNYXApIHtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEJvb2xBbmRNYXBbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xufSkoVXBjYXN0Qm9vbEFuZE1hcCB8fCAoVXBjYXN0Qm9vbEFuZE1hcCA9IHt9KSk7XG52YXIgVXBjYXN0RmxvYXQzMkFuZE1hcDtcbihmdW5jdGlvbiAoVXBjYXN0RmxvYXQzMkFuZE1hcCkge1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0RmxvYXQzMkFuZE1hcFtcImludDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0RmxvYXQzMkFuZE1hcFtcImJvb2xcIl0gPSBcImZsb2F0MzJcIjtcbn0pKFVwY2FzdEZsb2F0MzJBbmRNYXAgfHwgKFVwY2FzdEZsb2F0MzJBbmRNYXAgPSB7fSkpO1xudmFyIHVwY2FzdFR5cGVNYXAgPSB7XG4gICAgZmxvYXQzMjogVXBjYXN0RmxvYXQzMkFuZE1hcCxcbiAgICBpbnQzMjogVXBjYXN0SW50MzJBbmRNYXAsXG4gICAgYm9vbDogVXBjYXN0Qm9vbEFuZE1hcFxufTtcbmZ1bmN0aW9uIHVwY2FzdFR5cGUodHlwZUEsIHR5cGVCKSB7XG4gICAgcmV0dXJuIHVwY2FzdFR5cGVNYXBbdHlwZUFdW3R5cGVCXTtcbn1cbmV4cG9ydHMudXBjYXN0VHlwZSA9IHVwY2FzdFR5cGU7XG5mdW5jdGlvbiBzdW1PdXRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdXBjYXN0VHlwZSh0eXBlLCAnaW50MzInKTtcbn1cbmV4cG9ydHMuc3VtT3V0VHlwZSA9IHN1bU91dFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHMoKSB7XG4gICAgfVxuICAgIE9wcy5uZWcgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ05lZycsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm5lZygpOyB9IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3BzLmNlaWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0NlaWwnLCB7IGlucHV0czogeyB4OiB4IH0gfSk7XG4gICAgfTtcbiAgICBPcHMuZmxvb3IgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0Zsb29yJywgeyBpbnB1dHM6IHsgeDogeCB9IH0pO1xuICAgIH07XG4gICAgT3BzLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnRXhwJywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKHkpOyB9IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3BzLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnTG9nJywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2KHgudG9GbG9hdCgpKTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTcXJ0JywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2KHgudG9GbG9hdCgpLnNxcnQoKS5tdWwobmRhcnJheV8xLlNjYWxhci5uZXcoMikpKTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1NxdWFyZScsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bCh4LnRvRmxvYXQoKS5tdWwobmRhcnJheV8xLlNjYWxhci5uZXcoMikpKTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5hYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0FicycsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bCh4LnRvRmxvYXQoKS5zdGVwKC0xKSk7IH0gfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMuY2xpcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICAgICAgICB1dGlsLmFzc2VydCgobWluIDw9IG1heCksIFwiRXJyb3IgaW4gY2xpcDogbWluIChcIiArIG1pbiArIFwiKSBtdXN0IGJlXCIgK1xuICAgICAgICAgICAgKFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoXCIgKyBtYXggKyBcIikuXCIpKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdDbGlwJywgeyBpbnB1dHM6IHsgeDogeCB9LCBhcmdzOiB7IG1pbjogbWluLCBtYXg6IG1heCB9IH0pO1xuICAgIH07XG4gICAgT3BzLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1JlbHUnLCB7IGlucHV0czogeyB4OiB4IH0gfSwgZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICB2YXIgc3RlcFJlcyA9IHguc3RlcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKHN0ZXBSZXMudG9GbG9hdCgpKTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5lbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChlbHVEZXIoeCkpOyB9LFxuICAgICAgICAgICAgICAgIGFscGhhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVyaXZhdGl2ZSBvZiBwcmVsdSB3aXRoIHJlc3BlY3QgdG8gYWxwaGEgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnRWx1JywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGRlcik7XG4gICAgfTtcbiAgICBPcHMuc2VsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnU2VsdScsIHsgaW5wdXRzOiB7IHg6IHggfSB9KTtcbiAgICB9O1xuICAgIE9wcy5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjI7IH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdMZWFreVJlbHUnLCB7IGlucHV0czogeyB4OiB4IH0sIGFyZ3M6IHsgYWxwaGE6IGFscGhhIH0gfSk7XG4gICAgfTtcbiAgICBPcHMucHJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWwocHJlbHVEZXIoeCwgYWxwaGEpKTsgfSxcbiAgICAgICAgICAgICAgICBhbHBoYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rlcml2YXRpdmUgb2YgcHJlbHUgd2l0aCByZXNwZWN0IHRvIGFscGhhIGlzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ1BSZUxVJywgeyBpbnB1dHM6IHsgeDogeCwgYWxwaGE6IGFscGhhIH0gfSwgZGVyKTtcbiAgICB9O1xuICAgIE9wcy5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTaWdtb2lkJywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKHkubXVsKG5kYXJyYXlfMS5TY2FsYXIubmV3KDEpLnN1Yih5KSkpOyB9IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3BzLnNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnU2luJywgeyBpbnB1dHM6IHsgeDogeCB9IH0sIGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4geC50b0Zsb2F0KCkuY29zKCkubXVsKGR5KTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5jb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0NvcycsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHgudG9GbG9hdCgpLnNpbigpLm5lZygpLm11bChkeSk7IH0gfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMudGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdUYW4nLCB7IGlucHV0czogeyB4OiB4IH0gfSwgZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXYoeC5jb3MoKS5zcXVhcmUoKSk7IH0gfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQXNpbicsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2KE9wcy5zcXJ0KG5kYXJyYXlfMS5TY2FsYXIubmV3KDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMuYWNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQWNvcycsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2KE9wcy5zcXJ0KG5kYXJyYXlfMS5TY2FsYXIubmV3KDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKS5uZWcoKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPcHMuYXRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnQXRhbicsIHsgaW5wdXRzOiB7IHg6IHggfSB9LCBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdihuZGFycmF5XzEuU2NhbGFyLm5ldygxKS5hZGQoeC50b0Zsb2F0KCkuc3F1YXJlKCkpKTsgfSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wcy5zaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdTaW5oJywgeyBpbnB1dHM6IHsgeDogeCB9IH0pO1xuICAgIH07XG4gICAgT3BzLmNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmV4ZWN1dGVLZXJuZWwoJ0Nvc2gnLCB7IGlucHV0czogeyB4OiB4IH0gfSk7XG4gICAgfTtcbiAgICBPcHMudGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnVGFuaCcsIHsgaW5wdXRzOiB7IHg6IHggfSB9KTtcbiAgICB9O1xuICAgIE9wcy5zdGVwID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4wOyB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnU3RlcCcsIHsgaW5wdXRzOiB7IHg6IHggfSwgYXJnczogeyBhbHBoYTogYWxwaGEgfSB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcIm5lZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJjZWlsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImZsb29yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImV4cFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJsb2dcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic3FydFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzcXVhcmVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYWJzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNsaXBcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicmVsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic2VsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJsZWFreVJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwicHJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwic2lnbW9pZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiY29zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcInRhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJhc2luXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImFjb3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwiYXRhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzaW5oXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkZWNvcmF0b3JzXzEub3BlcmF0aW9uXG4gICAgXSwgT3BzLCBcImNvc2hcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRlY29yYXRvcnNfMS5vcGVyYXRpb25cbiAgICBdLCBPcHMsIFwidGFuaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZGVjb3JhdG9yc18xLm9wZXJhdGlvblxuICAgIF0sIE9wcywgXCJzdGVwXCIsIG51bGwpO1xuICAgIHJldHVybiBPcHM7XG59KCkpO1xuZXhwb3J0cy5PcHMgPSBPcHM7XG5mdW5jdGlvbiBwcmVsdURlcih4LCBhbHBoYSkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZXhlY3V0ZUtlcm5lbCgnUFJlTFVEZXInLCB7IGlucHV0czogeyB4OiB4LCBhbHBoYTogYWxwaGEgfSB9KTtcbn1cbmZ1bmN0aW9uIGVsdURlcih4KSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5leGVjdXRlS2VybmVsKCdFbHVEZXInLCB7IGlucHV0czogeyB4OiB4IH0gfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmFyeV9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIGJhY2tlbmRfY3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL2JhY2tlbmRzL2JhY2tlbmRfY3B1XCIpO1xudmFyIGJhY2tlbmRfd2ViZ2xfMSA9IHJlcXVpcmUoXCIuL21hdGgvYmFja2VuZHMvYmFja2VuZF93ZWJnbFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy5URVNUX0VQU0lMT04gPSAxZS0yO1xuZnVuY3Rpb24gbWVhbih2YWx1ZXMpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3VtIC8gdmFsdWVzLmxlbmd0aDtcbn1cbmV4cG9ydHMubWVhbiA9IG1lYW47XG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih2YWx1ZXMsIG1lYW4pIHtcbiAgICB2YXIgc3F1YXJlRGlmZlN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZXNbaV0gLSBtZWFuO1xuICAgICAgICBzcXVhcmVEaWZmU3VtICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZURpZmZTdW0gLyB2YWx1ZXMubGVuZ3RoKTtcbn1cbmV4cG9ydHMuc3RhbmRhcmREZXZpYXRpb24gPSBzdGFuZGFyZERldmlhdGlvbjtcbmZ1bmN0aW9uIGt1cnRvc2lzKHZhbHVlcykge1xuICAgIHZhciB2YWx1ZXNNZWFuID0gbWVhbih2YWx1ZXMpO1xuICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgc3VtMiA9IDA7XG4gICAgdmFyIHN1bTQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVzW2ldIC0gdmFsdWVzTWVhbjtcbiAgICAgICAgc3VtMiArPSBNYXRoLnBvdyh2LCAyKTtcbiAgICAgICAgc3VtNCArPSBNYXRoLnBvdyh2LCA0KTtcbiAgICB9XG4gICAgcmV0dXJuICgxIC8gbikgKiBzdW00IC8gTWF0aC5wb3coKDEgLyBuKSAqIHN1bTIsIDIpO1xufVxuZXhwb3J0cy5rdXJ0b3NpcyA9IGt1cnRvc2lzO1xuZnVuY3Rpb24gc2tld25lc3ModmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlc01lYW4gPSBtZWFuKHZhbHVlcyk7XG4gICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBzdW0yID0gMDtcbiAgICB2YXIgc3VtMyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV0gLSB2YWx1ZXNNZWFuO1xuICAgICAgICBzdW0yICs9IE1hdGgucG93KHYsIDIpO1xuICAgICAgICBzdW0zICs9IE1hdGgucG93KHYsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gKDEgLyBuKSAqIHN1bTMgLyBNYXRoLnBvdygoMSAvIChuIC0gMSkpICogc3VtMiwgMyAvIDIpO1xufVxuZXhwb3J0cy5za2V3bmVzcyA9IHNrZXduZXNzO1xuZnVuY3Rpb24gamFycXVlQmVyYU5vcm1hbGl0eVRlc3QoYSkge1xuICAgIHZhciB2YWx1ZXM7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICB2YWx1ZXMgPSBhLmRhdGFTeW5jKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSBhO1xuICAgIH1cbiAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHMgPSBza2V3bmVzcyh2YWx1ZXMpO1xuICAgIHZhciBrID0ga3VydG9zaXModmFsdWVzKTtcbiAgICB2YXIgamIgPSBuIC8gNiAqIChNYXRoLnBvdyhzLCAyKSArIDAuMjUgKiBNYXRoLnBvdyhrIC0gMywgMikpO1xuICAgIHZhciBDSElfU1FVQVJFXzJERUcgPSA1Ljk5MTtcbiAgICBpZiAoamIgPiBDSElfU1FVQVJFXzJERUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwLXZhbHVlIGZvciBKQjogXCIgKyBqYik7XG4gICAgfVxufVxuZXhwb3J0cy5qYXJxdWVCZXJhTm9ybWFsaXR5VGVzdCA9IGphcnF1ZUJlcmFOb3JtYWxpdHlUZXN0O1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlJbk1lYW5TdGRSYW5nZShhY3R1YWwsIGV4cGVjdGVkTWVhbiwgZXhwZWN0ZWRTdGREZXYsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIHZhciBhY3R1YWxWYWx1ZXM7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgIGFjdHVhbFZhbHVlcyA9IGFjdHVhbC5kYXRhU3luYygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWVzID0gYWN0dWFsO1xuICAgIH1cbiAgICB2YXIgYWN0dWFsTWVhbiA9IG1lYW4oYWN0dWFsVmFsdWVzKTtcbiAgICBleHBlY3ROdW1iZXJzQ2xvc2UoYWN0dWFsTWVhbiwgZXhwZWN0ZWRNZWFuLCBlcHNpbG9uKTtcbiAgICBleHBlY3ROdW1iZXJzQ2xvc2Uoc3RhbmRhcmREZXZpYXRpb24oYWN0dWFsVmFsdWVzLCBhY3R1YWxNZWFuKSwgZXhwZWN0ZWRTdGREZXYsIGVwc2lsb24pO1xufVxuZXhwb3J0cy5leHBlY3RBcnJheUluTWVhblN0ZFJhbmdlID0gZXhwZWN0QXJyYXlJbk1lYW5TdGRSYW5nZTtcbmZ1bmN0aW9uIGV4cGVjdEFycmF5c0Nsb3NlKGFjdHVhbCwgZXhwZWN0ZWQsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIGlmICghKGFjdHVhbCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSAmJiAhKGV4cGVjdGVkIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpKSB7XG4gICAgICAgIHZhciBhVHlwZSA9IGFjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgYlR5cGUgPSBleHBlY3RlZC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIGFjdHVhbDogXCIgKyBhVHlwZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ2cyBleHBlY3RlZDogXCIgKyBiVHlwZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5ICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgaWYgKGFjdHVhbC5kdHlwZSAhPT0gZXhwZWN0ZWQuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgYWN0dWFsOiBcIiArIGFjdHVhbC5kdHlwZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ2cyBleHBlY3RlZDogXCIgKyBleHBlY3RlZC5kdHlwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbC5zaGFwZSwgZXhwZWN0ZWQuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCBzaGFwZSBhY3R1YWw6IFwiICsgYWN0dWFsLnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChcInZzIGV4cGVjdGVkOiBcIiArIGV4cGVjdGVkLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWN0dWFsVmFsdWVzO1xuICAgIHZhciBleHBlY3RlZFZhbHVlcztcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgYWN0dWFsVmFsdWVzID0gYWN0dWFsLmRhdGFTeW5jKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3R1YWxWYWx1ZXMgPSBhY3R1YWw7XG4gICAgfVxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgIGV4cGVjdGVkVmFsdWVzID0gZXhwZWN0ZWQuZGF0YVN5bmMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cGVjdGVkVmFsdWVzID0gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChhY3R1YWxWYWx1ZXMubGVuZ3RoICE9PSBleHBlY3RlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIiArIGFjdHVhbFZhbHVlcy5sZW5ndGggKyBcIiB2cyBcIiArXG4gICAgICAgICAgICAoXCJleHBlY3RlZDogXCIgKyBleHBlY3RlZFZhbHVlcy5sZW5ndGggKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgKFwiQWN0dWFsOiAgIFwiICsgYWN0dWFsVmFsdWVzICsgXCIuXFxuXCIpICtcbiAgICAgICAgICAgIChcIkV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzICsgXCIuXCIpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYSA9IGFjdHVhbFZhbHVlc1tpXTtcbiAgICAgICAgdmFyIGUgPSBleHBlY3RlZFZhbHVlc1tpXTtcbiAgICAgICAgaWYgKCFhcmVDbG9zZShhLCBOdW1iZXIoZSksIGVwc2lsb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgZGlmZmVyOiBhY3R1YWxbXCIgKyBpICsgXCJdID0gXCIgKyBhICsgXCIsIGV4cGVjdGVkW1wiICsgaSArIFwiXSA9IFwiICsgZSArIFwiLlxcblwiICtcbiAgICAgICAgICAgICAgICAoXCJBY3R1YWw6ICAgXCIgKyBhY3R1YWxWYWx1ZXMgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgICAgIChcIkV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzQ2xvc2UgPSBleHBlY3RBcnJheXNDbG9zZTtcbmZ1bmN0aW9uIGV4cGVjdEFycmF5c0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZXhwZWN0QXJyYXlzQ2xvc2UoYWN0dWFsLCBleHBlY3RlZCwgMCk7XG59XG5leHBvcnRzLmV4cGVjdEFycmF5c0VxdWFsID0gZXhwZWN0QXJyYXlzRXF1YWw7XG5mdW5jdGlvbiBleHBlY3ROdW1iZXJzQ2xvc2UoYSwgZSwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgaWYgKCFhcmVDbG9zZShhLCBlLCBlcHNpbG9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSBcIiArIGEgKyBcIiwgZXhwZWN0ZWQgPT09IFwiICsgZSk7XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3ROdW1iZXJzQ2xvc2UgPSBleHBlY3ROdW1iZXJzQ2xvc2U7XG5mdW5jdGlvbiBhcmVDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGlzTmFOKGEpICYmIGlzTmFOKGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oYSkgfHwgaXNOYU4oZSkgfHwgTWF0aC5hYnMoYSAtIGUpID4gZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXhwZWN0VmFsdWVzSW5SYW5nZShhY3R1YWwsIGxvdywgaGlnaCkge1xuICAgIHZhciBhY3R1YWxWYWxzO1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsLmRhdGFTeW5jKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFjdHVhbFZhbHNbaV0gPCBsb3cgfHwgYWN0dWFsVmFsc1tpXSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIiArIGFjdHVhbFZhbHNbaV0gKyBcIiBsb3c6IFwiICsgbG93ICsgXCIsIGhpZ2g6IFwiICsgaGlnaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdFZhbHVlc0luUmFuZ2UgPSBleHBlY3RWYWx1ZXNJblJhbmdlO1xuZnVuY3Rpb24gcmFuZG9tQXJyYXlJblJhbmdlKG4sIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIHZhciB2ID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICB2YXIgcmFuZ2UgPSBtYXhWYWx1ZSAtIG1pblZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZbaV0gPSAoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSArIG1pblZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmV4cG9ydHMucmFuZG9tQXJyYXlJblJhbmdlID0gcmFuZG9tQXJyYXlJblJhbmdlO1xuZnVuY3Rpb24gbWFrZUlkZW50aXR5KG4pIHtcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG4pO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGlbKGogKiBuKSArIGpdID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5leHBvcnRzLm1ha2VJZGVudGl0eSA9IG1ha2VJZGVudGl0eTtcbmZ1bmN0aW9uIGNwdU11bHRpcGx5TWF0cml4KGEsIGFSb3csIGFDb2wsIGIsIGJSb3csIGJDb2wpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhUm93ICogYkNvbCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBhUm93OyArK3IpIHtcbiAgICAgICAgdmFyIGFPZmZzZXQgPSAociAqIGFDb2wpO1xuICAgICAgICB2YXIgY09mZnNldCA9IChyICogYkNvbCk7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYkNvbDsgKytjKSB7XG4gICAgICAgICAgICB2YXIgZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFDb2w7ICsraykge1xuICAgICAgICAgICAgICAgIGQgKz0gYVthT2Zmc2V0ICsga10gKiBiWyhrICogYkNvbCkgKyBjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjT2Zmc2V0ICsgY10gPSBkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNwdU11bHRpcGx5TWF0cml4ID0gY3B1TXVsdGlwbHlNYXRyaXg7XG5mdW5jdGlvbiBjcHVEb3RQcm9kdWN0KGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3B1RG90UHJvZHVjdDogaW5jb21wYXRpYmxlIHZlY3RvcnMuJyk7XG4gICAgfVxuICAgIHZhciBkID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZCArPSBhW2ldICogYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59XG5leHBvcnRzLmNwdURvdFByb2R1Y3QgPSBjcHVEb3RQcm9kdWN0O1xuZnVuY3Rpb24gZGVzY3JpYmVNYXRoQ1BVKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QpIHtcbiAgICB2YXIgdGVzdE5hbWVCYXNlID0gJ0NQVTogbWF0aC4nICsgbmFtZTtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGZ1bmN0aW9uICh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKSB7IHJldHVybiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZU1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IG1hdGhfMS5OREFycmF5TWF0aChuZXcgYmFja2VuZF9jcHVfMS5NYXRoQmFja2VuZENQVSgpLCBzYWZlTW9kZSk7XG4gICAgfSwgZmVhdHVyZXMpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZU1hdGhDUFUgPSBkZXNjcmliZU1hdGhDUFU7XG5mdW5jdGlvbiBkZXNjcmliZU1hdGhHUFUobmFtZSwgdGVzdHMsIGZlYXR1cmVzTGlzdCkge1xuICAgIHZhciB0ZXN0TmFtZUJhc2UgPSAnV2ViR0w6IG1hdGguJyArIG5hbWU7XG4gICAgZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzLCBmdW5jdGlvbiAodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykgeyByZXR1cm4gZXhlY3V0ZU1hdGhUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVNb2RlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoXzEuTkRBcnJheU1hdGgobmV3IGJhY2tlbmRfd2ViZ2xfMS5NYXRoQmFja2VuZFdlYkdMKCksIHNhZmVNb2RlKTtcbiAgICB9LCBmZWF0dXJlcyk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlTWF0aEdQVSA9IGRlc2NyaWJlTWF0aEdQVTtcbmZ1bmN0aW9uIGRlc2NyaWJlQ3VzdG9tKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCkge1xuICAgIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IobmFtZSwgW3Rlc3RzXSwgZnVuY3Rpb24gKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpIHsgcmV0dXJuIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZUN1c3RvbSA9IGRlc2NyaWJlQ3VzdG9tO1xuZnVuY3Rpb24gZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzLCBleGVjdXRvciwgZmVhdHVyZXNMaXN0KSB7XG4gICAgaWYgKGZlYXR1cmVzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgIGZlYXR1cmVzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICAgICAgdmFyIHRlc3ROYW1lID0gdGVzdE5hbWVCYXNlICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoZmVhdHVyZXMpO1xuICAgICAgICAgICAgZXhlY3V0b3IodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVRlc3RGdW5jUHJvbWlzZSh0ZXN0RnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGVzdEZ1bmMoKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGRvbmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZmFpbChlKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgUFJPTUlTRV9JVCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgIGl0KG5hbWUsIHJlc29sdmVUZXN0RnVuY1Byb21pc2UodGVzdEZ1bmMpKTtcbn07XG52YXIgUFJPTUlTRV9GSVQgPSBmdW5jdGlvbiAobmFtZSwgdGVzdEZ1bmMpIHtcbiAgICBmaXQobmFtZSwgcmVzb2x2ZVRlc3RGdW5jUHJvbWlzZSh0ZXN0RnVuYykpO1xufTtcbnZhciBQUk9NSVNFX1hJVCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgIHhpdChuYW1lLCByZXNvbHZlVGVzdEZ1bmNQcm9taXNlKHRlc3RGdW5jKSk7XG59O1xuZnVuY3Rpb24gZXhlY3V0ZU1hdGhUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIG1hdGhGYWN0b3J5LCBmZWF0dXJlcykge1xuICAgIHZhciBtYXRoO1xuICAgIHZhciBjdXN0b21CZWZvcmVFYWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXRoID0gbWF0aEZhY3RvcnkoKTtcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuc2V0TWF0aChtYXRoKTtcbiAgICAgICAgbWF0aC5zdGFydFNjb3BlKCk7XG4gICAgfTtcbiAgICB2YXIgY3VzdG9tQWZ0ZXJFYWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXRoLmVuZFNjb3BlKG51bGwpO1xuICAgICAgICBtYXRoLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHZhciBjdXN0b21JdCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgICAgICBQUk9NSVNFX0lUKG5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlc3RGdW5jKG1hdGgpOyB9KTtcbiAgICB9O1xuICAgIHZhciBjdXN0b21GaXQgPSBmdW5jdGlvbiAobmFtZSwgdGVzdEZ1bmMpIHtcbiAgICAgICAgUFJPTUlTRV9GSVQobmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVzdEZ1bmMobWF0aCk7IH0pO1xuICAgIH07XG4gICAgdmFyIGN1c3RvbVhpdCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgICAgICBQUk9NSVNFX1hJVChuYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXN0RnVuYyhtYXRoKTsgfSk7XG4gICAgfTtcbiAgICBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcywgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoLCBjdXN0b21JdCwgY3VzdG9tRml0LCBjdXN0b21YaXQpO1xufVxuZXhwb3J0cy5leGVjdXRlTWF0aFRlc3RzID0gZXhlY3V0ZU1hdGhUZXN0cztcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gsIGN1c3RvbUl0LCBjdXN0b21GaXQsIGN1c3RvbVhpdCkge1xuICAgIGlmIChjdXN0b21JdCA9PT0gdm9pZCAwKSB7IGN1c3RvbUl0ID0gUFJPTUlTRV9JVDsgfVxuICAgIGlmIChjdXN0b21GaXQgPT09IHZvaWQgMCkgeyBjdXN0b21GaXQgPSBQUk9NSVNFX0ZJVDsgfVxuICAgIGlmIChjdXN0b21YaXQgPT09IHZvaWQgMCkgeyBjdXN0b21YaXQgPSBQUk9NSVNFX1hJVDsgfVxuICAgIGRlc2NyaWJlKHRlc3ROYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5zZXRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuYWRkQ3VzdG9tQmFja2VuZCgnd2ViZ2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgYmFja2VuZF93ZWJnbF8xLk1hdGhCYWNrZW5kV2ViR0woKTsgfSk7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuYWRkQ3VzdG9tQmFja2VuZCgnY3B1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGJhY2tlbmRfY3B1XzEuTWF0aEJhY2tlbmRDUFUoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VzdG9tQmVmb3JlRWFjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQmVmb3JlRWFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjdXN0b21BZnRlckVhY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFmdGVyRWFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkgeyByZXR1cm4gdGVzdChjdXN0b21JdCwgY3VzdG9tRml0LCBjdXN0b21YaXQpOyB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTmFuKHZhbCwgZHR5cGUpIHtcbiAgICBpZiAoIXV0aWwuaXNWYWxOYU4odmFsLCBkdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgXCIgKyB2YWwgKyBcIiBkb2VzIG5vdCByZXByZXNlbnQgTmFOIGZvciBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydElzTmFuID0gYXNzZXJ0SXNOYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIHZhciBjb3VudGVyID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZW1wID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChjb3VudGVyID4gMCkge1xuICAgICAgICBpbmRleCA9IChNYXRoLnJhbmRvbSgpICogY291bnRlcikgfCAwO1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIHRlbXAgPSBhcnJheVtjb3VudGVyXTtcbiAgICAgICAgYXJyYXlbY291bnRlcl0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHRlbXA7XG4gICAgfVxufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgeCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oeCwgbWF4KSk7XG59XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5mdW5jdGlvbiByYW5kVW5pZm9ybShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cbmV4cG9ydHMucmFuZFVuaWZvcm0gPSByYW5kVW5pZm9ybTtcbmZ1bmN0aW9uIGRpc3RTcXVhcmVkKGEsIGIpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSBOdW1iZXIoYVtpXSkgLSBOdW1iZXIoYltpXSk7XG4gICAgICAgIHJlc3VsdCArPSBkaWZmICogZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGlzdFNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbmZ1bmN0aW9uIGFzc2VydChleHByLCBtc2cpIHtcbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaChzaGFwZUEsIHNoYXBlQiwgZXJyb3JNZXNzYWdlUHJlZml4KSB7XG4gICAgaWYgKGVycm9yTWVzc2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZVByZWZpeCA9ICcnOyB9XG4gICAgYXNzZXJ0KGFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSwgZXJyb3JNZXNzYWdlUHJlZml4ICsgKFwiU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFNoYXBlc01hdGNoID0gYXNzZXJ0U2hhcGVzTWF0Y2g7XG5mdW5jdGlvbiBhc3NlcnRUeXBlc01hdGNoKGEsIGIpIHtcbiAgICBhc3NlcnQoYS5kdHlwZSA9PT0gYi5kdHlwZSwgXCJUaGUgZHR5cGVzIG9mIHRoZSBmaXJzdCAoXCIgKyBhLmR0eXBlICsgXCIpIGFuZCBcIiArXG4gICAgICAgIChcInNlY29uZCAoXCIgKyBiLmR0eXBlICsgXCIpIGlucHV0IG11c3QgbWF0Y2hcIikpO1xufVxuZXhwb3J0cy5hc3NlcnRUeXBlc01hdGNoID0gYXNzZXJ0VHlwZXNNYXRjaDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCByZXQpIHtcbiAgICBpZiAocmV0ID09PSB2b2lkIDApIHsgcmV0ID0gW107IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmbGF0dGVuKGFycltpXSwgcmV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5mdW5jdGlvbiBpbmZlclNoYXBlKGFycikge1xuICAgIHZhciBzaGFwZSA9IFtdO1xuICAgIHdoaWxlIChhcnIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBzaGFwZS5wdXNoKGFyci5sZW5ndGgpO1xuICAgICAgICBhcnIgPSBhcnJbMF07XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJTaGFwZSA9IGluZmVyU2hhcGU7XG5mdW5jdGlvbiBzaXplRnJvbVNoYXBlKHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBzaGFwZVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKj0gc2hhcGVbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZXhwb3J0cy5zaXplRnJvbVNoYXBlID0gc2l6ZUZyb21TaGFwZTtcbmZ1bmN0aW9uIGlzU2NhbGFyU2hhcGUoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGUubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc1NjYWxhclNoYXBlID0gaXNTY2FsYXJTaGFwZTtcbmZ1bmN0aW9uIGFycmF5c0VxdWFsKG4xLCBuMikge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG4xW2ldICE9PSBuMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5hcnJheXNFcXVhbCA9IGFycmF5c0VxdWFsO1xuZnVuY3Rpb24gaXNJbnQoYSkge1xuICAgIHJldHVybiBhICUgMSA9PT0gMDtcbn1cbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbmZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIGlmIChNYXRoLnRhbmggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC50YW5oKHgpO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZTJ4ID0gTWF0aC5leHAoMiAqIHgpO1xuICAgICAgICByZXR1cm4gKGUyeCAtIDEpIC8gKGUyeCArIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFuaCA9IHRhbmg7XG5mdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpIHtcbiAgICBmb3IgKHZhciBhID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoc2l6ZSkpOyBhID4gMTsgLS1hKSB7XG4gICAgICAgIGlmIChzaXplICUgYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBzaXplIC8gYV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsxLCBzaXplXTtcbn1cbmV4cG9ydHMuc2l6ZVRvU3F1YXJpc2hTaGFwZSA9IHNpemVUb1NxdWFyaXNoU2hhcGU7XG5mdW5jdGlvbiBjcmVhdGVTaHVmZmxlZEluZGljZXMobikge1xuICAgIHZhciBzaHVmZmxlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgc2h1ZmZsZWRJbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgc2h1ZmZsZShzaHVmZmxlZEluZGljZXMpO1xuICAgIHJldHVybiBzaHVmZmxlZEluZGljZXM7XG59XG5leHBvcnRzLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyA9IGNyZWF0ZVNodWZmbGVkSW5kaWNlcztcbmZ1bmN0aW9uIHJpZ2h0UGFkKGEsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSBhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgcmV0dXJuIGEgKyAnICcucmVwZWF0KHNpemUgLSBhLmxlbmd0aCk7XG59XG5leHBvcnRzLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG5mdW5jdGlvbiByZXBlYXRlZFRyeShjaGVja0ZuLCBkZWxheUZuLCBtYXhDb3VudGVyKSB7XG4gICAgaWYgKGRlbGF5Rm4gPT09IHZvaWQgMCkgeyBkZWxheUZuID0gZnVuY3Rpb24gKGNvdW50ZXIpIHsgcmV0dXJuIDA7IH07IH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdHJ5Q291bnQgPSAwO1xuICAgICAgICB2YXIgdHJ5Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeUNvdW50Kys7XG4gICAgICAgICAgICB2YXIgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcbiAgICAgICAgICAgIGlmIChtYXhDb3VudGVyICE9IG51bGwgJiYgdHJ5Q291bnQgPj0gbWF4Q291bnRlcikge1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCh0cnlGbiwgMCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlcGVhdGVkVHJ5ID0gcmVwZWF0ZWRUcnk7XG5mdW5jdGlvbiBnZXRRdWVyeVBhcmFtcyhxdWVyeVN0cmluZykge1xuICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICBxdWVyeVN0cmluZy5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVQYXJhbShwYXJhbXMsIHRbMF0sIHRbMV0pO1xuICAgICAgICByZXR1cm4gdC5qb2luKCc9Jyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmV4cG9ydHMuZ2V0UXVlcnlQYXJhbXMgPSBnZXRRdWVyeVBhcmFtcztcbmZ1bmN0aW9uIGRlY29kZVBhcmFtKHBhcmFtcywgbmFtZSwgdmFsdWUpIHtcbiAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSB8fCAnJyk7XG59XG5mdW5jdGlvbiBpbmZlckZyb21JbXBsaWNpdFNoYXBlKHNoYXBlLCBzaXplKSB7XG4gICAgdmFyIHNoYXBlUHJvZCA9IDE7XG4gICAgdmFyIGltcGxpY2l0SWR4ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2hhcGVbaV0gPiAwKSB7XG4gICAgICAgICAgICBzaGFwZVByb2QgKj0gc2hhcGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGljaXRJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiRm91bmQgLTEgYXQgZGltIFwiICsgaW1wbGljaXRJZHggKyBcIiBhbmQgZGltIFwiICsgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1wbGljaXRJZHggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPD0gMC4gRm91bmQgXCIgKyBzaGFwZVtpXSArIFwiIGF0IGRpbSBcIiArIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbXBsaWNpdElkeCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgIT09IHNoYXBlUHJvZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaXplIChcIiArIHNpemUgKyBcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIiArIHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfVxuICAgIGlmIChzaXplICUgc2hhcGVQcm9kICE9PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIFwiICtcbiAgICAgICAgICAgIChcIkdvdCBcIiArIHNpemUgKyBcIiAvIFwiICsgc2hhcGVQcm9kKSk7XG4gICAgfVxuICAgIHZhciBuZXdTaGFwZSA9IHNoYXBlLnNsaWNlKCk7XG4gICAgbmV3U2hhcGVbaW1wbGljaXRJZHhdID0gc2l6ZSAvIHNoYXBlUHJvZDtcbiAgICByZXR1cm4gbmV3U2hhcGU7XG59XG5leHBvcnRzLmluZmVyRnJvbUltcGxpY2l0U2hhcGUgPSBpbmZlckZyb21JbXBsaWNpdFNoYXBlO1xuZXhwb3J0cy5OQU5fSU5UMzIgPSAxIDw8IDMxO1xuZXhwb3J0cy5OQU5fQk9PTCA9IDI1NTtcbmV4cG9ydHMuTkFOX0ZMT0FUMzIgPSBOYU47XG5mdW5jdGlvbiBnZXROYU4oZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5OQU5fRkxPQVQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTkFOX0lOVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5BTl9CT09MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmdldE5hTiA9IGdldE5hTjtcbmZ1bmN0aW9uIGlzVmFsTmFOKHZhbCwgZHR5cGUpIHtcbiAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gdmFsID09PSBleHBvcnRzLk5BTl9JTlQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gdmFsID09PSBleHBvcnRzLk5BTl9CT09MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsTmFOID0gaXNWYWxOYU47XG5mdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgbmV3U2hhcGUgPSBbXTtcbiAgICB2YXIga2VwdERpbXMgPSBbXTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXhpc1tqXSA9PT0gaSAmJiBzaGFwZVtpXSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJheGlzIFwiICsgaSArIFwiIGlzIG5vdCAxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChheGlzW2pdID09PSB1bmRlZmluZWQgfHwgYXhpc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzW2pdIDw9IGkpXG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDEpIHtcbiAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBuZXdTaGFwZTogbmV3U2hhcGUsIGtlcHREaW1zOiBrZXB0RGltcyB9O1xufVxuZXhwb3J0cy5zcXVlZXplU2hhcGUgPSBzcXVlZXplU2hhcGU7XG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCBzaXplKSB7XG4gICAgdmFyIHZhbHVlcyA9IG51bGw7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5nZXRUeXBlZEFycmF5RnJvbURUeXBlID0gZ2V0VHlwZWRBcnJheUZyb21EVHlwZTtcbmZ1bmN0aW9uIGlzTkRBcnJheUluTGlzdChuZGFycmF5LCBuZGFycmF5TGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmRhcnJheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5kYXJyYXlMaXN0W2ldLmlkID09PSBuZGFycmF5LmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzTkRBcnJheUluTGlzdCA9IGlzTkRBcnJheUluTGlzdDtcbmZ1bmN0aW9uIGNoZWNrRm9yTmFOKHZhbHMsIGR0eXBlLCBuYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc1ZhbE5hTih2YWxzW2ldLCBkdHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBtYXRoLlwiICsgbmFtZSArIFwiIGhhcyBOYU5zLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tGb3JOYU4gPSBjaGVja0Zvck5hTjtcbmZ1bmN0aW9uIGZsYXR0ZW5OYW1lQXJyYXlNYXAobmFtZUFycmF5TWFwLCBrZXlzKSB7XG4gICAgdmFyIHhzID0gW107XG4gICAgaWYgKG5hbWVBcnJheU1hcCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgIHhzLnB1c2gobmFtZUFycmF5TWFwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB4TWFwID0gbmFtZUFycmF5TWFwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzLnB1c2goeE1hcFtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuZXhwb3J0cy5mbGF0dGVuTmFtZUFycmF5TWFwID0gZmxhdHRlbk5hbWVBcnJheU1hcDtcbmZ1bmN0aW9uIHVuZmxhdHRlblRvTmFtZUFycmF5TWFwKGtleXMsIGZsYXRBcnJheXMpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IGZsYXRBcnJheXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1bmZsYXR0ZW4gTkRBcnJheVtdLCBrZXlzIGFuZCBhcnJheXMgYXJlIG5vdCBvZiBzYW1lIGxlbmd0aC5cIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2tleXNbaV1dID0gZmxhdEFycmF5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5mbGF0dGVuVG9OYW1lQXJyYXlNYXAgPSB1bmZsYXR0ZW5Ub05hbWVBcnJheU1hcDtcbmZ1bmN0aW9uIGhhc0VuY29kaW5nTG9zcyhvbGRUeXBlLCBuZXdUeXBlKSB7XG4gICAgaWYgKG5ld1R5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZXdUeXBlID09PSAnaW50MzInICYmIG9sZFR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZXdUeXBlID09PSAnYm9vbCcgJiYgb2xkVHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmhhc0VuY29kaW5nTG9zcyA9IGhhc0VuY29kaW5nTG9zcztcbmZ1bmN0aW9uIG5leHRGcmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcbn1cbmV4cG9ydHMubmV4dEZyYW1lID0gbmV4dEZyYW1lO1xuZnVuY3Rpb24gY29weVR5cGVkQXJyYXkoYXJyYXksIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHZhciB2YWxzID0gbmV3IEludDMyQXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoaXNWYWxOYU4odmFsLCAnaW50MzInKSkge1xuICAgICAgICAgICAgICAgIHZhbHNbaV0gPSBnZXROYU4oJ2ludDMyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhciBib29sID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoaXNWYWxOYU4odmFsLCAnYm9vbCcpKSB7XG4gICAgICAgICAgICAgICAgYm9vbFtpXSA9IGdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5yb3VuZCh2YWwpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYm9vbFtpXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmNvcHlUeXBlZEFycmF5ID0gY29weVR5cGVkQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlcnNpb24gPSAnMC40LjInO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqXG4gKiBEZWZpbmVzIGFuIGludGVyZmFjZSBmb3IgY3JlYXRpbmcgUG9seW1lciBlbGVtZW50cyBpbiBUeXBlc2NyaXB0IHdpdGggdGhlXG4gKiBjb3JyZWN0IHR5cGluZ3MuIEEgUG9seW1lciBlbGVtZW50IHNob3VsZCBiZSBkZWZpbmVkIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBcbiAqIGxldCBNeUVsZW1lbnRQb2x5bWVyID0gUG9seW1lckVsZW1lbnQoe1xuICogICBpczogJ215LXBvbHltZXItZWxlbWVudCcsXG4gKiAgIHByb3BlcnRpZXM6IHtcbiAqICAgICBmb286IHN0cmluZyxcbiAqICAgICBiYXI6IEFycmF5XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIE15RWxlbWVudFBvbHltZXIge1xuICogICBmb286IHN0cmluZztcbiAqICAgYmFyOiBudW1iZXJbXTtcbiAqXG4gKiAgIHJlYWR5KCkge1xuICogICAgIGNvbnNvbGUubG9nKCdNeUVsZW1lbnQgaW5pdGlhbGl6ZWQhJyk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoTXlFbGVtZW50LnByb3RvdHlwZS5pcywgTXlFbGVtZW50KTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB0eXBlIFNwZWMgPSB7XG4gIGlzOiBzdHJpbmc7IHByb3BlcnRpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiAoRnVuY3Rpb258e1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgdHlwZTogRnVuY3Rpb24sIHZhbHVlPzogYW55O1xuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlPzogYm9vbGVhbjtcbiAgICAgIHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICAgIG5vdGlmeT86IGJvb2xlYW47XG4gICAgICBjb21wdXRlZD86IHN0cmluZztcbiAgICAgIG9ic2VydmVyPzogc3RyaW5nO1xuICAgIH0pXG4gIH07XG4gIG9ic2VydmVycz86IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIFBvbHltZXJFbGVtZW50KHNwZWM6IFNwZWMpIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICByZXR1cm4gUG9seW1lci5DbGFzcyhzcGVjIGFzIGFueSkgYXMge25ldyAoKTogUG9seW1lckhUTUxFbGVtZW50fTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2x5bWVySFRNTEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgcG9seW1lci5CYXNlIHt9XG4iLCIvLyBBIGxpYnJhcnkgb2Ygc2VlZGFibGUgUk5HcyBpbXBsZW1lbnRlZCBpbiBKYXZhc2NyaXB0LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuLy8gdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oMSk7IC8vIG9yIGFueSBzZWVkLlxuLy8gdmFyIHggPSByYW5kb20oKTsgICAgICAgLy8gMCA8PSB4IDwgMS4gIEV2ZXJ5IGJpdCBpcyByYW5kb20uXG4vLyB2YXIgeCA9IHJhbmRvbS5xdWljaygpOyAvLyAwIDw9IHggPCAxLiAgMzIgYml0cyBvZiByYW5kb21uZXNzLlxuXG4vLyBhbGVhLCBhIDUzLWJpdCBtdWx0aXBseS13aXRoLWNhcnJ5IGdlbmVyYXRvciBieSBKb2hhbm5lcyBCYWFnw7hlLlxuLy8gUGVyaW9kOiB+Ml4xMTZcbi8vIFJlcG9ydGVkIHRvIHBhc3MgYWxsIEJpZ0NydXNoIHRlc3RzLlxudmFyIGFsZWEgPSByZXF1aXJlKCcuL2xpYi9hbGVhJyk7XG5cbi8vIHhvcjEyOCwgYSBwdXJlIHhvci1zaGlmdCBnZW5lcmF0b3IgYnkgR2VvcmdlIE1hcnNhZ2xpYS5cbi8vIFBlcmlvZDogMl4xMjgtMS5cbi8vIFJlcG9ydGVkIHRvIGZhaWw6IE1hdHJpeFJhbmsgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yMTI4ID0gcmVxdWlyZSgnLi9saWIveG9yMTI4Jyk7XG5cbi8vIHhvcndvdywgR2VvcmdlIE1hcnNhZ2xpYSdzIDE2MC1iaXQgeG9yLXNoaWZ0IGNvbWJpbmVkIHBsdXMgd2V5bC5cbi8vIFBlcmlvZDogMl4xOTItMl4zMlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogQ29sbGlzaW9uT3ZlciwgU2ltcFBva2VyLCBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3J3b3cgPSByZXF1aXJlKCcuL2xpYi94b3J3b3cnKTtcblxuLy8geG9yc2hpZnQ3LCBieSBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllciwgdGFrZXNcbi8vIGEgZGlmZmVyZW50IGFwcHJvYWNoOiBpdCBhZGRzIHJvYnVzdG5lc3MgYnkgYWxsb3dpbmcgbW9yZSBzaGlmdHNcbi8vIHRoYW4gTWFyc2FnbGlhJ3Mgb3JpZ2luYWwgdGhyZWUuICBJdCBpcyBhIDctc2hpZnQgZ2VuZXJhdG9yXG4vLyB3aXRoIDI1NiBiaXRzLCB0aGF0IHBhc3NlcyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RtYXRpYyBmYWlsdXJlcy5cbi8vIFBlcmlvZCAyXjI1Ni0xLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3JzaGlmdDcgPSByZXF1aXJlKCcuL2xpYi94b3JzaGlmdDcnKTtcblxuLy8geG9yNDA5NiwgYnkgUmljaGFyZCBCcmVudCwgaXMgYSA0MDk2LWJpdCB4b3Itc2hpZnQgd2l0aCBhXG4vLyB2ZXJ5IGxvbmcgcGVyaW9kIHRoYXQgYWxzbyBhZGRzIGEgV2V5bCBnZW5lcmF0b3IuIEl0IGFsc28gcGFzc2VzXG4vLyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RlbWF0aWMgZmFpbHVyZXMuICBJdHMgbG9uZyBwZXJpb2QgbWF5XG4vLyBiZSB1c2VmdWwgaWYgeW91IGhhdmUgbWFueSBnZW5lcmF0b3JzIGFuZCBuZWVkIHRvIGF2b2lkXG4vLyBjb2xsaXNpb25zLlxuLy8gUGVyaW9kOiAyXjQxMjgtMl4zMi5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yNDA5NiA9IHJlcXVpcmUoJy4vbGliL3hvcjQwOTYnKTtcblxuLy8gVHljaGUtaSwgYnkgU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLCBpcyBhIGJpdC1zaGlmdGluZyByYW5kb21cbi8vIG51bWJlciBnZW5lcmF0b3IgZGVyaXZlZCBmcm9tIENoYUNoYSwgYSBtb2Rlcm4gc3RyZWFtIGNpcGhlci5cbi8vIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG4vLyBQZXJpb2Q6IH4yXjEyN1xuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB0eWNoZWkgPSByZXF1aXJlKCcuL2xpYi90eWNoZWknKTtcblxuLy8gVGhlIG9yaWdpbmFsIEFSQzQtYmFzZWQgcHJuZyBpbmNsdWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4vLyBQZXJpb2Q6IH4yXjE2MDBcbnZhciBzciA9IHJlcXVpcmUoJy4vc2VlZHJhbmRvbScpO1xuXG5zci5hbGVhID0gYWxlYTtcbnNyLnhvcjEyOCA9IHhvcjEyODtcbnNyLnhvcndvdyA9IHhvcndvdztcbnNyLnhvcnNoaWZ0NyA9IHhvcnNoaWZ0NztcbnNyLnhvcjQwOTYgPSB4b3I0MDk2O1xuc3IudHljaGVpID0gdHljaGVpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNyO1xuIiwiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufVxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIl19
